{
    "related_entities": {
        "methods": [
            {
                "start_line": 88,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public EnumDeserializer(EnumResolver byNameResolver, boolean caseInsensitive,",
                "distance": 1.0,
                "title": null,
                "name": "EnumDeserializer",
                "documentation": "/**\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    }
                ],
                "similarity": 0.10012898692586421,
                "end_line": 88,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer(EnumResolver byNameResolver, boolean caseInsensitive, EnumResolver byEnumNamingResolver)"
            },
            {
                "start_line": 103,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected EnumDeserializer(EnumDeserializer base, Boolean caseInsensitive,",
                "distance": 1.0,
                "title": null,
                "name": "EnumDeserializer",
                "documentation": "/**\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    }
                ],
                "similarity": 0.09922166368752271,
                "end_line": 103,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer(EnumDeserializer base, Boolean caseInsensitive, Boolean useDefaultValueForUnknownEnum, Boolean useNullForUnknownEnum)"
            },
            {
                "start_line": 80,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public EnumDeserializer(EnumResolver byNameResolver, Boolean caseInsensitive)",
                "distance": 1.0,
                "title": null,
                "name": "EnumDeserializer",
                "documentation": "/**\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    }
                ],
                "similarity": 0.09838701448817817,
                "end_line": 80,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer(EnumResolver byNameResolver, Boolean caseInsensitive)"
            },
            {
                "start_line": 122,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected EnumDeserializer(EnumDeserializer base, Boolean caseInsensitive) {\n        this(base, caseInsensitive, null, null);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "EnumDeserializer",
                "documentation": "/**\n     * @since 2.9\n     * @deprecated Since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    }
                ],
                "similarity": 0.09716275413919652,
                "end_line": 124,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer(EnumDeserializer base, Boolean caseInsensitive)"
            },
            {
                "start_line": 130,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public EnumDeserializer(EnumResolver byNameResolver) {\n        this(byNameResolver, null);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "EnumDeserializer",
                "documentation": "/**\n     * @deprecated Since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    }
                ],
                "similarity": 0.09638723460711288,
                "end_line": 132,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer(EnumResolver byNameResolver)"
            },
            {
                "start_line": 2236,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected String _shapeForToken(JsonToken t) {\n        if (t != null) {\n            switch (t) {\n            // Likely Object values\n            case START_OBJECT:\n            case END_OBJECT:\n            case FIELD_NAME:\n                return \"Object value\";\n\n            // Likely Array values\n            case START_ARRAY:\n            case END_ARRAY:\n                return \"Array value\";\n\n            case VALUE_FALSE:\n            case VALUE_TRUE:\n                return \"Boolean value\";\n\n            case VALUE_EMBEDDED_OBJECT:\n                return \"Embedded Object\";\n\n            case VALUE_NUMBER_FLOAT:\n                return \"Floating-point value\";\n            case VALUE_NUMBER_INT:\n                return \"Integer value\";\n            case VALUE_STRING:\n                return \"String value\";\n\n            case VALUE_NULL:\n                return \"Null value\";\n\n            case NOT_AVAILABLE:\n            default:\n                return \"[Unavailable value]\";\n            }\n        }\n        return \"<end of input>\";\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_shapeForToken",
                "documentation": "/**\n     * Helper method for constructing description like \"Object value\" given\n     * {@link JsonToken} encountered.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_shapeForToken"
                    }
                ],
                "similarity": 0.09510357841195989,
                "end_line": 2273,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext._shapeForToken(JsonToken t): String"
            },
            {
                "start_line": 151,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config,",
                "distance": 1.25,
                "title": null,
                "name": "deserializerForCreator",
                "documentation": "/**\n     * Factory method used when Enum instances are to be deserialized\n     * using a creator (static factory method)\n     *\n     * @return Deserializer based on given factory method\n     *\n     * @since 2.8\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "deserializerForCreator"
                    }
                ],
                "similarity": 0.09467132943149976,
                "end_line": 151,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.deserializerForCreator(DeserializationConfig config, Class enumClass, AnnotatedMethod factory, ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps): JsonDeserializer"
            },
            {
                "start_line": 971,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findRootValueDeserializer(type);\n        if (deser == null) {\n            return reportBadDefinition(type,\n                    \"Could not find JsonDeserializer for type \"+ClassUtil.getTypeDescription(type));\n        }\n        return (T) deser.deserialize(p, this);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.0921001776034381,
                "end_line": 978,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readValue(JsonParser p, JavaType type): T"
            },
            {
                "start_line": 432,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected CompactStringObjectMap _getToStringLookup(DeserializationContext ctxt) {\n        CompactStringObjectMap lookup = _lookupByToString;\n        if (lookup == null) {\n            synchronized (this) {\n                lookup = _lookupByToString;\n                if (lookup == null) {\n                    lookup = EnumResolver.constructUsingToString(ctxt.getConfig(), _enumClass())\n                        .constructLookup();\n                    _lookupByToString = lookup;\n                }\n            }\n        }\n        return lookup;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_getToStringLookup",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_getToStringLookup"
                    }
                ],
                "similarity": 0.09008636502854994,
                "end_line": 445,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer._getToStringLookup(DeserializationContext ctxt): CompactStringObjectMap"
            },
            {
                "start_line": 597,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {\n        try {\n            return _cache.hasValueDeserializerFor(this, _factory, type);\n        } catch (DatabindException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { // earlier behavior\n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasValueDeserializerFor",
                "documentation": "/**\n     * Method for checking whether we could find a deserializer\n     * for given type.\n     *\n     * @param type Type to check\n     * @param cause (optional) Reference set to root cause if no deserializer\n     *    could be found due to exception (to find the reason for failure)\n     *\n     * @since 2.3\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasValueDeserializerFor"
                    }
                ],
                "similarity": 0.08837119048401028,
                "end_line": 611,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.hasValueDeserializerFor(JavaType type, AtomicReference cause): boolean"
            },
            {
                "start_line": 172,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static JsonDeserializer<?> deserializerForNoArgsCreator(DeserializationConfig config,",
                "distance": 1.25,
                "title": null,
                "name": "deserializerForNoArgsCreator",
                "documentation": "/**\n     * Factory method used when Enum instances are to be deserialized\n     * using a zero-/no-args factory method\n     *\n     * @return Deserializer based on given no-args factory method\n     *\n     * @since 2.8\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "deserializerForNoArgsCreator"
                    }
                ],
                "similarity": 0.08779560328040972,
                "end_line": 172,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.deserializerForNoArgsCreator(DeserializationConfig config, Class enumClass, AnnotatedMethod factory): JsonDeserializer"
            },
            {
                "start_line": 454,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected boolean useDefaultValueForUnknownEnum(DeserializationContext ctxt) {\n        return (_enumDefaultValue != null)\n          && (Boolean.TRUE.equals(_useDefaultValueForUnknownEnum)\n          || ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "useDefaultValueForUnknownEnum",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "useDefaultValueForUnknownEnum"
                    }
                ],
                "similarity": 0.0869680729193327,
                "end_line": 458,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.useDefaultValueForUnknownEnum(DeserializationContext ctxt): boolean"
            },
            {
                "start_line": 200,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public EnumDeserializer withResolved(Boolean caseInsensitive) {\n        return withResolved(caseInsensitive,\n                _useDefaultValueForUnknownEnum, _useNullForUnknownEnum);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "withResolved",
                "documentation": "/**\n     * @since 2.9\n     * @deprecated Since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withResolved"
                    }
                ],
                "similarity": 0.08652120955374881,
                "end_line": 203,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.withResolved(Boolean caseInsensitive): EnumDeserializer"
            },
            {
                "start_line": 1663,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "setSubtypeResolver",
                "documentation": "/**\n     * Method for setting custom subtype resolver to use.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "setSubtypeResolver"
                    }
                ],
                "similarity": 0.08626634682421809,
                "end_line": 1668,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.setSubtypeResolver(SubtypeResolver str): ObjectMapper"
            },
            {
                "start_line": 288,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private CompactStringObjectMap _resolveCurrentLookup(DeserializationContext ctxt) {\n        if (_lookupByEnumNaming != null) {\n            return _lookupByEnumNaming;\n        }\n        return ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n            ? _getToStringLookup(ctxt)\n            : _lookupByName;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_resolveCurrentLookup",
                "documentation": "/**\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_resolveCurrentLookup"
                    }
                ],
                "similarity": 0.08337568287099695,
                "end_line": 295,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer._resolveCurrentLookup(DeserializationContext ctxt): CompactStringObjectMap"
            },
            {
                "start_line": 448,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected boolean useNullForUnknownEnum(DeserializationContext ctxt) {\n        return Boolean.TRUE.equals(_useNullForUnknownEnum)\n          || ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "useNullForUnknownEnum",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "useNullForUnknownEnum"
                    }
                ],
                "similarity": 0.08069022031793571,
                "end_line": 451,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.useNullForUnknownEnum(DeserializationContext ctxt): boolean"
            },
            {
                "start_line": 1004,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findContextualValueDeserializer(type, prop);\n        if (deser == null) {\n            return reportBadDefinition(type, String.format(\n                    \"Could not find JsonDeserializer for type %s (via property %s)\",\n                    ClassUtil.getTypeDescription(type), ClassUtil.nameOf(prop)));\n        }\n        return (T) deser.deserialize(p, this);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readPropertyValue",
                "documentation": "/**\n     * Same as {@link #readPropertyValue(JsonParser, BeanProperty, Class)} but with\n     * fully resolved {@link JavaType} as target: needs to be used for generic types,\n     * for example.\n     *\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readPropertyValue"
                    }
                ],
                "similarity": 0.08023710725360063,
                "end_line": 1012,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readPropertyValue(JsonParser p, BeanProperty prop, JavaType type): T"
            },
            {
                "start_line": 185,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public EnumDeserializer withResolved(Boolean caseInsensitive,",
                "distance": 1.25,
                "title": null,
                "name": "withResolved",
                "documentation": "/**\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "withResolved"
                    }
                ],
                "similarity": 0.07775216300706123,
                "end_line": 185,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.withResolved(Boolean caseInsensitive, Boolean useDefaultValueForUnknownEnum, Boolean useNullForUnknownEnum): EnumDeserializer"
            },
            {
                "start_line": 107,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public abstract T deserialize(JsonParser p, DeserializationContext ctxt)",
                "distance": 1.0,
                "title": null,
                "name": "deserialize",
                "documentation": "/**\n     * Method that can be called to ask implementation to deserialize\n     * JSON content into the value type this serializer handles.\n     * Returned instance is to be constructed by method itself.\n     *<p>\n     * Pre-condition for this method is that the parser points to the\n     * first event that is part of value to deserializer (and which\n     * is never JSON 'null' literal, more on this below): for simple\n     * types it may be the only value; and for structured types the\n     * Object start marker or a FIELD_NAME.\n     * </p>\n     * <p>\n     * The two possible input conditions for structured types result\n     * from polymorphism via fields. In the ordinary case, Jackson\n     * calls this method when it has encountered an OBJECT_START,\n     * and the method implementation must advance to the next token to\n     * see the first field name. If the application configures\n     * polymorphism via a field, then the object looks like the following.\n     *  <pre>\n     *      {\n     *          \"@class\": \"class name\",\n     *          ...\n     *      }\n     *  </pre>\n     *  Jackson consumes the two tokens (the <tt>@class</tt> field name\n     *  and its value) in order to learn the class and select the deserializer.\n     *  Thus, the stream is pointing to the FIELD_NAME for the first field\n     *  after the @class. Thus, if you want your method to work correctly\n     *  both with and without polymorphism, you must begin your method with:\n     *  <pre>\n     *       if (p.currentToken() == JsonToken.START_OBJECT) {\n     *         p.nextToken();\n     *       }\n     *  </pre>\n     * This results in the stream pointing to the field name, so that\n     * the two conditions align.\n     * <p>\n     * Post-condition is that the parser will point to the last\n     * event that is part of deserialized value (or in case deserialization\n     * fails, event that was not recognized or usable, which may be\n     * the same event as the one it pointed to upon call).\n     *<p>\n     * Note that this method is never called for JSON null literal,\n     * and thus deserializers need (and should) not check for it.\n     *\n     * @param p Parsed used for reading JSON content\n     * @param ctxt Context that can be used to access information about\n     *   this deserialization activity.\n     *\n     * @return Deserialized value\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "deserialize"
                    }
                ],
                "similarity": 0.07743457419354392,
                "end_line": 107,
                "signature": "com.fasterxml.jackson.databind.JsonDeserializer.deserialize(JsonParser p, DeserializationContext ctxt): T"
            },
            {
                "start_line": 248,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DeserializationContext(DeserializationContext src) {\n        _cache = new DeserializerCache();\n        _factory = src._factory;\n\n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _readCapabilities = src._readCapabilities;\n        _view = src._view;\n        _injectableValues = null;\n    }",
                "distance": 1.0,
                "title": null,
                "name": "DeserializationContext",
                "documentation": "/**\n     * Copy-constructor for use with <code>copy()</code> by {@link ObjectMapper#copy()}\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    }
                ],
                "similarity": 0.07724530907439496,
                "end_line": 257,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext(DeserializationContext src)"
            },
            {
                "start_line": 168,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DeserializationContext(DeserializerFactory df,",
                "distance": 1.0,
                "title": null,
                "name": "DeserializationContext",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    }
                ],
                "similarity": 0.07622407519299712,
                "end_line": 168,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext(DeserializerFactory df, DeserializerCache cache)"
            },
            {
                "start_line": 2047,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        // [databind#2162]: use specific exception type as we don't know if it's\n        // due to type definition, input, or neither\n        return ValueInstantiationException.from(_parser, msg, constructType(instClass), cause);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "instantiationException",
                "documentation": "/**\n     * Helper method for constructing instantiation exception for specified type,\n     * to indicate problem with physically constructing instance of\n     * specified class (missing constructor, exception from constructor)\n     *<p>\n     * Note that most of the time this method should NOT be called directly; instead,\n     * {@link #handleInstantiationProblem} should be called which will call this method\n     * if necessary.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "instantiationException"
                    }
                ],
                "similarity": 0.0760887629586676,
                "end_line": 2059,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.instantiationException(Class instClass, Throwable cause): JsonMappingException"
            },
            {
                "start_line": 4301,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader readerForArrayOf(Class<?> type) {\n        _assertNotNull(\"type\", type);\n        return _newReader(getDeserializationConfig(),\n                _typeFactory.constructArrayType(type), null,\n                null, _injectableValues);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readerForArrayOf",
                "documentation": "/**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read values of a type {@code List<type>}.\n     * Functionally same as:\n     *<pre>\n     *    readerFor(type[].class);\n     *</pre>\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readerForArrayOf"
                    }
                ],
                "similarity": 0.07579002763783253,
                "end_line": 4306,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.readerForArrayOf(Class type): ObjectReader"
            },
            {
                "start_line": 803,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated,",
                "distance": 1.25,
                "title": null,
                "name": "deserializerInstance",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "deserializerInstance"
                    }
                ],
                "similarity": 0.07334157168417366,
                "end_line": 803,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.deserializerInstance(Annotated annotated, Object deserDef): JsonDeserializer"
            },
            {
                "start_line": 208,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonDeserializer<Object> deserializerInstance(Annotated ann, Object deserDef)",
                "distance": 1.25,
                "title": null,
                "name": "deserializerInstance",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DefaultDeserializationContext"
                    },
                    {
                        "start_node": "DefaultDeserializationContext",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "deserializerInstance"
                    }
                ],
                "similarity": 0.07294278023979979,
                "end_line": 208,
                "signature": "com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.deserializerInstance(Annotated ann, Object deserDef): JsonDeserializer"
            },
            {
                "start_line": 2749,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectMapper configure(DatatypeFeature f, boolean state) {\n        if (state) {\n            _deserializationConfig = _deserializationConfig.with(f);\n            _serializationConfig = _serializationConfig.with(f);\n        } else {\n            _deserializationConfig = _deserializationConfig.without(f);\n            _serializationConfig = _serializationConfig.without(f);\n        }\n        return this;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "configure",
                "documentation": "/**\n     * Method for changing state of an on/off datatype-specific feature for\n     * this object mapper.\n     * <p>\n     * Note: Changing the configuration of this {@link ObjectMapper} instance after its first use (read &amp; write) is\n     * not safe and should not be attempted. Instead, use {@code with()} and {@code without()} methods of\n     * {@link ObjectReader}/{@link ObjectWriter} which fully support reconfiguration as new instances are constructed.\n     * <p>\n     * <strong>This method will be removed in Jackson 3.0 due to unsafe usage.\n     * Configure using {@link MapperBuilder#configure(DatatypeFeature, boolean)} instead.</strong>\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "configure"
                    }
                ],
                "similarity": 0.07139951189332082,
                "end_line": 2758,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.configure(DatatypeFeature f, boolean state): ObjectMapper"
            },
            {
                "start_line": 237,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n        return _enumDefaultValue;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "getEmptyValue",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "getEmptyValue"
                    }
                ],
                "similarity": 0.07138792994683202,
                "end_line": 239,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.getEmptyValue(DeserializationContext ctxt): Object"
            },
            {
                "start_line": 1329,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(byte[] content, int offset, int len) throws IOException {\n        _assertNotNull(\"content\", content);\n        return _deserializationConfig.initialize(_jsonFactory.createParser(content, offset, len));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Factory method for constructing properly initialized {@link JsonParser}\n     * to read content from specified byte array.\n     * Parser is not managed (or \"owned\") by ObjectMapper: caller is responsible\n     * for properly closing it once content reading is complete.\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.07024327767331488,
                "end_line": 1332,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.createParser(byte[] content, int offset, int len): JsonParser"
            },
            {
                "start_line": 2070,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonMappingException instantiationException(Class<?> instClass, String msg0) {\n        // [databind#2162]: use specific exception type as we don't know if it's\n        // due to type definition, input, or neither\n        return ValueInstantiationException.from(_parser,\n                String.format(\"Cannot construct instance of %s: %s\",\n                        ClassUtil.nameOf(instClass), msg0),\n                constructType(instClass));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "instantiationException",
                "documentation": "/**\n     * Helper method for constructing instantiation exception for specified type,\n     * to indicate that instantiation failed due to missing instantiator\n     * (creator; constructor or factory method).\n     *<p>\n     * Note that most of the time this method should NOT be called; instead,\n     * {@link #handleMissingInstantiator} should be called which will call this method\n     * if necessary.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "instantiationException"
                    }
                ],
                "similarity": 0.06911397228704698,
                "end_line": 2077,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.instantiationException(Class instClass, String msg0): JsonMappingException"
            },
            {
                "start_line": 428,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected Class<?> _enumClass() {\n        return handledType();\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_enumClass",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_enumClass"
                    }
                ],
                "similarity": 0.06827418384119252,
                "end_line": 430,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer._enumClass(): Class"
            },
            {
                "start_line": 138,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config,",
                "distance": 1.25,
                "title": null,
                "name": "deserializerForCreator",
                "documentation": "/**\n     * @deprecated Since 2.8\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "deserializerForCreator"
                    }
                ],
                "similarity": 0.06804487365479421,
                "end_line": 138,
                "signature": "com.fasterxml.jackson.databind.deser.std.EnumDeserializer.deserializerForCreator(DeserializationConfig config, Class enumClass, AnnotatedMethod factory): JsonDeserializer"
            },
            {
                "start_line": 164,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DeserializationContext(DeserializerFactory df) {\n        this(df, null);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "DeserializationContext",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    }
                ],
                "similarity": 0.06764131483121615,
                "end_line": 166,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext(DeserializerFactory df)"
            },
            {
                "start_line": 4318,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader readerForListOf(Class<?> type) {\n        _assertNotNull(\"type\", type);\n        return _newReader(getDeserializationConfig(),\n                _typeFactory.constructCollectionType(List.class, type), null,\n                null, _injectableValues);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readerForListOf",
                "documentation": "/**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of a type {@code List<type>}.\n     * Functionally same as:\n     *<pre>\n     *    readerFor(new TypeReference&lt;List&lt;type&gt;&gt;() { });\n     *</pre>\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readerForListOf"
                    }
                ],
                "similarity": 0.06733618965892366,
                "end_line": 4323,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.readerForListOf(Class type): ObjectReader"
            },
            {
                "start_line": 3363,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createArrayNode",
                "documentation": "/**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction cannot refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createArrayNode"
                    }
                ],
                "similarity": 0.06707646704951492,
                "end_line": 3365,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.createArrayNode(): ArrayNode"
            },
            {
                "start_line": 618,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type,",
                "distance": 1.25,
                "title": null,
                "name": "findContextualValueDeserializer",
                "documentation": "/**\n     * Method for finding a value deserializer, and creating a contextual\n     * version if necessary, for value reached via specified property.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findContextualValueDeserializer"
                    }
                ],
                "similarity": 0.06663502474372705,
                "end_line": 618,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(JavaType type, BeanProperty prop): JsonDeserializer"
            },
            {
                "start_line": 4426,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "reader",
                "documentation": "/**\n     * @deprecated Since 2.5, use {@link #readerFor(TypeReference)} instead\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "reader"
                    }
                ],
                "similarity": 0.06659031790157355,
                "end_line": 4429,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.reader(TypeReference type): ObjectReader"
            },
            {
                "start_line": 1368,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(char[] content, int offset, int len) throws IOException {\n        _assertNotNull(\"content\", content);\n        return _deserializationConfig.initialize(_jsonFactory.createParser(content, offset, len));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Factory method for constructing properly initialized {@link JsonParser}\n     * to read content from specified character array.\n     * Parser is not managed (or \"owned\") by ObjectMapper: caller is responsible\n     * for properly closing it once content reading is complete.\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.06606442820514281,
                "end_line": 1371,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.createParser(char[] content, int offset, int len): JsonParser"
            },
            {
                "start_line": 1767,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectMapper setPolymorphicTypeValidator(PolymorphicTypeValidator ptv) {\n        BaseSettings s = _deserializationConfig.getBaseSettings().with(ptv);\n        _deserializationConfig = _deserializationConfig._withBase(s);\n        return this;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "setPolymorphicTypeValidator",
                "documentation": "/**\n     * Method for specifying {@link PolymorphicTypeValidator} to use for validating\n     * polymorphic subtypes used with explicit polymorphic types (annotation-based),\n     * but NOT one with \"default typing\" (see {@link #activateDefaultTyping(PolymorphicTypeValidator)}\n     * for details).\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "setPolymorphicTypeValidator"
                    }
                ],
                "similarity": 0.06594507317051612,
                "end_line": 1771,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.setPolymorphicTypeValidator(PolymorphicTypeValidator ptv): ObjectMapper"
            },
            {
                "start_line": 1781,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public PolymorphicTypeValidator getPolymorphicTypeValidator() {\n        return _deserializationConfig.getBaseSettings().getPolymorphicTypeValidator();\n    }",
                "distance": 1.25,
                "title": null,
                "name": "getPolymorphicTypeValidator",
                "documentation": "/**\n     * Accessor for configured {@link PolymorphicTypeValidator} used for validating\n     * polymorphic subtypes used with explicit polymorphic types (annotation-based),\n     * but NOT one with \"default typing\" (see {@link #activateDefaultTyping(PolymorphicTypeValidator)}\n     * for details).\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "getPolymorphicTypeValidator"
                    }
                ],
                "similarity": 0.06559495037032123,
                "end_line": 1783,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.getPolymorphicTypeValidator(): PolymorphicTypeValidator"
            },
            {
                "start_line": 4249,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = (valueToUpdate == null) ? null\n                : _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readerForUpdating",
                "documentation": "/**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readerForUpdating"
                    }
                ],
                "similarity": 0.06557773454025392,
                "end_line": 4254,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.readerForUpdating(Object valueToUpdate): ObjectReader"
            },
            {
                "start_line": 1316,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(byte[] content) throws IOException {\n        _assertNotNull(\"content\", content);\n        return _deserializationConfig.initialize(_jsonFactory.createParser(content));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Factory method for constructing properly initialized {@link JsonParser}\n     * to read content from specified byte array.\n     * Parser is not managed (or \"owned\") by ObjectMapper: caller is responsible\n     * for properly closing it once content reading is complete.\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.06541272423453413,
                "end_line": 1319,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.createParser(byte[] content): JsonParser"
            },
            {
                "start_line": 44,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache) {\n        super(df, cache);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "DefaultDeserializationContext",
                "documentation": "/**\n     * Constructor that will pass specified deserializer factory and\n     * cache: cache may be null (in which case default implementation\n     * will be used), factory cannot be null\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DefaultDeserializationContext"
                    }
                ],
                "similarity": 0.06528381092636816,
                "end_line": 46,
                "signature": "com.fasterxml.jackson.databind.deser.DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache)"
            },
            {
                "start_line": 963,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, Class<T> type) throws IOException {\n        return readValue(p, getTypeFactory().constructType(type));\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Convenience method that may be used by composite or container deserializers,\n     * for reading one-off values contained (for sequences, it is more efficient\n     * to actually fetch deserializer once for the whole collection).\n     *<p>\n     * NOTE: when deserializing values of properties contained in composite types,\n     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};\n     * this method does not allow use of contextual annotations.\n     *\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.06513617650101099,
                "end_line": 965,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readValue(JsonParser p, Class type): T"
            },
            {
                "start_line": 2200,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {\n        return JsonMappingException.from(_parser,\n                String.format(\"Cannot deserialize instance of %s out of %s token\",\n                        ClassUtil.nameOf(targetClass), token));\n    }",
                "distance": 1.25,
                "title": null,
                "name": "mappingException",
                "documentation": "/**\n     * @deprecated Since 2.8 use {@link #handleUnexpectedToken(Class, JsonParser)} instead\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "mappingException"
                    }
                ],
                "similarity": 0.06512184147598798,
                "end_line": 2204,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.mappingException(Class targetClass, JsonToken token): JsonMappingException"
            },
            {
                "start_line": 4946,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,",
                "distance": 1.25,
                "title": null,
                "name": "_findRootDeserializer",
                "documentation": "/**\n     * Method called to locate deserializer for the passed root-level value.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_findRootDeserializer"
                    }
                ],
                "similarity": 0.06508640403049706,
                "end_line": 4946,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(DeserializationContext ctxt, JavaType valueType): JsonDeserializer"
            },
            {
                "start_line": 4285,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader readerFor(TypeReference<?> typeRef) {\n        _assertNotNull(\"type\", typeRef);\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(typeRef), null,\n                null, _injectableValues);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readerFor",
                "documentation": "/**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     *\n     * @since 2.6\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readerFor"
                    }
                ],
                "similarity": 0.06502072988890963,
                "end_line": 4289,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.readerFor(TypeReference typeRef): ObjectReader"
            },
            {
                "start_line": 306,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public abstract DefaultDeserializationContext createDummyInstance(",
                "distance": 1.25,
                "title": null,
                "name": "createDummyInstance",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DefaultDeserializationContext"
                    },
                    {
                        "start_node": "DefaultDeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createDummyInstance"
                    }
                ],
                "similarity": 0.0647699571791264,
                "end_line": 306,
                "signature": "com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.createDummyInstance(DeserializationConfig config): DefaultDeserializationContext"
            },
            {
                "start_line": 76,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/FactoryBasedEnumDeserializer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected FactoryBasedEnumDeserializer(FactoryBasedEnumDeserializer base,",
                "distance": 2.25,
                "title": null,
                "name": "FactoryBasedEnumDeserializer",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "EnumDeserializer"
                    },
                    {
                        "start_node": "EnumDeserializer",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "deserializerForCreator"
                    },
                    {
                        "start_node": "deserializerForCreator",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "FactoryBasedEnumDeserializer"
                    }
                ],
                "similarity": 0.06456931626463451,
                "end_line": 76,
                "signature": "com.fasterxml.jackson.databind.deser.std.FactoryBasedEnumDeserializer(FactoryBasedEnumDeserializer base, JsonDeserializer deser)"
            },
            {
                "start_line": 1450,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "setSerializerFactory",
                "documentation": "/**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "setSerializerFactory"
                    }
                ],
                "similarity": 0.06448281301678369,
                "end_line": 1453,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.setSerializerFactory(SerializerFactory f): ObjectMapper"
            },
            {
                "start_line": 2217,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DateFormat _getDateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        /* 24-Feb-2012, tatu: At this point, all timezone configuration\n         *    should have occurred, with respect to default dateformat\n         *    and timezone configuration. But we still better clone\n         *    an instance as formatters may be stateful.\n         */\n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        return df;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_getDateFormat",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_getDateFormat"
                    }
                ],
                "similarity": 0.06428359645330617,
                "end_line": 2229,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext._getDateFormat(): DateFormat"
            }
        ],
        "classes": [],
        "issues": [
            {
                "content": "**Describe the bug**\r\nFactoryBasedEnumDeserializer is unable to deserialize enum value which is wrapped in Array.\r\n\r\n\r\n**Version information**\r\nThis is for Jackson 2.13.1 - It worked fine for release 2.10.1\r\n\r\n**To Reproduce**\r\nIf you have a way to reproduce this with:\r\n\r\n```\r\npublic class EnumDeserializeTest {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer();\r\n        Frequency frequency = Frequency.DAILY;\r\n        byte[] frequencyAsBytes = serializer.serialize(frequency);\r\n        Frequency frequencyDeserialized = mapper.readValue(frequencyAsBytes, Frequency.class);\r\n    }\r\n}\r\n```\r\n\r\nValue is serialized as : [\"Frequency\",\"DAILY\"]\r\n\r\nThis results in exception:\r\n\r\n`Exception in thread \"main\" com.fasterxml.jackson.databind.exc.ValueInstantiationException: Cannot construct instance of `Frequency`, problem: Unexpected value ''\r\n at [Source: (byte[])\"[\"Frequency\",\"DAILY\"]\"; line: 1, column: 21]\r\n\tat com.fasterxml.jackson.databind.exc.ValueInstantiationException.from(ValueInstantiationException.java:47)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:2047)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleInstantiationProblem(DeserializationContext.java:1400)\r\n\tat com.fasterxml.jackson.databind.deser.std.FactoryBasedEnumDeserializer.deserialize(FactoryBasedEnumDeserializer.java:182)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4674)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3690)\r\n\tat EnumDeserializeTest.main(EnumDeserializeTest.java:26)`\r\n\r\n\r\n**Expected behavior**\r\nDeserialization should work fine with FactoryBasedEnumDeserializer but fails when it encounters START_ARRAY token. EnumDeserializer works just fine and it is able to parse the array tokens and retrieves the enum value. Similarly, FactoryBasedEnumDeserializer should also work.\r\n\r\n**Additional context**\r\nThis issue is faced when using GenericJackson2JsonRedisSerializer. A change was made to this serialiser in Spring-data-redis 2.7.2 which uses JsonTypeInfo.Id.CLASS annotation as default for all types. Prior to this release, enum types were serialised as simple/plain values but with this change they are wrapped in an array where 1st element is denoted for class and 2nd element holds the enum value.\r\n\n",
                "distance": 0,
                "title": "`FactoryBasedEnumDeserializer` unable to deserialize enum object with Polymorphic Type Id (\"As.WRAPPER_ARRAY\") - fails on START_ARRAY token",
                "name": "root",
                "path": [],
                "issue_id": "root",
                "similarity": 2.0,
                "type": "issue"
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3724",
                "type": "issue",
                "content": "### New\r\n- Supports `@JsonCreator.mode=DISABLED` on canonical constructor.\r\n- Supports deserialization using \"implicit\" (i.e. without `@JsonCreator` annotation) non-canonical constructor when 1/more of its parameter is/are annotated with `@JsonProperty`.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating constructor.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating factory method.\r\n- Supports disabling \"implicit\" (i.e. without `@JsonCreator` annotation) constructor/factory method detection via `MapperFeature.AUTO_DETECT_CREATORS`.\r\n\r\nThis is a non-exhaustive list - I don't have full knowledge of existing JavaBeans deserialization capabilities.\r\n\r\n### Fixes\r\n- Fixes #2974\r\n- Fixes #2992\r\n- Resolves #3180 (via \"implicit\" 1-arg delegating constructor/factory method)\r\n- Fixes #3297\r\n- Fixes #3342\r\n\n\n\nComment by cowtowncoder:\nFirst of all, thank you for contributing this @yihtserns ! It sounds like solid improvement, potentially.\r\n\r\nI added some smaller notes on keeping existing API in some places, but there is one bigger request I have: this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14 -- patches are typically for smaller, less risky changes, and while I don't have specific issues here I feel there is potential for some breakage.\r\n\r\n\n\nComment by yihtserns:\n> ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n\r\nDo I put \"since 2.15\" in the deprecation notice?\r\n\r\nAnd yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter...  That doc needs to be updated?\n\nComment by cowtowncoder:\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n> \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\n\r\n\r\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n\r\nYes.\r\n \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\nThanks, I'll need to update that. There are some things that should go into earlier branches too -- generally earliest maintained, for safe enough fixes. So it is not easy to correctly guess what I think is the right branch :)\r\n(which is also why I don't mind pointing out what I think should be used).\r\n\r\n\r\n\n\nComment by cowtowncoder:\nOk, looks pretty good. I do need to go over it again with more thought, but I like how small changes are.\r\n\n\nComment by cowtowncoder:\n@yihtserns One more thing: I hope to be able to merge this soon. One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution. This only needs to be done once and then it is good for all future PRs for Jackson project.\r\n\r\nDocument is here:\r\n\r\nhttps://github.com/FasterXML/jackson/blob/master/contributor-agreement.pdf\r\n\r\nand the usual way is to print, fill & sign, scan/photo, email to `info` at fasterxml dot com.\r\nOnce I get the document I will be able to merge the PR (I will do one more code review but I assume we are very close).\r\n\r\nThank you again for providing this patch -- looking forward to merging it!\r\n\r\n\r\n\r\n\n\nComment by yihtserns:\nI'm currently re-reviewing if `@JsonIgnore` can be supported in a different way (else the explanation of the current approach will be a headache).\r\n\r\n**UPDATE**: Didn't manage to find a low-change way, so decided to stick with this approach (with some difference) + smothered it with docs.\n\nComment by yihtserns:\n> One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution\r\n\r\nCLA sent.\n\nComment by cowtowncoder:\nOk looks good, will merge! Will see how much trouble merging into `master` (3.0) will be....\n\nComment by cowtowncoder:\nUgh. Ok, so I was able to merge code. But now there are ~20 failures for Record-related tests in `master`.\r\n\r\nAlso: I think I may disagree with test\r\n\r\n        public void testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames() throws Exception\r\n\r\nwherein it is claimed there are 2 usable Creators (canonical, one with `@JsonProperty` annotation).\r\nIt seems to me that while constructor has no `@JsonCreator`, existence of `@JsonProperty` would make that explicit constructor, over canonical constructor.\r\n\r\nBut be that as it may, I think I will need help with `master`, failing tests. I think some calls are now missing so that even simplest of `Record` tests in `RecordsBasicTest` fail.\r\n\r\n\r\n\n\nComment by yihtserns:\n> But be that as it may, I think I will need help with master, failing tests.\r\n\r\nOK I'll look into them.\n\nComment by cowtowncoder:\nThank you @yihtserns! I am zeroing in on one issue: VisibilityChecker for Constructors is somehow claiming default record constructors are not visible. I'll try to see what gives...\n\nComment by cowtowncoder:\nOk, yes; there is something in minimum visibility needed; defaults are defined by `@JsonAutoDetect` annotation in `VisibilityChecker` and have changed to require `public` for 3.0.\r\n\r\nBut what seems odd to me is how canonical constructor is apparently not generated as `public` (looking at decompiled record classes) but as package default.\r\nSo I think one way to fix this would be to somehow use differently configured `VisibilityChecker` for records; similar to have \"all public\" variant is (by default) used for JDK types.\r\nLooks like logic could be injected from `getDefaultVisibilityChecker()` of `MapperConfigBase`; possibly checking if type is a record type (before even checking for \"is JDK class\").\r\n\r\n\n\nComment by yihtserns:\n> But what seems odd to me is how canonical constructor is apparently not generated as public\r\n\r\nThey aren't public because the `record` declarations weren't public.  Changing `record XXX` to `public record XXX` reduced test failures from 21 to 3.\r\n\r\n(For some of the records, although the declaration itself weren't `public`, their _declared_ constructors are `public` so they're not failing.)\n\nComment by yihtserns:\nI've created https://github.com/FasterXML/jackson-databind/pull/3733 (will remain in draft until all test failures are resolved) to deal with issues related to the 3.0 port - let's continue this conversation there.\n\nComment by yihtserns:\n@pjfanning @cowtowncoder thank you for taking the time to review this PR, I really appreciate it.\n\nComment by cowtowncoder:\nFWTW, I think this change may have also caused a regression of one Kotlin test:\r\n\r\nhttps://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\n\nComment by yihtserns:\n> FWTW, I think this change may have also caused a regression of one Kotlin test: https://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\r\nSo [Github396.kt](https://github.com/FasterXML/jackson-module-kotlin/blob/2.15/src/test/kotlin/com/fasterxml/jackson/module/kotlin/test/github/failing/Github396.kt) is a negative test that expects deserialization to fail with `MismatchedInputException`, but it is now by managing to deserialize `<product><stuff></stuff></product>` into `Product(stuff=Stuff(str=null))`.\r\n\r\nThat seems to have been caused by #3676.  When I change `BeanDeserializerBase.getEmptyValue(...)` from `_valueInstantiator.createUsingDefaultOrWithoutArguments(...)` back to `_valueInstantiator.createUsingDefault(...)`, that negative test is passing again.\n\nComment by cowtowncoder:\n@yihtserns Ok. So not these changes but earlier one; and unnoticed since there's no cascading CI builds across projects (that is, without changes to Kotlin module, no CI triggered when databind has changed -- something that'd be really nice to somehow resolve).\r\n\r\nBut this sounds like it would be a good thing? I am not big fan of negative tests because of this, although the main alternative (having failing tests under `failing/`) has the problem of \"hiding\" fixes.\r\n\r\n\n\nComment by cowtowncoder:\n@yihtserns Ok yes, thank you for pointing out the \"failing to fail\" part. This is indeed something fixed in `jackson-dataformat-xml` so I just had to change test. Looking how things work it's actually not a bad idea to verify \"is now fixed\" part... need to keep that in mind wrt other modules :)\n\nComment by yihtserns:\n> Also: I think I may disagree with test `testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames()` wherein it is claimed there are 2 usable Creators (canonical, one with @JsonProperty annotation).\r\nIt seems to me that while constructor has no @JsonCreator, existence of @JsonProperty would make that explicit constructor, over canonical constructor.\r\n\r\n@cowtowncoder when I test the POJO equivalent:\r\n```\r\npublic static class BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator {\r\n\r\n    // Private fields\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(int id, String name, String email) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n    }\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(@JsonProperty(\"id_only\") int id, String email) {\r\n        this.id = id;\r\n        this.email = email;\r\n    }\r\n\r\n    // Public getters\r\n}\r\n```\r\n\r\nI get the same failure as Records':\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.github.yihtserns.records.jackson.RecordCanonicalVsJsonPropertyTest$RecordWithJsonPropertyAndImplicitPropertyWithoutJsonCreator` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n\r\nBug?  Although from a quick search in Issues, nobody is complaining about it anyway.  \ud83e\udd37\u200d\u2642\ufe0f \n\nComment by cowtowncoder:\n@yihtserns If there is no module for getting implicit constructor parameter names, I'd expect failure since partial use of `@JsonProperty` is not enough for detection. But if parameter name detection exists, I am not 100% sure if logic would only allow it if there are no competing constructors (ones with or without annotation).\r\n\r\nThe thing that further complications matters is that POJOs do not have canonical constructor to solve the case where nothing is annotated -- but there are always implicit names.\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nRenovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n\r\nThese are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\n\nComment by yihtserns:\n@leonardehrenfried that symptom sounds similar to the one describe in https://github.com/FasterXML/jackson-databind/issues/3628#issuecomment-1504892161 - let me test that.\n\nComment by yihtserns:\n@leonardehrenfried so I tested `OpenTripPlanner`:\r\n1. Changed `jackson.version` in `pom.xml` to `2.15.0`.\r\n2. Run `mvn test` to observe the test failures (there's 1 unrelated to Records, so I'm ignoring it).\r\n3. Create a local fork of `jackson-databind:2.15.0`, reverting [0a4cfc4](https://github.com/FasterXML/jackson-databind/commit/0a4cfc46bc491aed9eab83e13dcd65d415b10c64#diff-8a89bf8f93c483493c778cda25b2e31e2e89bd4b0a8a131e71bfd2ed5a199fff).\r\n4. Change `OpenTripPlanner/pom.xml`'s `jackson-databind` to refer to that local fork.\r\n5. Run `mvn test` again - no more test failures related to Records.\r\n\r\nI've confirmed that the issue you're facing is related to the broken workaround mentioned in #3628, unrelated to this change.\n\nComment by leonardehrenfried:\nI since checked and we seem to be using a custom object mapper in the test:\r\n\r\n```\r\n      objectMapper = new ObjectMapper();\r\n      objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);\r\n      objectMapper.enable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);\r\n      objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n      objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\r\n      objectMapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);\r\n      objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n      objectMapper.registerModule(new JavaTimeModule());\r\n      objectMapper.registerModule(new Jdk8Module());\r\n\r\n      objectMapper.setVisibility(\r\n        objectMapper\r\n          .getSerializationConfig()\r\n          .getDefaultVisibilityChecker()\r\n          .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n          .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n      );\r\n```\r\n\r\nhttps://github.com/opentripplanner/OpenTripPlanner/blob/dev-2.x/src/test/java/org/opentripplanner/routing/algorithm/mapping/SnapshotTestBase.java#L366-L384\r\n\r\nSo it appears that your analysis is totally correct.\r\n\r\nI'm still not clear if this is was an intentional change in Jackson or not - can you clarify this for me?\r\n\r\nAsked the other way around: is the old behaviour going to be restored and I should just wait for a new release or do I need to change the config of my object mapper?\n\nComment by yihtserns:\n> ...do I need to change the config of my object mapper?\r\n\r\nI think that config was used because you had the same problem as #3628, and I can't think of an alternative solution for that problem.\r\n\r\n> ...is the old behaviour going to be restored and I should just wait for a new release...\r\n\r\nI've helped create #3894 to support that type of config.\n\nComment by cowtowncoder:\n> Renovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n> \r\n> These are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\r\n\r\nThis is why we publish release candidates -- 2.15.0-rc1, rc2, rc3 -- to try to get users to verify if they find any regressions beyond what our unit test suite catches. Nothing was reported for this.\r\n\r\nNow, I don't know what tests you have so I cannot say if behavior is expected or not: sometimes usage is based on undefined behavior, in which case change may be intended (typically due to a fix to some known problem, and change to unsupported case incidental).\r\n\r\nThank you for helping create a new issue. We'll see where that leads.\r\n\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nI'm sorry and as an open source maintainer myself I feel you.\r\n\r\nI'm the last guy showing up on an issue making demands.\r\n\r\nI would love to help diagnose and test and don't expect you to make a potentially broken config work for my benefit.\n\nComment by cowtowncoder:\n@leonardehrenfried Oh and just to make sure: I did not mean to blame you or users at all. I appreciate your reaching out and reporting the issue. I think we can figure this out; PR submitted might be the way, although I have some reservations. But it's a tricky problem.\n\nComment by yihtserns:\n@leonardehrenfried I've spent a bit of time to study your codebase to understand why that config was used - seems like it was to prevent `ApiLeg.getDuration()` from being serialized.\r\n\r\nI assume that is to make assertion easier, since that method returns non-constant number?\r\n\r\nIf that's the case, here's my suggestion (tested with `2.15.0`):\r\n```java\r\npublic abstract class SnapshotTestBase {\r\n    ...\r\n\r\n    private static class SnapshotItinerarySerializer implements SnapshotSerializer {\r\n\r\n        private SnapshotItinerarySerializer() {\r\n            ...\r\n\r\n            // Remove this config:\r\n            //objectMapper.setVisibility(\r\n            //    objectMapper\r\n            //      .getSerializationConfig()\r\n            //      .getDefaultVisibilityChecker()\r\n            //      .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n            //      .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //);\r\n\r\n            // Add this:\r\n            objectMapper.addMixIn(ApiLeg.class, ApiLegMixin.class);\r\n            ...\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * To exclude {@link ApiLeg#getDuration()} from being deserialized because the returned number\r\n     * is non-constant making it impossible to assert.\r\n     */\r\n    private abstract static class ApiLegMixin {\r\n\r\n      @JsonIgnore\r\n      abstract double getDuration();\r\n    }\r\n}\r\n```\n\nComment by leonardehrenfried:\n@yihtserns thanks so much for this. It absolutely fixes the problems we are having. Fantastic work!\n\nComment by agavrilov76:\nRelated to https://github.com/FasterXML/jackson-databind/issues/3900\n\nComment by cowtowncoder:\nAnother breakage: #3938.\n\nComment by yihtserns:\nI used to think \"nobody would ever put a setter in a Record since nothing is mutable, right?\"\r\n\r\nNow I know how ignorant I was...\n\nComment by cowtowncoder:\nTo be honest, that use case is a bit \"Creative\" and just used to prevent deserialization of something without full ignoral.\r\nBut it is something I'd have used with regular POJOs and works very well for what is needed.\r\n\r\nIf someone else has shown that use case to me, I might have argued against it tho, with Records. Given that they are immutable.\r\n\r\nAnyway, was happy to figure out how to make it work again via fix for #3928.\r\n\n\nComment by yihtserns:\nCaused #3968.",
                "source_code": null,
                "distance": 0.75,
                "title": "Change Records deserialization to use the same mechanism as POJO deserialization.",
                "name": "pr#3724",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3724"
                    }
                ],
                "similarity": 0.2741286997482826,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3906",
                "type": "issue",
                "content": "**Describe the bug**\r\nThis code used to work with 2.14.2, but not with 2.15.0\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nRecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n```\r\n\r\n**Version information**\r\n2.15.0\r\n\r\n**To Reproduce**\r\n```java\r\n/**\r\n * This works fine with Jackson 2.14.2, but not with 2.15.0.\r\n */\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    record RecordTest(String string, int integer) {\r\n    }\r\n\r\n    @Test\r\n    public void emptyJsonToRecord() throws JsonProcessingException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n\r\n        mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n        // mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n        RecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n\r\n\r\n        System.out.println(\"RecordTest deserialized: \" + recordTest_deserialized);\r\n        Assert.assertEquals(new RecordTest(null, 0), recordTest_deserialized);\r\n    }\r\n}\r\n```\r\nComment out the `mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)` and it works.\r\n\r\nNote that the commented-out `mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nException is:\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `io.mats3.examples.jbang.Jackson_2_15_0_Regression$RecordTest` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{}\"; line: 1, column: 2]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1915)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:414)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1360)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1424)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)\r\n\tat io.mats3.examples.jbang.Jackson_2_15_0_Regression.emptyJsonToRecord(Jackson_2_15_0_Regression.java:25)\r\n```\n\n\nComment by pjfanning:\nSeems to work if you don't change the mapper visibility setting - see #3907. Would it be possible for you to not set this value?\r\n\r\nThis issue will still be investigated. I'm just making the suggestion above as a workaround. I'm no expert on the benefits of setting the visibility to non-default values.\n\nComment by yihtserns:\n## Fix/workaround\r\nAllow visibility for `PropertyAccessor.CREATOR`:\r\n```\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.ANY);\r\n```\r\n\r\n## Explanation\r\nPreviously, Records deserialization is specially handled, resulting in some behavioural differences (mostly missing behaviours) compared to POJO deserialization.\r\n\r\n#3724 was done to address those differences, to close the gap between Records vs POJO de/serialization:\r\n1. This means now, Jackson looks for deserialization \"creators\" for Records the same way it looks for POJO's.\r\n2. `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` \"hides\" those \"creators\", because `PropertyAccessor.ALL` includes `PropertyAccessor.CREATOR`.\n\nComment by yihtserns:\n(Interesting to see the different config used to utilise Jackson as only a deserializer not serializer: here & #3897 \ud83e\udd14.)\n\nComment by stolsvik:\nThanks.\r\n\r\nThis is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records.\r\n\r\nI need this config to work both for 2.14.2 and 2.15. Will that new suggested configuration do that just the same? That is: I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the _data_ transferred. I guess I found that config somewhere sometime, and it have done exactly what I wanted for at least 6 years (used to be just classes, and then it also worked just as expected with records. Nice.)\r\n\r\n(PS: I cannot really \"test if it works\" with an alternate config, as this is a \"foundation lib\", there are at least 50 different random services that depend on this just working as it always has. I just wanted to upgrade to keep with the times! :-) That bit pretty hard, both this, and the 5M char limit for String: https://github.com/FasterXML/jackson-core/issues/863#issuecomment-1531090338 )\r\n\r\n(PPS: The bullet 2 where _\"setVisibility(PropertyAccessor.ALL, Visibility.NONE) \"hides\" those \"creators\", because PropertyAccessor.ALL includes PropertyAccessor.CREATOR\"_ on the face of it sounds like a clear bug to me. For a record, there is no other proper way to get this thing made, so they should probably not be included? At least not the canonical constructor?)\n\nComment by cowtowncoder:\nOne thing worth noting: Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side. Especially regarding access to Record Fields; something that will start failing on newer JDKs. It is not certain handling can be fully unified.\r\n\r\nI agree that it is important to be able to have value types, handling that works for both 2.14 and 2.15. But we really did not realize that there was Record usage that relied on explicit Visibility settings -- there's no testing so one can view at as unsupported use case, technically.\r\nAssumption rather was that usage wrt Records would use default visibility settings.\r\n\n\nComment by stolsvik:\n@cowtowncoder Thanks!\r\n\r\n> Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n\r\nyes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\n> Assumption rather was that usage wrt Records would use default visibility settings.\r\n\r\nThis is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\n\nComment by cowtowncoder:\n> > Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n> \r\n> yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\nRight... and which is why code originally was separate.\r\n\r\nI had plans to rewrite Introspection of POJOs, Records, but didn't have time so others had a chance to try out alternatives here.\r\n\r\n> > Assumption rather was that usage wrt Records would use default visibility settings.\r\n> \r\n> This is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\nSorry, I did not mean that as a justification for breaking things: but rather explanation of why this use case was not covered by tests. I understand it was used as a way to unify handling with 2.14 when there was no other way.\r\nI agree in that the same `ObjectMapper` should be usable.\r\n\r\nI'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?) and I think there's a way to change them separately as well. I just do not remember details.\r\n\r\n**EDIT**: I think I got confused with above: visibility checker defaults had to do with different defaults for JDK types, where we do NOT want to detect fields. Records (outside of JDK packages) not affected by that.\r\n\r\n\n\nComment by yihtserns:\n> This is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records...\r\n> ...I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the data transferred.\r\n\r\nTest result for `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` with `2.14.2`:\r\n\r\n| Mechanism (without annotations) | Serialization | Deserialization with non-empty JSON object | Deserialization with empty JSON object |\r\n|---|---|---|---|\r\n| No-arg constructor with getters & setters | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"0 known properties\" | \u2714 Successful: created empty instance |\r\n| Constructor creator | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"no Creators exist\" | \u274c Failed: \"no Creators exist\"\r\n| Record class | \u274c Empty JSON Object | \u2714 Successful: created instance using the JSON fields | \u2714 Successful: created instance using default values |\r\n\r\nThe only way the failing tests above can work is when `@JsonCreator`/`@ConstructorProperties` & `@JsonProperty` annotations are used on the constructor & fields, respectively.  @stolsvik is that what was done in your codebase?\n\nComment by yihtserns:\n> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n> I think there's a way to change them separately as well...\r\n\r\nThe only way I know is this:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n### Alternatives\r\n1. Annotate the override directly on the Records:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n2. Annotate `@JsonCreator` on the canonical compact constructor:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n> I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. **I feel it makes little sense to have to handle this differently**? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\n...which was the whole point of #3724's \"jamming records and POJOs into the same regime\", so that using Records is no (or not much) different from using POJO - the issue you're facing now is because Records & POJOs are handled similarly...\n\nComment by yihtserns:\n>> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n>[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n@cowtowncoder Do you think we should copy that to `2.15`?  E.g.:\r\n```\r\npublic abstract class MapperConfigBase ... {\r\n    ...\r\n    public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n        ...\r\n        if (ClassUtil.isJDKClass(baseType)) {\r\n            vc = VisibilityChecker.Std.allPublicInstance();\r\n        } else if (baseType.isRecord()) {\r\n            // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n            // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n\r\n            vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n        } else {\r\n            vc = getDefaultVisibilityChecker();\r\n        }\r\n        ...\r\n    }\r\n}\r\n```\n\nComment by stolsvik:\n@yihtserns:\r\n> is that what was done in your codebase?\r\n\r\nNo, as I said at top, I have both of:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\nThe full init is:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\n\r\n// Read and write any access modifier fields (e.g. private)\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n// Drop nulls\r\nmapper.setSerializationInclusion(Include.NON_NULL);\r\n\r\n// If props are in JSON that aren't in Java DTO, do not fail.\r\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n\r\n// Write e.g. Dates as \"1975-03-11\" instead of timestamp, and instead of array-of-ints [1975, 3, 11].\r\n// Uses ISO8601 with milliseconds and timezone (if present).\r\nmapper.registerModule(new JavaTimeModule());\r\nmapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\r\n\r\n// Handle Optional, OptionalLong, OptionalDouble\r\nmapper.registerModule(new Jdk8Module());\r\n```\r\nIt is here: https://github.com/centiservice/mats3/blob/main/mats-serial-json/src/main/java/io/mats3/serial/json/MatsSerializerJson.java#L120-L152 - now also with the attempt at handling the 5M chars-in-String limit.\r\n\r\n**Note: I had accepted that I always need a no-args constructor** (as opposed to GSON). (Note: If it is possible to support missing no-args constructor for a class, even with Java 17+, that would be *excellent*!)\r\n\r\n> the issue you're facing now is because Records & POJOs are handled similarly...\r\n\r\nExactly. Which is why I said: _\"yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\"_\r\n\r\nMy point is that the construction of a Record and of a Class, and their population of fields, are rather different, so it sounds .. ambitious .. to do it with the same codebase/flow? Note, I do not try to dictate anything here, it is just an observation. But it would be nice if this - as seen from my side - _regression_ - was not present!\n\nComment by yihtserns:\n> No, as I said at top, I had both of:\r\n> ```\r\n> ObjectMapper mapper = new ObjectMapper();\r\n> mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n> mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n> ```\r\n\r\nOK, was confused because it was commented out in the sample code.\r\n\r\nThat means you might actually have 2 problems:\r\n1. This issue for Records deserialization.\r\n2. #3895 for Records serialization.\n\nComment by stolsvik:\nYes, but I tried to mention:\r\n> Note that the commented-out mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY) is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nIt was an attempt to reduce the problem to the bare minimum.\n\nComment by yihtserns:\nTo summarize, there are 2 things broken when using this config:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\n## 1. For Records deserialization\r\nCaused by #3724 to make Records de/serialization behaves just like POJO de/serialization - it sees:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n...similarly to:\r\n```\r\npublic class RecordTest {\r\n    private String string;\r\n    private int integer;\r\n\r\n    @ConstructorProperties({\"string\", \"integer\"})\r\n    public RecordTest(String string, int integer) {\r\n        this.string = string;\r\n        this.integer = integer\r\n    }\r\n\r\n    public String getString() {\r\n        return this.string;\r\n    }\r\n\r\n    public String getInteger() {\r\n        return this.integer;\r\n    }\r\n}\r\n```\r\n### Fixes/workarounds\r\n1. Make all classes' constructor/factory method Creators visible:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NON_PRIVATE);\r\n```\r\n2. Make only Records' constructor/factory method Creators visible:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n3. Override visibility directly on the Record class:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n4. Override visibility of constructor Creator directly in the Record class:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n## 2. For Records serialization\r\nBroken by #3737 - Records serialization will always result in empty JSON hash (i.e. `{}`).\r\n\r\n#3894 to fix that is pending review.\n\nComment by yihtserns:\nAs for [changing Jackson to make Records' creators always visibility regardless of config](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532803630), I can/will create a PR if the core maintainers think that's the way to go.\n\nComment by stolsvik:\n=1. Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\n1.: Will this work identical for 2.14 and 2.15?  Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a _creator_, if this is what we're talking about?)\r\n2.: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which _might_ have a bunch of constructors that I do not want the serialization to touch?\r\n3. and 3. is utterly out of the question. _(I .. well .. despise ... implementation-specific annotations for serialization. The serialization used for this Mats3 library should be completely opaque to the user, the use of Jackson is literally an implementation detail which should never be thought about. Provide the Request and Reply DTOs, and I will make them \"magically\" transported. I would rather put in code that refused to start if there was any sign of such annotations present)_\r\n\r\nHowever, I can't shake the feeling that this is a pretty clear regression.\r\n\r\n=2:\r\nGood, thanks!\n\nComment by pjfanning:\n@yihtserns thanks for looking at this this. Let's not rush things. We will need to tackle one problem at a time. Maybe getting #3894 progressed is the first priority. @stolsvik will just have to be patient while we resolve the issues. Please stick with Jackson 2.14 in the interim - or try another library, if you prefer.\n\nComment by stolsvik:\nWell, I pretty obviously prefer Jackson, as otherwise I would probably not try to report this.\n\nComment by yihtserns:\n> Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\nNeed to wait for the [core maintainers to make the final decision](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532869817).\r\n\r\n> 1: Will this work identical for 2.14 and 2.15? Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a creator, if this is what we're talking about?)\r\n\r\nCreators are constructors or factory methods (with name `valueOf`) that have parameters, that will be used for deserialization - they are typically either annotated with `@JsonCreator` or \"magically\" chosen.\r\n\r\nThey are not related to, and nor will that config affects no-arg constructor.\r\n\r\n> 2: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which might have a bunch of constructors that I do not want the serialization to touch?\r\n\r\nYou can use this with both `2.14` & `2.15`, but it basically does nothing for `2.14` (because again, deserialization was implemented differently).  This is basically like number 1, except it only targets Record classes:\r\n```\r\nreturn ac.getType().isRecordType()                          // if we're deserializing Record class...\r\n    ? checker.withCreatorVisibility(Visibility.NON_PRIVATE) // ...make the Creators visible\r\n    : checker;                                              // ...leave the visibility as NONE for POJO types\r\n```\n\nComment by cowtowncoder:\n> > > I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n> \r\n> > [3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n> \r\n> @cowtowncoder Do you think we should copy that to `2.15`? E.g.:\r\n> \r\n> ```\r\n> public abstract class MapperConfigBase ... {\r\n>     ...\r\n>     public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n>         ...\r\n>         if (ClassUtil.isJDKClass(baseType)) {\r\n>             vc = VisibilityChecker.Std.allPublicInstance();\r\n>         } else if (baseType.isRecord()) {\r\n>             // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n>             // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n> \r\n>             vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n>         } else {\r\n>             vc = getDefaultVisibilityChecker();\r\n>         }\r\n>         ...\r\n>     }\r\n> }\r\n> ```\r\n\r\nHmmmh. I am bit hesitant wrt overriding users' explicit settings but it does make some sense -- esp. since that's in 3.0.\r\nThe main question would be whether to do that in 2.15.1 or 2.16(.0).\r\nIf (and only if) this would resolve issues we face wrt 2.14->2.15 changes, I'd say let's do it for 2.15(.1).\r\nAlso requires making sure we have good test coverage.\n\nComment by cowtowncoder:\nI merged #3894 fwtw; shouldn't (I think) affect this issue but just in case.\n\nComment by stolsvik:\nJust a comment from the side:\r\n\r\n>  I am bit hesitant wrt overriding users' explicit settings but it does make some sense\r\n\r\nI agree to the general idea that this seems just wrong, but somehow you need to get to those constructors to actually be able to make records! Another way could be a special-case \"if\" when about to create a record, that _effectively_ ignored the setting by just finding the canonical constructor in spite of the setting. However, you would at least not just \"overwrite\" the user-set setting?!\n\nComment by cowtowncoder:\n@stolsvik Yeah this is the challenge in using same logic, handling as with POJOs, when rules are bit different (Records having clear, well-defined rules of what constitutes canonical Constructor, what properties exist).\r\nI'll get #3910 merged and we'll see how far we might get.\r\n\r\n@yihtserns I think we should go with the patch you suggest to unblock remaining issues.\r\n\n\nComment by stolsvik:\nNote: I had to adjust the suggestion a bit to get the \"only adjust visibility for records\" to work: The `ac.getType()` could apparently return null.\r\n\r\n```java\r\npublic VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n    if (ac.getType() == null) {\r\n        return checker;\r\n    }\r\n    if (!ac.getType().isRecordType()) {\r\n        return checker;\r\n    }\r\n    // If this is a Record, then increase the \"creator\" visibility again\r\n    return checker.withCreatorVisibility(Visibility.ANY);\r\n}\r\n```\n\nComment by stolsvik:\nAnother comment from the side: I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the NON_PRIVATE part. If I understand this correctly, it would then not find a private record with private constructor? (Visibility of a record's canonical constructor cannot be less than visibility of the record itself - but a record can be private?)\n\nComment by yihtserns:\n> ...a record can be private?\r\n\r\nYes:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private record RecordTest(String string, int integer) {\r\n    }\r\n}\r\n```\r\n...will be compiled into:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private static record RecordTest(String string, int integer) {\r\n        private RecordTest(String string, int integer) {\r\n            this.string = string;\r\n            this.integer = integer;    \r\n        }\r\n\r\n        public String string() {\r\n            return this.string;\r\n        }\r\n\r\n        public String integer() {\r\n            return this.integer;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> ...I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the `NON_PRIVATE` part...\r\n\r\nI just copied that directly from 3.x codebase.  In hindsight, I should've changed that to `Visibility.ANY` to make it simple (and practical).  \ud83d\ude1e\n\nComment by cowtowncoder:\nI do not remember details here, but it is possible the idea was to avoid exposing `private` constructors, thinking that they are private for reason (but that there are other non-private constructors). For regular POJOs only public constructors are auto-detected; although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?) and other constructors (use configured visibility) would make most sense.\r\nBut once that runs counter to trying to make Records work just like POJOs.\r\n\n\nComment by stolsvik:\n> .. although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?)\r\n\r\nTotally agree. You need to create an instance. That I have chosen to make this DTO-record an inner private entity of whatever service class it resides in, shouldn't make any difference.\n\nComment by cowtowncoder:\n@yihtserns I think fix you suggested would be doable (just need to change check to use `ClassUtil.isRecordType(baseType)` since `Class.isRecord()` is not available on JDK 8).\r\nI think I'll create a PR.\n\nComment by cowtowncoder:\nNote: need to figure out what (if anything) to do with 3.0 (master); 2 failing tests left.\r\nThis due to `MapperFeature.AUTO_DETECT_CREATORS` being removed so specific workaround cannot be used.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Regression: 2.15.0 breaks deserialization for records when mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);",
                "name": "issue#3906",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3895"
                    },
                    {
                        "start_node": "issue#3895",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    }
                ],
                "similarity": 0.2691762865859901,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3628",
                "type": "issue",
                "content": "This may be by design, but I think it may be a bug...\r\n\r\n**Describe the bug**\r\nWhen serializing a record that implements an interface, Jackson also serializes any values resulting from getters in an implemented interface. Such additional \"getters\" should however always be perceived as transient, as they cannot influence the actual data stored in the record.\r\n\r\nFor example:\r\n\r\n    public sealed interface StreamMetaDataEvent extends AggregateEvent {\r\n      public record Updated(StreamMetaData streamMetaData) implements StreamMetaDataEvent {\r\n        @Override\r\n        public Type getType() {\r\n          return Type.FULL;\r\n        }\r\n    \r\n        @Override\r\n        public String getAggregateId() {\r\n          return \"\" + streamMetaData.contentId().asInt();\r\n        }\r\n      }\r\n    \r\n      public record Removed(ContentID id) implements StreamMetaDataEvent {\r\n        @Override\r\n        public Type getType() {\r\n          return Type.DELETE;\r\n        }\r\n    \r\n        @Override\r\n        public String getAggregateId() {\r\n          return \"\" + id.asInt();\r\n        }\r\n      }\r\n    }\r\n\r\nThe getters here are transient (they contain no new information) and are coming from the `AggregateEvent` interface:\r\n\r\n    public interface AggregateEvent {\r\n      enum Type { FULL, DELETE }\r\n\r\n      Type getType();\r\n      String getAggregateId();\r\n    }\r\n\r\n**Work around**\r\n\r\nConfiguring `setVisibility(PropertyAccessor.GETTER, Visibility.NONE)` will also ignore the records fields (not sure if they should be considered \"getters\", but I suppose they might).  Configuring in addition `setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` resolves the issue.\r\n\r\n**Version information**\r\nWhich Jackson version(s) was this for? 2.13.4\r\n\r\n**Expected behavior**\r\nI would expect Jackson to recognize records, and recognize that it is fully defined by the records fields; any additional methods, getters or otherwise, should be considered irrelevant for reconstructing the record.\r\n\n\n\nComment by cowtowncoder:\nMy first thought is that I would consider this a feature: a getter is a getter, even for Records. If they are not to be serialized, they should be marked to be ignored; either by annotations (`@JsonIgnore`, `@JsonIgnoreProperties`), or you may consider enabling `MapperFeature.REQUIRE_SETTERS_FOR_GETTERS` which would prevent serialization of any potential properties that cannot be deserialized (there is no matching \"setter\"; in case of Record meaning constructor parameter).\r\n\r\nIn theory I guess it would be possible to change default visibility level of `Record`s such that no getters would be auto-detected, if users feel this is the way to go. Right now you can change visibility levels (see `@JsonAutoDetect`), but there's no way to easily apply it to all Records.\r\n... actually, come to think of it, it is quite straight-forward to achieve that by user code: override method `findAutoDetectVisibility()` of `AnnotationIntrospector` (or implementation `JacksonAnnotationIntrospector`), and if class is a record type, return different settings: despite name, `AnnotationIntrospector` need not use annotations at all -- it is just the extension/API Jackson uses to make annotation-access modular. So one can use it to \"emulate\" existence of all Jackson annotations.\r\n\r\n\r\n\n\nComment by yihtserns:\nReading the last comment somehow reminds me of [50dd52f](https://github.com/FasterXML/jackson-databind/commit/50dd52f688c8d3af774fa2a9a57c7a5694a70996#diff-542cb14fa94cf6618aa34cc95eb237bf05bd561817e545e74b0a66f25fd98857), where you created a custom default `VisibilityChecker` for Records, for v3.\r\n\r\nIt is a possible option to change that `VisibilityChecker` (albeit for v3) to match the behaviour expected by this issue?  \ud83e\udd14  But that will cause the behaviour to drift further away again from POJO de/serialization behaviour...\n\nComment by yihtserns:\n@cowtowncoder  Eh while trying a different mecha than `AnnotationIntrospector` (i.e. via `ConfigOverride`), it suddenly made me wonder if #3737 specifically [0a4cfc4](https://github.com/FasterXML/jackson-databind/commit/0a4cfc46bc491aed9eab83e13dcd65d415b10c64#diff-8a89bf8f93c483493c778cda25b2e31e2e89bd4b0a8a131e71bfd2ed5a199fff) has broken the workaround used in his issue - specifically usage of `setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` - by avoiding to detect fields for Record types?\n\nComment by cowtowncoder:\nYeah I don't know. Perhaps. That's the challenge of missing test coverage -- functionality not covered by tests can easily break.\n\nComment by yihtserns:\n@hjohn can you help provide a code snippet so we can know exactly how your workaround looks like, so we can properly test whether it's broken in `2.15.0`?\n\nComment by hjohn:\nI just configured a custom `ObjectMapper` for serializing records:\r\n\r\n    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n      .setVisibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n      .setVisibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n      .registerModule(new JavaTimeModule())\r\n      .registerModule(new Jdk8Module())\r\n      .registerModule(new ParameterNamesModule(Mode.PROPERTIES));\r\n\r\nWith this setup it only detects the records fields, and since you can't add any fields to a record, that's all the data you would need to store.\n\nComment by cowtowncoder:\nOne thing to note is that `Record`s do NOT require use of `ParameterNamesModule` as name information is accessed (via Reflection) using record-specific accessors, and anything module provides is basically overridden.\r\nModule is needed for regular POJOs wrt Creators of course.\r\n\n\nComment by yihtserns:\nThat workaround + `2.15.0-rc2` = `{}`\r\n\r\n\ud83d\ude2c \n\nComment by hjohn:\n> That workaround + `2.15.0-rc2` = `{}`\r\n> \r\n> \ud83d\ude2c\r\n\r\nIs that a cryptic way of saying that limiting visibility to fields only for records breaks in 2.15.0-rc2 ?\n\nComment by yihtserns:\nYes.  Only an empty JSON hash/object will be generated when that workaround is used with `2.15.0-rc2`...\r\n\r\n**UPDATE**: The workaround used above is working again in `2.15.1` courtesy of #3894.",
                "source_code": null,
                "distance": 0.5,
                "title": "Serializing a Java 16 Record includes transient data from getters from implemented interfaces",
                "name": "issue#3628",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    }
                ],
                "similarity": 0.24652179663542967,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3895",
                "type": "issue",
                "content": "In 2.15 trying to encode records with PropertyAccessor.GETTER = Visibility.NONE will result in an empty object {}.\r\n```java\r\nrecord DataObject (int a, int b) {}\r\n\r\n@Test\r\npublic void testRecord() throws Exception {\r\n    final ObjectMapper jsonMapper = new JsonMapper();\r\n    final String r = jsonMapper.writeValueAsString(new DataObject(2, 3));\r\n    jsonMapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n    jsonMapper.setVisibility(PropertyAccessor.GETTER, Visibility.NONE);\r\n    Assertions.assertEquals(\"{\\\"a\\\":2,\\\"b\\\":3}\", r); // we get {}\r\n}\r\n```\r\n\r\nto resolve that we can set PropertyAccessor.GETTER = Visibility.DEFAULT or others, but that will break every single class serialization that does not have annotations on getter methods.\r\n```java\r\npublic class Foo {\r\n    private final int x = 2;\r\n    public int getComputedValue() { return 11; }\r\n}\r\n\r\njsonMapper.writeValueAsString(new Foo()) // { x: 2, computedValue: 11 }\r\n```\r\n\r\nThe behaviour in 2.14 with PropertyAccessor.GETTER = Visibility.NONE is the expected one, with records able to serialize all fields\r\n\r\n\r\nIs this change something done on purpose? are there alternatives to set the visibility of getters and annotate every class method?\n\n\nComment by cowtowncoder:\nWrong repo, moving.\r\n\n\nComment by cowtowncoder:\n@matteobertozzi We publish RC versions -- 2.15.0-rc1, rc2, rc3 -- to find these kinds of concerns; cases that are not supported explicitly (there not being unit tests to cover). So one way to think of it is that unless we test something, and no one contributes tests, feature is not formally supported.\r\n\r\nThis does not mean that usage might not be intended to work: there are gaps.\r\n\r\nHaving said that, I think I agree that if Field visibility is set to `Any`, it would seem serialization should consider these fields.\r\n\r\nI am guessing #3894 would solve this issue?\r\n\r\n\n\nComment by matteobertozzi:\ni'm really sorry to have not tested the RCs. \r\n\r\n#3894 should solve this one\r\n\r\nThank you!\n\nComment by yihtserns:\n@matteobertozzi can you share the reason for that config? Is the reason the same as #3628? \n\nComment by matteobertozzi:\n@yihtserns the main reason is because we have \"bad code\". with classes that contains methods called \"getXyz()\" but they are not getters and they are doing computations and maybe some business logic.\r\n\r\nso if we use something different from .GETTERS = Visbility.NONE, we end up with a value that is not supposed to be serialized and maybe some business logic triggered.\r\n```java\r\npublic class Foo {\r\n    private final int x = 2;\r\n    public int getComputedValue() { return 11; }\r\n}\r\n\r\njsonMapper.writeValueAsString(new Foo()) // { x: 2, computedValue: 11 }\r\n```\r\ngoing around all the methods in the codebase to add annotations may be fine for a major (e.g. the 3.x) but we didn't expect that for a minor. \n\nComment by cowtowncoder:\n@matteobertozzi Sorry did not mean that you specifically should have tested, just that it is too bad no one with this use case had tried it and reported. There are gaps, hopefully over time fewer and fewer.\r\n\r\nSo this is a surprise to us and not a planned behavioral change.\r\n\n\nComment by agavrilov76:\nIt is probably related that since version 2.15 `MapperFeature.SORT_PROPERTIES_ALPHABETICALLY` is not longer respected by record method based JSON properties.\r\n\r\nThe property 'a' in the example below comes at the last place:\r\n\r\n```java\r\n    final var mapper =\r\n        Jackson.mapperBuilder()\r\n            .enable(SerializationFeature.INDENT_OUTPUT)\r\n            .enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)\r\n            .build();\r\n\r\n    record R(String c, String b, String e) {\r\n\r\n      @JsonProperty\r\n      String a() {\r\n        return \"4\";\r\n      }\r\n    }\r\n\r\n    System.out.println(mapper.writeValueAsString(new R(\"1\", \"2\", \"3\")));\r\n```\r\nOutput:\r\n\r\n  {\r\n    \"b\" : \"2\",\r\n    \"c\" : \"1\",\r\n    \"e\" : \"3\",\r\n    \"a\" : \"4\"\r\n  }\r\n\n\nComment by yihtserns:\n@agavrilov76 can you create another issue for that?  It's not related to this, but rather is caused by #3724.\n\nComment by agavrilov76:\n@yihtserns https://github.com/FasterXML/jackson-databind/issues/3900\n\nComment by cowtowncoder:\nWould #3894 fix solve this as well? I just merged the fix.\n\nComment by matteobertozzi:\nHi, I did run my tests with the 2.15.1-20230504.033533-11 SNAPSHOT\r\n#3894 seems to solve this issue!\r\n\r\nThanks!\r\n\r\n```xml\r\n<repositories>\r\n    <repository>\r\n      <id>oss.sonatype.snapshots</id>\r\n      <url>https://oss.sonatype.org/content/repositories/snapshots</url>\r\n      <snapshots>\r\n        <enabled>true</enabled>\r\n      </snapshots>\r\n    </repository>\r\n  </repositories>\r\n\r\n  <properties>\r\n    <jackson.version>2.15.1-SNAPSHOT</jackson.version>\r\n...\r\n```\n\nComment by cowtowncoder:\nThank you @matteobertozzi !\n\nComment by haraldk:\nI just discovered that the default mapper configuration for the Azure SDK for Java is:\r\n\r\n```java\r\n        .visibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n        .visibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n```\r\n\r\nUpgrading `jackson-databind` to 2.15.0 did break my message serialization in Azure Service Bus... Was about to file a new issue, when I found this. Indeed, 2.15.1-SNAPSHOT does seem to restore things to how it worked in 2.14.2 again. \ud83d\udc4d\ud83c\udffb ",
                "source_code": null,
                "distance": 0.5,
                "title": "2.15.0 breaking behaviour change for records and Getter Visibility",
                "name": "issue#3895",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3895"
                    }
                ],
                "similarity": 0.21627311667826574,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3894",
                "type": "issue",
                "content": "Refines #3737 - the reason why the fields are needed is because this kind of config needs it:\r\n```java\r\nnew ObjectMapper()\r\n  .setVisibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n  .setVisibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n```\r\n\r\nAnd currently, we have 3 use cases that uses that config:\r\n| | Who | Why |\r\n|--|--|--|\r\n| 1 | #3628 | Easy way to ignore methods (that looks like a property) that comes from interface(s), and only serializing Record components. |\r\n| 2 | https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404 | Easy way (albeit overkill) way to exclude a method (that looks like a property) from being serialized, to avoid making test assertion complicated.\r\n| 3 | #3895, https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532842582 | A way to ignore non-accessor `getXXX` methods. |\r\n\r\nFor the 2nd use case, [there's an alternative solution](https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404).  Not so lucky for 1st & 3rd use cases.\n\n\nComment by cowtowncoder:\nAs per my comment I feel uneasy about exposing fields for Records.\r\n\r\nIt seems to me that the issue here wrt usage is that Records DO NOT use Bean getter/setter notion, and users should follow that naming notation.\r\nBut then again I don't think added accesors would be found.\r\n\r\nSo... I don't know. It's a confusion situation. I really wish JDK team hadn't switched from Bean convention since this is a major hassle -- and has been for years, actually. I understand it's bit more typing and all but for compatibility leaving getters as accessors would have been so much  better for everyone involved.\r\n\r\n\r\n\n\nComment by yihtserns:\nUpdated the PR 1st comment with the 3 currently known use cases.\r\n- The 2nd has alternative solution, so it can be ignored.\r\n- The 1st can be achieved via custom VisibilityChecker via custom AnnotationIntrospector - albeit quite a lot of code to write.\r\n- The 3rd has no alternative solution, and it seems to be a legit need.\n\nComment by fleiber:\nI think I have the problem with a slightly different use case, in case that helps.\r\nThe code is in Kotlin, where we have classes looking like:\r\n```kt\r\nclass Foo(val bar: Int) {\r\n      val isZero get() = bar == 0\r\n}\r\n```\r\nWe serialize these classes with `setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE)` to ignore the isXXX methods, and please note that we cannot use `@JsonIgnore` (\"This annotation is not applicable to target 'member property without backing field or delegate'\").\r\nStarting with Jackson 2.15.0, the `isZero` property is serialized, then the deserialization fails.\r\nThe way we use the visibility feature looks fine to me, so I would say the 2.15 change does look like a regression.\n\nComment by yihtserns:\n@fleiber unless that Kotlin class actually produces Record classes, then they're unrelated - you'd need to open a new issue for that use case.\n\nComment by fleiber:\n> @fleiber unless that Kotlin class actually produces Record classes, then they're unrelated - you'd need to open a new issue for that use case.\r\n\r\nIndeed, I missed the \"record\" part in the title... Sorry, let me create a new issue.\r\nEdit: #3904 \n\nComment by cowtowncoder:\nOk let's do this: we can still re-consider if necessary before 2.15.1 release, but for now this seems sensible.\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Only avoid Records fields detection for deserialization",
                "name": "pr#3894",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3894"
                    }
                ],
                "similarity": 0.15723630410824413,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4157",
                "type": "issue",
                "content": "### Describe your Issue\n\nBecause Java is not Delphi ObjectPascal or modern JavaScript or Kotlin, it has no idea of \"properties\", although the JavaBeans specification was an attempt to shoehorn in the concept by guessing based upon convention. That's why in the wild olden days, Jackson assumed that a method `String getDisplayName()` was a getter; and if there were no `setDisplayName(String)`, well, it's a getter to an imputed read-only property. If you didn't like it, you added a `@JsonIgnore` annotation to your class. (Back then we had a heck of a time figuring out how to make an immutable instance if the constructor had `String foo, String bar, \u2026`, too.)\r\n\r\nBut now we have the Java `record`, which (despite its downsides\u2014it's just one step to a lot of other features coming in Java) beautifully encapsulates not only a set of fields, but also the names of the fields and their required order in the constructor! Moreover Java adds some nifty new reflection methods to access records at runtime.\r\n\r\nSo let's say we have this record:\r\n\r\n```java\r\n/**\r\n * A user's profile information.\r\n * @param username The user's login identifier.\r\n * @param firstName The first name of the user.\r\n * @param lastName The last name of the user.\r\n */\r\npublic record UserProfile(@Nonnull String username, @Nonnull String firstName, @Nonnull String lastName) {\r\n\r\n  public UserProfile {\r\n    requireNonNull(username);\r\n    requireNonNull(firstName);\r\n    requireNonNull(lastName);\r\n  }\r\n\r\n  /** @return A form of the user name appropriate for displaying in messages. */\r\n  public String getDisplayName() {\r\n    return firstName() + \" \" + lastName();\r\n  }\r\n\r\n}\r\n```\r\n\r\nWe know at runtime exactly what the constructor types _and names_ (e.g. `username`); and which fields they correspond to. We know what the field getters are (e.g. `username()`. More importantly, we know what methods are _not_ getters, and have nothing to do with the fields\u2014`getDisplayName()` is an example.\r\n\r\nUnfortunately Jackson will generate a JSON object that has a `displayName` attribute, which will prevent the object from being parsed back round-trip, because `displayName` doesn't correspond to any of the record fields.\r\n\r\nMaybe the user wanted to generate a JSON object with the `displayName` attribute and _never use it for deserializing back to a `UserProfile` instance_. That's a valid use case, but it doesn't seem like it should be the default use case.\r\n\r\nI can get around this by adding a `@JsonIgnore`:\r\n\r\n```java\r\n  /** @return A form of the user name appropriate for displaying in messages. */\r\n  @JsonIgnore\r\n  public String getDisplayName() {\r\n    return firstName() + \" \" + lastName();\r\n  }\r\n```\r\n\r\nBut I don't want to dirty the model (even though it's a DTO model) with serialization information unless I have to. As recounted above, at one time we had to. But with Java `record`, we shouldn't have to.\r\n\r\nIs there a way to configure Jackson to automatically ignore non-field methods for Java `record`? If there is something I could use in `JsonMapper.builder()` that would be fine. Is there something like `JsonMapper.builder().serializationMethodInclusion(JsonInclude.Include.NON_RECORD)`? If not, what would you recommend as the best way forward to get this sort of functionality? Is there some little logic I can inject into my `JsonMapper` to detect and handle this case, for example?\n\n\nComment by JooHyukKim:\n> Is there a way to configure Jackson to automatically ignore non-field methods for Java `record`? If there is something I could use in `JsonMapper.builder()` that would be fine. Is there something like `JsonMapper.builder().serializationMethodInclusion(JsonInclude.Include.NON_RECORD)`? If not, what would you recommend as the best way forward to get this sort of functionality? Is there some little logic I can inject into my `JsonMapper` to detect and handle this case, for example?\r\n\r\nOkay, it seems like a usage question, right?\n\nComment by garretwilson:\n> Okay, it seems like a usage question, right?\r\n\r\nWell ultimately this is a request to add an option to turn off automatic serialization of additional methods on Java records. I assume there isn't a way already, but I was asking so as to confirm that first. Being none, I'd like to request that such an option be added.\n\nComment by JooHyukKim:\nI see. Since the issue template is for \"Something Else\", was wondering what the issue would be \ud83d\ude05.\r\n\r\nMaybe we can treat this as \"Feature Request\", but with conditions and maybe add some sort of header, for hint, so others can easily get on helping?\n\nComment by pjfanning:\n@garretwilson have you checked around the web? Plenty of stackoverflow and blogs to look up.\r\n\r\nI've never gone near the visibility settings but they look like the kind of settings that might work here.\r\n\r\nhttps://stackoverflow.com/questions/7105745/how-to-specify-jackson-to-only-use-fields-preferably-globally covers the opposite - only using fields - but maybe you could use some trial and error on this?\n\nComment by cowtowncoder:\n@pjfanning I would recommend against trying make use of Fields `record` types have tho... it requires forcing access and is less than ideal, possibly breaking at some point with later JDKs.\r\n\r\nI think I'd be +1 for new `MapperFeature` -- if need be -- for disabling implicit \"getter-discovery\" for Record types (probably should also disable setter discovery fwtw). And I think it is quite doable.\r\n\r\n... although most likely for 2.17, unless someone can come up with a patch in a day or so; I am trying to close the last issue I really want in for 2.16.\r\n\r\n\r\n\n\nComment by JooHyukKim:\n> ... although most likely for 2.17, unless someone can come up with a patch \r\n\r\n+1 for `2.17` planning \ud83d\udc4d\ud83c\udffc `record` type has taken lots of battle scars past few minor versions, so we may want to take it slow (unless criticial)\n\nComment by JooHyukKim:\n> I think I'd be +1 for new `MapperFeature` -- if need be -- for disabling implicit \"getter-discovery\" for Record types (probably should also disable setter discovery fwtw). And I think it is quite doable.\r\n\r\nThrowing out some naming ideas,\r\n\r\n- `MapperFeature.IGNORE_SETTER_METHODS_IN_RECORD_TYPE`,\r\n- `MapperFeature.IGNORE_GETTER_METHODS_IN_RECORD_TYPE`,\r\n- `MapperFeature.IGNORE_GETTER_AND_SETTER_METHODS_IN_RECORD_TYPE`,\n\nComment by cowtowncoder:\nLooking at existing `MapperFeature`, we have `AUTO_DETECT_GETTERS`. The reason I like referring to auto-detection (or implicit detection) is that this would not ignore explicitly annotated getters; only disable auto-detection -- this so that defining explicit getters is fine since that is often needed (f.ex to change default behavior).\r\n\r\nAnd to refer to both getters and setters we could use term \"accessors\", so could consider `AUTO_DETECT_RECORD_ACCESSORS` (default `true` for backwards compatibility).\r\n\r\nOne possible complication is that users might expect existing `AUTO_DETECT_GETTERS`/`_SETTERS` to still have some effect, so would need to consider semantics there -- for `Mapper-`/`Deserialization-`/`SerializationFeature` we only have on/off setting and no \"use default\".\r\nIn that sense, maybe use of `DISABLE_RECORD_ACCESSOR_AUTO_DETECTION` would make most sense; enabling of which would forcibly prevent auto-detection for Record fields, setters, getters, is-getters (but not Creator detection).\r\n\r\nAnd yes, it does sound like waiting until 2.17 would be prudent, even if this initially seemed like a simple  thing to add.\r\n\n\nComment by yihtserns:\n> I assume there isn't a way already, but I was asking so as to confirm that first.\r\n\r\n> I've never gone near the visibility settings but they look like the kind of settings that might work here.\r\n\r\n> I would recommend against trying make use of Fields record types have tho... it requires forcing access and is less than ideal, possibly breaking at some point with later JDKs.\r\n\r\nIgnoring the question of whether it is an appropriate method or not, just want to note that using (abusing?) visibility seems to be the typical way of achieving this - see:\r\n- #3628\r\n- https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404\r\n- #3895\r\n- https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532842582\n\nComment by cowtowncoder:\n@yihtserns yes. On plus side, there are workarounds. On downside all these workarounds probably make it more not less difficult to fix things (since they are now behavior that arguably needs to be supported, being used somewhat widely).\r\n",
                "source_code": null,
                "distance": 0.25,
                "title": "`MapperFeature` to ignore setter/getter method implicit detection for Record types",
                "name": "issue#4157",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    }
                ],
                "similarity": 0.15262238677493925,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1",
                "type": "issue",
                "content": "I'm struggling with a problem that is probably common for people that extensively use @JsonView. Since only one view can be active at any one time, and jsonview classes are singly-inherited, the facility is very tightly constrained. There are a lot of cases where I need to define multiple views: \"Show me the properties relevant to green administrators and the fields relevant to blue administrators\", where these are not perfect subsets.\n\nFrom an API perspective, one solution would be to allow json views to be defined by interfaces and thus enable multiple inheritance. Alternatively, just allow multiple views to be specified - although this raises the question of AND vs OR.\n\nThis has been moved from https://github.com/FasterXML/jackson-core/issues/3\n\n\n\nComment by cowtowncoder:\nForgot to add a comment: interfaces can be used to represent views just fine already (since beginning), and the reason is exactly the ability to compose more complicated view definitions. So at least that part should already work, if I understand request correctly.\n\n\nComment by cowtowncoder:\nNot sure if there is anything to do here: one can use interfaces as JsonView values already.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Improve @JsonView flexibility",
                "name": "issue#1",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3895"
                    },
                    {
                        "start_node": "issue#3895",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1"
                    }
                ],
                "similarity": 0.15165211400352788,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3737",
                "type": "issue",
                "content": "\n\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Avoid mutator-inference for Records (to avoid pulling in Fields as mutators)",
                "name": "pr#3737",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    },
                    {
                        "start_node": "issue#4157",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    }
                ],
                "similarity": 0.08316960179599948,
                "end_line": null,
                "signature": null
            }
        ]
    },
    "artifact_stats": {
        "skipped_due_to_time": 5,
        "valid_related_items": 127
    }
}