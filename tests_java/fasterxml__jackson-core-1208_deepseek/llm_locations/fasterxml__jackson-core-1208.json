{
    "related_entities": {
        "methods": [
            {
                "start_line": 373,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory(ObjectCodec oc) {\n        _recyclerPool = JsonRecyclerPools.defaultPool();\n        _objectCodec = oc;\n        _quoteChar = DEFAULT_QUOTE_CHAR;\n        _streamReadConstraints = StreamReadConstraints.defaults();\n        _streamWriteConstraints = StreamWriteConstraints.defaults();\n        _errorReportConfiguration = ErrorReportConfiguration.defaults();\n        _generatorDecorators = null;\n\n        _rootCharSymbols = CharsToNameCanonicalizer.createRoot(this);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "JsonFactory",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    }
                ],
                "similarity": 0.1892390288461378,
                "end_line": 383,
                "signature": "com.fasterxml.jackson.core.JsonFactory(ObjectCodec oc)"
            },
            {
                "start_line": 425,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory(JsonFactoryBuilder b) {\n        _recyclerPool = b._recyclerPool;\n        _objectCodec = null;\n\n        // General\n        _factoryFeatures = b._factoryFeatures;\n        _parserFeatures = b._streamReadFeatures;\n        _generatorFeatures = b._streamWriteFeatures;\n        _inputDecorator = b._inputDecorator;\n        _outputDecorator = b._outputDecorator;\n        _generatorDecorators = _copy(b._generatorDecorators);\n        _streamReadConstraints = Objects.requireNonNull(b._streamReadConstraints);\n        _streamWriteConstraints = Objects.requireNonNull(b._streamWriteConstraints);\n        _errorReportConfiguration = Objects.requireNonNull(b._errorReportConfiguration);\n\n        // JSON-specific\n        _characterEscapes = b._characterEscapes;\n        _rootValueSeparator = b._rootValueSeparator;\n        _maximumNonEscapedChar = b._maximumNonEscapedChar;\n        _quoteChar = b._quoteChar;\n\n        _rootCharSymbols = CharsToNameCanonicalizer.createRoot(this);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "JsonFactory",
                "documentation": "/**\n     * Constructor used by {@link JsonFactoryBuilder} for instantiation.\n     *\n     * @param b Builder that contains settings to use\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    }
                ],
                "similarity": 0.1734242009317703,
                "end_line": 447,
                "signature": "com.fasterxml.jackson.core.JsonFactory(JsonFactoryBuilder b)"
            },
            {
                "start_line": 872,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory setStreamReadConstraints(StreamReadConstraints src) {\n        _streamReadConstraints = Objects.requireNonNull(src);\n        return this;\n    }",
                "distance": 1.0,
                "title": null,
                "name": "setStreamReadConstraints",
                "documentation": "/**\n     * Method for overriding {@link StreamReadConstraints} defined for\n     * this factory.\n     *<p>\n     * NOTE: the preferred way to set constraints is by using\n     * {@link JsonFactoryBuilder#streamReadConstraints}: this method is only\n     * provided to support older non-builder-based construction.\n     * In Jackson 3.x this method will not be available.\n     *\n     * @param src Constraints\n     *\n     * @return This factory instance (to allow call chaining)\n     *\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "setStreamReadConstraints"
                    }
                ],
                "similarity": 0.1702488090040092,
                "end_line": 875,
                "signature": "com.fasterxml.jackson.core.JsonFactory.setStreamReadConstraints(StreamReadConstraints src): JsonFactory"
            },
            {
                "start_line": 104,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static void overrideDefaultStreamReadConstraints(final StreamReadConstraints streamReadConstraints) {\n        if (streamReadConstraints == null) {\n            DEFAULT = new StreamReadConstraints(DEFAULT_MAX_DEPTH, DEFAULT_MAX_DOC_LEN,\n                    DEFAULT_MAX_NUM_LEN, DEFAULT_MAX_STRING_LEN);\n        } else {\n            DEFAULT = streamReadConstraints;\n        }\n    }",
                "distance": 1.25,
                "title": null,
                "name": "overrideDefaultStreamReadConstraints",
                "documentation": "/**\n     * Override the default StreamReadConstraints. These defaults are only used when {@link JsonFactory}\n     * instances are not configured with their own StreamReadConstraints.\n     * <p>\n     * Library maintainers should not set this as it will affect other code that uses Jackson.\n     * Library maintainers who want to configure StreamReadConstraints for the Jackson usage within their\n     * lib should create <code>ObjectMapper</code> instances that have a {@link JsonFactory} instance with\n     * the required StreamReadConstraints.\n     * <p>\n     * This method is meant for users delivering applications. If they use this, they set it when they start\n     * their application to avoid having other code initialize their mappers before the defaults are overridden.\n     *\n     * @param streamReadConstraints new default for StreamReadConstraints (a null value will reset to built-in default)\n     * @see #defaults()\n     * @see #builder()\n     * @since v2.15.2\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "StreamReadConstraints"
                    },
                    {
                        "start_node": "StreamReadConstraints",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "overrideDefaultStreamReadConstraints"
                    }
                ],
                "similarity": 0.16851493612861118,
                "end_line": 111,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.overrideDefaultStreamReadConstraints(StreamReadConstraints streamReadConstraints): void"
            },
            {
                "start_line": 457,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonFactory(TSFBuilder<?,?> b, boolean bogus) {\n        _recyclerPool = b._recyclerPool;\n        _objectCodec = null;\n\n        _factoryFeatures = b._factoryFeatures;\n        _parserFeatures = b._streamReadFeatures;\n        _generatorFeatures = b._streamWriteFeatures;\n        _inputDecorator = b._inputDecorator;\n        _outputDecorator = b._outputDecorator;\n        _generatorDecorators = _copy(b._generatorDecorators);\n        _streamReadConstraints = Objects.requireNonNull(b._streamReadConstraints);\n        _streamWriteConstraints = Objects.requireNonNull(b._streamWriteConstraints);\n        _errorReportConfiguration = Objects.requireNonNull(b._errorReportConfiguration);\n\n        // JSON-specific: need to assign even if not really used\n        _characterEscapes = null;\n        _rootValueSeparator = null;\n        _maximumNonEscapedChar = 0;\n        _quoteChar = DEFAULT_QUOTE_CHAR;\n\n        _rootCharSymbols = CharsToNameCanonicalizer.createRoot(this);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "JsonFactory",
                "documentation": "/**\n     * Constructor for subtypes; needed to work around the fact that before 3.0,\n     * this factory has cumbersome dual role as generic type as well as actual\n     * implementation for json.\n     *\n     * @param b Builder that contains settings to use\n     * @param bogus Argument only needed to separate constructor signature; ignored\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    }
                ],
                "similarity": 0.16834619288315797,
                "end_line": 478,
                "signature": "com.fasterxml.jackson.core.JsonFactory(TSFBuilder b, boolean bogus)"
            },
            {
                "start_line": 236,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        Builder(StreamReadConstraints src) {\n            maxNestingDepth = src._maxNestingDepth;\n            maxDocLen = src._maxDocLen;\n            maxNumLen = src._maxNumLen;\n            maxStringLen = src._maxStringLen;\n            maxNameLen = src._maxNameLen;\n        }",
                "distance": 1.0,
                "title": null,
                "name": "Builder",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "Builder"
                    }
                ],
                "similarity": 0.16194814578322908,
                "end_line": 242,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.Builder(StreamReadConstraints src)"
            },
            {
                "start_line": 339,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static CharsToNameCanonicalizer createRoot(TokenStreamFactory owner, int seed) {\n        // Need to use a variable seed, to thwart hash-collision based attacks.\n        // 14-Feb-2017, tatu: not sure it actually helps, at all, since it won't\n        //   change mixing or any of the steps. Should likely just remove in future.\n        if (seed == 0) {\n            // 23-Aug-2023, tatu: Changed to use identity hash code instead of current time\n            seed = System.identityHashCode(owner);\n        }\n\n        StreamReadConstraints src;\n        int factoryFeatures;\n        \n        if (owner == null) {\n            src = StreamReadConstraints.defaults();\n            factoryFeatures = 0;\n        } else {\n            src = owner.streamReadConstraints();\n            factoryFeatures = owner.getFactoryFeatures();\n        }\n        return new CharsToNameCanonicalizer(src, factoryFeatures, seed);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "createRoot",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    }
                ],
                "similarity": 0.1610061823822341,
                "end_line": 359,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.createRoot(TokenStreamFactory owner, int seed): CharsToNameCanonicalizer"
            },
            {
                "start_line": 214,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public Builder maxNameLength(final int maxNameLen) {\n            if (maxNameLen < 0) {\n                throw new IllegalArgumentException(\"Cannot set maxNameLen to a negative value\");\n            }\n            this.maxNameLen = maxNameLen;\n            return this;\n        }",
                "distance": 1.0,
                "title": null,
                "name": "maxNameLength",
                "documentation": "/**\n         * Sets the maximum name length (in chars or bytes, depending on input context).\n         * The default is 50,000. This limit is not exact, the limit is applied when we increase\n         * internal buffer sizes and an exception will happen at sizes greater than this limit. Some\n         * text values that are a little bigger than the limit may be treated as valid but no text\n         * values with sizes less than or equal to this limit will be treated as invalid.\n         *\n         * @param maxNameLen the maximum string length (in chars or bytes, depending on input context)\n         *\n         * @return this builder\n         * @throws IllegalArgumentException if the maxStringLen is set to a negative value\n         * @since 2.16.0\n         */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "maxNameLength"
                    }
                ],
                "similarity": 0.15928734313704604,
                "end_line": 220,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.Builder.maxNameLength(int maxNameLen): Builder"
            },
            {
                "start_line": 244,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public StreamReadConstraints build() {\n            return new StreamReadConstraints(maxNestingDepth, maxDocLen,\n                    maxNumLen, maxStringLen, maxNameLen);\n        }",
                "distance": 1.0,
                "title": null,
                "name": "build",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "build"
                    }
                ],
                "similarity": 0.15312259674697873,
                "end_line": 247,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.Builder.build(): StreamReadConstraints"
            },
            {
                "start_line": 787,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected void _reportTooManyCollisions(int maxLen) throws StreamConstraintsException {\n        throw new StreamConstraintsException(\"Longest collision chain in symbol table (of size \"+_size\n                +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_reportTooManyCollisions",
                "documentation": "/**\n     * @param maxLen Maximum allowed length of collision chain\n     * @throws StreamConstraintsException if there are too many collisions (was an IllegalStateException before v2.15)\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    },
                    {
                        "start_node": "CharsToNameCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_reportTooManyCollisions"
                    }
                ],
                "similarity": 0.15146079620856195,
                "end_line": 790,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer._reportTooManyCollisions(int maxLen): void"
            },
            {
                "start_line": 338,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static ByteQuadsCanonicalizer createRoot() {\n        // Need to use a variable seed, to thwart hash-collision based attacks.\n        // 14-Feb-2017, tatu: Does this actually help?\n        long now = System.currentTimeMillis();\n        // ensure it's not 0; and might as well require to be odd so:\n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "createRoot",
                "documentation": "/**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     *\n     * @return Root instance to use for constructing new child instances\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    }
                ],
                "similarity": 0.14618588601817564,
                "end_line": 345,
                "signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.createRoot(): ByteQuadsCanonicalizer"
            },
            {
                "start_line": 246,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private CharsToNameCanonicalizer(StreamReadConstraints src, int factoryFeatures,",
                "distance": 1.0,
                "title": null,
                "name": "CharsToNameCanonicalizer",
                "documentation": "/**\n     * Main method for constructing a root symbol table instance.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    }
                ],
                "similarity": 0.13924933150911759,
                "end_line": 246,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer(StreamReadConstraints src, int factoryFeatures, int seed)"
            },
            {
                "start_line": 335,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static CharsToNameCanonicalizer createRoot(TokenStreamFactory owner) {\n        return createRoot(owner, 0);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "createRoot",
                "documentation": "/**\n     * Method called to create root canonicalizer for a {@link com.fasterxml.jackson.core.JsonFactory}\n     * instance. Root instance is never used directly; its main use is for\n     * storing and sharing underlying symbol arrays as needed.\n     *\n     * @param owner Factory that will use the root instance; used for accessing\n     *    configuration\n     *\n     * @return Root instance to use for constructing new child instances\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    }
                ],
                "similarity": 0.1362116660086535,
                "end_line": 337,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.createRoot(TokenStreamFactory owner): CharsToNameCanonicalizer"
            },
            {
                "start_line": 272,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected StreamReadConstraints(final int maxNestingDepth, final long maxDocLen,",
                "distance": 1.0,
                "title": null,
                "name": "StreamReadConstraints",
                "documentation": "/**\n     * @param maxNestingDepth Maximum input document nesting to allow\n     * @param maxDocLen Maximum input document length to allow\n     * @param maxNumLen Maximum number representation length to allow\n     * @param maxStringLen Maximum String value length to allow\n     * @param maxNameLen Maximum Object property name length to allow\n     *\n     * @since 2.16\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "StreamReadConstraints"
                    }
                ],
                "similarity": 0.1347718455257972,
                "end_line": 272,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints(int maxNestingDepth, long maxDocLen, int maxNumLen, int maxStringLen, int maxNameLen)"
            },
            {
                "start_line": 257,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected StreamReadConstraints(final int maxNestingDepth, final long maxDocLen,",
                "distance": 1.0,
                "title": null,
                "name": "StreamReadConstraints",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "StreamReadConstraints"
                    }
                ],
                "similarity": 0.13266611969935957,
                "end_line": 257,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints(int maxNestingDepth, long maxDocLen, int maxNumLen, int maxStringLen)"
            },
            {
                "start_line": 488,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public TSFBuilder<?,?> rebuild() {\n        // 13-Jun-2018, tatu: Verify sub-classing to prevent strange bugs in format impls\n        _requireJSONFactory(\"Factory implementation for format (%s) MUST override `rebuild()` method\");\n        return new JsonFactoryBuilder(this);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "rebuild",
                "documentation": "/**\n     * Method that allows construction of differently configured factory, starting\n     * with settings of this factory.\n     *\n     * @return Builder instance to use\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "rebuild"
                    }
                ],
                "similarity": 0.13229102263144854,
                "end_line": 492,
                "signature": "com.fasterxml.jackson.core.JsonFactory.rebuild(): TSFBuilder"
            },
            {
                "start_line": 1864,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n        try {\n            return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n                    _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n        } catch (IOException | RuntimeException e) {\n            // 10-Jun-2022, tatu: For [core#763] may need to close InputStream here\n            if (ctxt.isResourceManaged()) {\n                try {\n                    in.close();\n                } catch (Exception e2) {\n                    e.addSuppressed(e2);\n                }\n            }\n            ctxt.close();\n            throw e;\n        }\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_createParser",
                "documentation": "/**\n     * Overridable factory method that actually instantiates desired parser\n     * given {@link InputStream} and context object.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     *\n     * @param in InputStream to use for reading content to parse\n     * @param ctxt I/O context to use for parsing\n     *\n     * @throws IOException if parser initialization fails due to I/O (read) problem\n     *\n     * @return Parser constructed\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_createParser"
                    }
                ],
                "similarity": 0.13165715292106211,
                "end_line": 1880,
                "signature": "com.fasterxml.jackson.core.JsonFactory._createParser(InputStream in, IOContext ctxt): JsonParser"
            },
            {
                "start_line": 1208,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(File f) throws IOException, JsonParseException {\n        // true, since we create InputStream from File\n        IOContext ctxt = _createContext(_createContentReference(f), true);\n        InputStream in = _fileInputStream(f);\n        return _createParser(_decorate(in, ctxt), ctxt);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Method for constructing JSON parser instance to parse\n     * contents of specified file.\n     *\n     *<p>\n     * Encoding is auto-detected from contents according to JSON\n     * specification recommended mechanism. Json specification\n     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n     * so auto-detection implemented only for this charsets.\n     * For other charsets use {@link #createParser(java.io.Reader)}.\n     *\n     *<p>\n     * Underlying input stream (needed for reading contents)\n     * will be <b>owned</b> (and managed, i.e. closed as need be) by\n     * the parser, since caller has no access to it.\n     *\n     * @param f File that contains JSON content to parse\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.13140967283933105,
                "end_line": 1213,
                "signature": "com.fasterxml.jackson.core.JsonFactory.createParser(File f): JsonParser"
            },
            {
                "start_line": 40,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactoryBuilder.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactoryBuilder(JsonFactory base) {\n        super(base);\n        _characterEscapes = base.getCharacterEscapes();\n        _rootValueSeparator = base._rootValueSeparator;\n        _maximumNonEscapedChar = base._maximumNonEscapedChar;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "JsonFactoryBuilder",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "build"
                    },
                    {
                        "start_node": "build",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "JsonFactoryBuilder"
                    },
                    {
                        "start_node": "JsonFactoryBuilder",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "JsonFactoryBuilder"
                    }
                ],
                "similarity": 0.13006290988187819,
                "end_line": 45,
                "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder(JsonFactory base)"
            },
            {
                "start_line": 1234,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(URL url) throws IOException, JsonParseException {\n        // true, since we create InputStream from URL\n        IOContext ctxt = _createContext(_createContentReference(url), true);\n        InputStream in = _optimizedStreamFromURL(url);\n        return _createParser(_decorate(in, ctxt), ctxt);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Method for constructing JSON parser instance to parse\n     * contents of resource reference by given URL.\n     *<p>\n     * Encoding is auto-detected from contents according to JSON\n     * specification recommended mechanism. Json specification\n     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n     * so auto-detection implemented only for this charsets.\n     * For other charsets use {@link #createParser(java.io.Reader)}.\n     *<p>\n     * Underlying input stream (needed for reading contents)\n     * will be <b>owned</b> (and managed, i.e. closed as need be) by\n     * the parser, since caller has no access to it.\n     *\n     * @param url URL pointing to resource that contains JSON content to parse\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.1293348124534443,
                "end_line": 1239,
                "signature": "com.fasterxml.jackson.core.JsonFactory.createParser(URL url): JsonParser"
            },
            {
                "start_line": 2317,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private final boolean _isJSONFactory() {\n        // NOTE: since we only really care about whether this is standard JSON-backed factory,\n        // or its sub-class / delegated to one, no need to check for equality, identity is enough\n        return getFormatName() == FORMAT_NAME_JSON;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_isJSONFactory",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_isJSONFactory"
                    }
                ],
                "similarity": 0.12919056676406232,
                "end_line": 2321,
                "signature": "com.fasterxml.jackson.core.JsonFactory._isJSONFactory(): boolean"
            },
            {
                "start_line": 912,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory setStreamWriteConstraints(StreamWriteConstraints swc) {\n        _streamWriteConstraints = Objects.requireNonNull(swc);\n        return this;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "setStreamWriteConstraints",
                "documentation": "/**\n     * Method for overriding {@link StreamWriteConstraints} defined for\n     * this factory.\n     *<p>\n     * NOTE: the preferred way to set constraints is by using\n     * {@link JsonFactoryBuilder#streamWriteConstraints}: this method is only\n     * provided to support older non-builder-based construction.\n     * In Jackson 3.x this method will not be available.\n     *\n     * @param swc Constraints\n     *\n     * @return This factory instance (to allow call chaining)\n     *\n     * @since 2.16\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "setStreamWriteConstraints"
                    }
                ],
                "similarity": 0.12864944073932075,
                "end_line": 915,
                "signature": "com.fasterxml.jackson.core.JsonFactory.setStreamWriteConstraints(StreamWriteConstraints swc): JsonFactory"
            },
            {
                "start_line": 1338,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(String content) throws IOException, JsonParseException {\n        final int strLen = content.length();\n        // Actually, let's use this for medium-sized content, up to 64kB chunk (32kb char)\n        if ((_inputDecorator != null) || (strLen > 0x8000) || !canUseCharArrays()) {\n            // easier to just wrap in a Reader than extend InputDecorator; or, if content\n            // is too long for us to copy it over\n            return createParser(new StringReader(content));\n        }\n        IOContext ctxt = _createContext(_createContentReference(content), true);\n        char[] buf = ctxt.allocTokenBuffer(strLen);\n        content.getChars(0, strLen, buf, 0);\n        return _createParser(buf, 0, strLen, ctxt, true);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Method for constructing parser for parsing\n     * contents of given String.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.12818701306475683,
                "end_line": 1350,
                "signature": "com.fasterxml.jackson.core.JsonFactory.createParser(String content): JsonParser"
            },
            {
                "start_line": 51,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamWriteConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static void overrideDefaultStreamWriteConstraints(final StreamWriteConstraints streamWriteConstraints) {\n        if (streamWriteConstraints == null) {\n            DEFAULT = new StreamWriteConstraints(DEFAULT_MAX_DEPTH);\n        } else {\n            DEFAULT = streamWriteConstraints;\n        }\n    }",
                "distance": 1.5,
                "title": null,
                "name": "overrideDefaultStreamWriteConstraints",
                "documentation": "/**\n     * Override the default StreamWriteConstraints. These defaults are only used when {@link JsonFactory}\n     * instances are not configured with their own StreamWriteConstraints.\n     * <p>\n     * Library maintainers should not set this as it will affect other code that uses Jackson.\n     * Library maintainers who want to configure StreamWriteConstraints for the Jackson usage within their\n     * lib should create <code>ObjectMapper</code> instances that have a {@link JsonFactory} instance with\n     * the required StreamWriteConstraints.\n     * <p>\n     * This method is meant for users delivering applications. If they use this, they set it when they start\n     * their application to avoid having other code initialize their mappers before the defaults are overridden.\n     *\n     * @param streamWriteConstraints new default for StreamWriteConstraints (a null value will reset to built-in default)\n     * @see #defaults()\n     * @see #builder()\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "builder"
                    },
                    {
                        "start_node": "builder",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "StreamWriteConstraints"
                    },
                    {
                        "start_node": "StreamWriteConstraints",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "overrideDefaultStreamWriteConstraints"
                    }
                ],
                "similarity": 0.1274796814164865,
                "end_line": 57,
                "signature": "com.fasterxml.jackson.core.StreamWriteConstraints.overrideDefaultStreamWriteConstraints(StreamWriteConstraints streamWriteConstraints): void"
            },
            {
                "start_line": 360,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/TSFBuilder.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public B streamReadConstraints(StreamReadConstraints streamReadConstraints) {\n        _streamReadConstraints = Objects.requireNonNull(streamReadConstraints);\n        return _this();\n    }",
                "distance": 1.5,
                "title": null,
                "name": "streamReadConstraints",
                "documentation": "/**\n     * Sets the constraints for streaming reads.\n     *\n     * @param streamReadConstraints constraints for streaming reads\n     * @return this builder (for call chaining)\n     * @since 2.15\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "build"
                    },
                    {
                        "start_node": "build",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "TSFBuilder"
                    },
                    {
                        "start_node": "TSFBuilder",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "streamReadConstraints"
                    }
                ],
                "similarity": 0.1269246162524263,
                "end_line": 363,
                "signature": "com.fasterxml.jackson.core.TSFBuilder.streamReadConstraints(StreamReadConstraints streamReadConstraints): B"
            },
            {
                "start_line": 234,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactoryBuilder.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory build() {\n        // 28-Dec-2017, tatu: No special settings beyond base class ones, so:\n        return new JsonFactory(this);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "build",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "build"
                    }
                ],
                "similarity": 0.12592449990844579,
                "end_line": 237,
                "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder.build(): JsonFactory"
            },
            {
                "start_line": 114,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/ErrorReportConfiguration.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        Builder(final int maxErrorTokenLength, final int maxRawContentLength) {\n            this.maxErrorTokenLength = maxErrorTokenLength;\n            this.maxRawContentLength = maxRawContentLength;\n        }",
                "distance": 1.0,
                "title": null,
                "name": "Builder",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "Builder"
                    }
                ],
                "similarity": 0.12551654841503948,
                "end_line": 117,
                "signature": "com.fasterxml.jackson.core.ErrorReportConfiguration.Builder(int maxErrorTokenLength, int maxRawContentLength)"
            },
            {
                "start_line": 91,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamWriteConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public StreamWriteConstraints build() {\n            return new StreamWriteConstraints(maxNestingDepth);\n        }",
                "distance": 1.0,
                "title": null,
                "name": "build",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "build"
                    }
                ],
                "similarity": 0.1251733591235353,
                "end_line": 93,
                "signature": "com.fasterxml.jackson.core.StreamWriteConstraints.Builder.build(): StreamWriteConstraints"
            },
            {
                "start_line": 393,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonFactory(JsonFactory src, ObjectCodec codec)",
                "distance": 1.0,
                "title": null,
                "name": "JsonFactory",
                "documentation": "/**\n     * Constructor used when copy()ing a factory instance.\n     *\n     * @param src Original factory to copy settings from\n     * @param codec Databinding-level codec to use, if any\n     *\n     * @since 2.2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    }
                ],
                "similarity": 0.12433269636107801,
                "end_line": 393,
                "signature": "com.fasterxml.jackson.core.JsonFactory(JsonFactory src, ObjectCodec codec)"
            },
            {
                "start_line": 563,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected Object readResolve() {\n        return new JsonFactory(this, _objectCodec);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "readResolve",
                "documentation": "/**\n     * Method that we need to override to actually make restoration go\n     * through constructors etc: needed to allow JDK serializability of\n     * factory instances.\n     *<p>\n     * Note: must be overridden by sub-classes as well.\n     *\n     * @return Newly constructed instance\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readResolve"
                    }
                ],
                "similarity": 0.12287176227876753,
                "end_line": 565,
                "signature": "com.fasterxml.jackson.core.JsonFactory.readResolve(): Object"
            },
            {
                "start_line": 375,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public CharsToNameCanonicalizer makeChild() {\n        return new CharsToNameCanonicalizer(this, _streamReadConstraints,\n                _factoryFeatures, _seed, _tableInfo.get());\n    }",
                "distance": 1.25,
                "title": null,
                "name": "makeChild",
                "documentation": "/**\n     * \"Factory\" method; will create a new child instance of this symbol\n     * table. It will be a copy-on-write instance, ie. it will only use\n     * read-only copy of parent's data, but when changes are needed, a\n     * copy will be created.\n     *<p>\n     * Note: while this method is synchronized, it is generally not\n     * safe to both use makeChild/mergeChild, AND to use instance\n     * actively. Instead, a separate 'root' instance should be used\n     * on which only makeChild/mergeChild are called, but instance itself\n     * is not used as a symbol table.\n     *\n     * @return Actual canonicalizer instance that can be used by a parser\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    },
                    {
                        "start_node": "CharsToNameCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "makeChild"
                    }
                ],
                "similarity": 0.12256440388647123,
                "end_line": 378,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.makeChild(): CharsToNameCanonicalizer"
            },
            {
                "start_line": 2240,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected IOContext _createNonBlockingContext(Object srcRef) {\n        // [jackson-core#479]: allow recycling for non-blocking parser again\n        // now that access is thread-safe\n        return new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration,\n                _getBufferRecycler(),\n                _createContentReference(srcRef),\n                false);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_createNonBlockingContext",
                "documentation": "/**\n     * Overridable factory method that actually instantiates desired\n     * context object for async (non-blocking) parsing\n     *\n     * @param srcRef Source reference to use for diagnostics, exception messages\n     *\n     * @return I/O context created\n     *\n     * @since 2.9.7\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_createNonBlockingContext"
                    }
                ],
                "similarity": 0.12251459269891203,
                "end_line": 2247,
                "signature": "com.fasterxml.jackson.core.JsonFactory._createNonBlockingContext(Object srcRef): IOContext"
            },
            {
                "start_line": 1296,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(byte[] data) throws IOException, JsonParseException {\n        IOContext ctxt = _createContext(_createContentReference(data), true);\n        if (_inputDecorator != null) {\n            InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length);\n            if (in != null) {\n                return _createParser(in, ctxt);\n            }\n        }\n        return _createParser(data, 0, data.length, ctxt);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Method for constructing parser for parsing\n     * the contents of given byte array.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.12168849214804338,
                "end_line": 1305,
                "signature": "com.fasterxml.jackson.core.JsonFactory.createParser(byte[] data): JsonParser"
            },
            {
                "start_line": 193,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public Builder maxStringLength(final int maxStringLen) {\n            if (maxStringLen < 0) {\n                throw new IllegalArgumentException(\"Cannot set maxStringLen to a negative value\");\n            }\n            this.maxStringLen = maxStringLen;\n            return this;\n        }",
                "distance": 1.25,
                "title": null,
                "name": "maxStringLength",
                "documentation": "/**\n         * Sets the maximum string length (in chars or bytes, depending on input context).\n         * The default is 20,000,000. This limit is not exact, the limit is applied when we increase\n         * internal buffer sizes and an exception will happen at sizes greater than this limit. Some\n         * text values that are a little bigger than the limit may be treated as valid but no text\n         * values with sizes less than or equal to this limit will be treated as invalid.\n         * <p>\n         *   Setting this value to lower than the {@link #maxNumberLength(int)} is not recommended.\n         * </p>\n         *<p>\n         * NOTE: Jackson 2.15.0 initially used a lower setting (5_000_000).\n         *\n         * @param maxStringLen the maximum string length (in chars or bytes, depending on input context)\n         *\n         * @return this builder\n         * @throws IllegalArgumentException if the maxStringLen is set to a negative value\n         */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "Builder"
                    },
                    {
                        "start_node": "Builder",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "maxStringLength"
                    }
                ],
                "similarity": 0.12135099005007206,
                "end_line": 199,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.Builder.maxStringLength(int maxStringLen): Builder"
            },
            {
                "start_line": 1263,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonParser createParser(InputStream in) throws IOException, JsonParseException {\n        IOContext ctxt = _createContext(_createContentReference(in), false);\n        return _createParser(_decorate(in, ctxt), ctxt);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "createParser",
                "documentation": "/**\n     * Method for constructing JSON parser instance to parse\n     * the contents accessed via specified input stream.\n     *<p>\n     * The input stream will <b>not be owned</b> by\n     * the parser, it will still be managed (i.e. closed if\n     * end-of-stream is reacher, or parser close method called)\n     * if (and only if) {@link com.fasterxml.jackson.core.StreamReadFeature#AUTO_CLOSE_SOURCE}\n     * is enabled.\n     *<p>\n     *\n     * Note: no encoding argument is taken since it can always be\n     * auto-detected as suggested by JSON RFC. Json specification\n     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n     * so auto-detection implemented only for this charsets.\n     * For other charsets use {@link #createParser(java.io.Reader)}.\n     *\n     * @param in InputStream to use for reading JSON content to parse\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createParser"
                    }
                ],
                "similarity": 0.12110349854027294,
                "end_line": 1266,
                "signature": "com.fasterxml.jackson.core.JsonFactory.createParser(InputStream in): JsonParser"
            },
            {
                "start_line": 168,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/StreamReadConstraints.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public Builder maxNumberLength(final int maxNumLen) {\n            if (maxNumLen < 0) {\n                throw new IllegalArgumentException(\"Cannot set maxNumberLength to a negative value\");\n            }\n            this.maxNumLen = maxNumLen;\n            return this;\n        }",
                "distance": 1.25,
                "title": null,
                "name": "maxNumberLength",
                "documentation": "/**\n         * Sets the maximum number length (in chars or bytes, depending on input context).\n         * The default is 1000.\n         *\n         * @param maxNumLen the maximum number length (in chars or bytes, depending on input context)\n         *\n         * @return this builder\n         * @throws IllegalArgumentException if the maxNumLen is set to a negative value\n         */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "Builder"
                    },
                    {
                        "start_node": "Builder",
                        "description": "contains method",
                        "type": "RELATED",
                        "end_node": "maxNumberLength"
                    }
                ],
                "similarity": 0.12028347886530048,
                "end_line": 174,
                "signature": "com.fasterxml.jackson.core.StreamReadConstraints.Builder.maxNumberLength(int maxNumLen): Builder"
            },
            {
                "start_line": 659,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public int calcHash(char[] buffer, int start, int len) {\n        int hash = _seed;\n        for (int i = start, end = start+len; i < end; ++i) {\n            hash = (hash * HASH_MULT) + (int) buffer[i];\n        }\n        // NOTE: shuffling, if any, is done in 'findSymbol()', not here:\n        return (hash == 0) ? 1 : hash;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "calcHash",
                "documentation": "/**\n     * Implementation of a hashing method for variable length\n     * Strings. Most of the time intention is that this calculation\n     * is done by caller during parsing, not here; however, sometimes\n     * it needs to be done for parsed \"String\" too.\n     *\n     * @param buffer Input buffer that contains name to decode\n     * @param start Pointer to the first character of the name\n     * @param len Length of String; has to be at least 1 (caller guarantees)\n     *\n     * @return Hash code calculated\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    },
                    {
                        "start_node": "CharsToNameCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "calcHash"
                    }
                ],
                "similarity": 0.12015124872798147,
                "end_line": 666,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.calcHash(char[] buffer, int start, int len): int"
            },
            {
                "start_line": 2311,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private final void _requireJSONFactory(String msg) {\n        if (!_isJSONFactory()) {\n            throw new UnsupportedOperationException(String.format(msg, getFormatName()));\n        }\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_requireJSONFactory",
                "documentation": "/**\n     * Helper method called to work around the problem of this class both defining\n     * general API for constructing parsers+generators AND implementing the API\n     * for JSON handling. Problem here is that when adding new functionality\n     * via factory methods, it is not possible to leave these methods abstract\n     * (because we are implementing them for JSON); but there is risk that\n     * sub-classes do not override them all (plus older version can not implement).\n     * So a work-around is to add a check to ensure that factory is still one\n     * used for JSON; and if not, make base implementation of a factory method fail.\n     *\n     * @param msg Message template to use for reporting problem (if necessary)\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_requireJSONFactory"
                    }
                ],
                "similarity": 0.11866263935008702,
                "end_line": 2315,
                "signature": "com.fasterxml.jackson.core.JsonFactory._requireJSONFactory(String msg): void"
            },
            {
                "start_line": 371,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFactory() { this((ObjectCodec) null); }",
                "distance": 1.0,
                "title": null,
                "name": "JsonFactory",
                "documentation": "/**\n     * Default constructor used to create factory instances.\n     * Creation of a factory instance is a light-weight operation,\n     * but it is still a good idea to reuse limited number of\n     * factory instances (and quite often just a single instance):\n     * factories are used as context for storing some reused\n     * processing objects (such as symbol tables parsers use)\n     * and this reuse only works within context of a single\n     * factory instance.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    }
                ],
                "similarity": 0.11816022722248107,
                "end_line": 371,
                "signature": "com.fasterxml.jackson.core.JsonFactory()"
            },
            {
                "start_line": 361,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this, _seed,\n                _tableInfo.get(),\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "makeChild",
                "documentation": "/**\n     * Factory method used to create actual symbol table instance to\n     * use for parsing.\n     *\n     * @param flags Bit flags of active {@link com.fasterxml.jackson.core.JsonFactory.Feature}s enabled.\n     *\n     * @return Actual canonicalizer instance that can be used by a parser\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    },
                    {
                        "start_node": "createRoot",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "ByteQuadsCanonicalizer"
                    },
                    {
                        "start_node": "ByteQuadsCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "makeChild"
                    }
                ],
                "similarity": 0.11793898575423792,
                "end_line": 366,
                "signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.makeChild(int flags): ByteQuadsCanonicalizer"
            },
            {
                "start_line": 321,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static CharsToNameCanonicalizer createRoot(int seed) {\n        return createRoot(null, seed);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "createRoot",
                "documentation": "/**\n     * @param seed Seed for hash value calculation\n     *\n     * @return Root instance to use for constructing new child instances\n     *\n     * @deprecated Since 2.16 use {@link #createRoot(TokenStreamFactory)} instead\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    }
                ],
                "similarity": 0.1164405302599041,
                "end_line": 323,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.createRoot(int seed): CharsToNameCanonicalizer"
            },
            {
                "start_line": 2038,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException {\n        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n                _generatorFeatures, _objectCodec, out, _quoteChar);\n        if (_maximumNonEscapedChar > 0) {\n            gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n        }\n        if (_characterEscapes != null) {\n            gen.setCharacterEscapes(_characterEscapes);\n        }\n        SerializableString rootSep = _rootValueSeparator;\n        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n            gen.setRootValueSeparator(rootSep);\n        }\n        return _decorate(gen);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_createUTF8Generator",
                "documentation": "/**\n     * Overridable factory method that actually instantiates generator for\n     * given {@link OutputStream} and context object, using UTF-8 encoding.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     *\n     * @param out OutputStream underlying writer to write generated content to\n     * @param ctxt I/O context to use\n     *\n     * @return This factory instance (to allow call chaining)\n     *\n     * @throws IOException if parser initialization fails due to I/O (write) problem\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_createUTF8Generator"
                    }
                ],
                "similarity": 0.11602657400271021,
                "end_line": 2052,
                "signature": "com.fasterxml.jackson.core.JsonFactory._createUTF8Generator(OutputStream out, IOContext ctxt): JsonGenerator"
            },
            {
                "start_line": 2223,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected IOContext _createContext(Object rawContentRef, boolean resourceManaged) {\n        return new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration,\n                _getBufferRecycler(),\n                _createContentReference(rawContentRef),\n                resourceManaged);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_createContext",
                "documentation": "/**\n     * Deprecated variant of {@link #_createContext(Object, boolean)}\n     *\n     * @param rawContentRef \"Raw\" source/target reference\n     * @param resourceManaged Whether input/output buffer is managed by this factory or not\n     *\n     * @return I/O context created\n     *\n     * @deprecated Since 2.13\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_createContext"
                    }
                ],
                "similarity": 0.11601658583626355,
                "end_line": 2228,
                "signature": "com.fasterxml.jackson.core.JsonFactory._createContext(Object rawContentRef, boolean resourceManaged): IOContext"
            },
            {
                "start_line": 733,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException {\n        return ByteSourceJsonBootstrapper.hasJSONFormat(acc);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasJSONFormat",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasJSONFormat"
                    }
                ],
                "similarity": 0.11601360841629706,
                "end_line": 735,
                "signature": "com.fasterxml.jackson.core.JsonFactory.hasJSONFormat(InputAccessor acc): MatchStrength"
            },
            {
                "start_line": 309,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static CharsToNameCanonicalizer createRoot() {\n        return createRoot(null);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "createRoot",
                "documentation": "/**\n     * @deprecated Since 2.16 use {@link #createRoot(TokenStreamFactory)} instead\n     *\n     * @return Root instance to use for constructing new child instances\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "createRoot"
                    }
                ],
                "similarity": 0.11567357018369818,
                "end_line": 311,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.createRoot(): CharsToNameCanonicalizer"
            },
            {
                "start_line": 448,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public int size() {\n        if (_tableInfo != null) { // root table\n            return _tableInfo.get().size;\n        }\n        // nope, child table\n        return _size;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "size",
                "documentation": "/**\n     * @return Number of symbol entries contained by this canonicalizer instance\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    },
                    {
                        "start_node": "CharsToNameCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "size"
                    }
                ],
                "similarity": 0.1151807955745529,
                "end_line": 454,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.size(): int"
            },
            {
                "start_line": 268,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent,",
                "distance": 1.0,
                "title": null,
                "name": "CharsToNameCanonicalizer",
                "documentation": "/**\n     * Internal constructor used when creating child instances.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    }
                ],
                "similarity": 0.11488801257759801,
                "end_line": 268,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, StreamReadConstraints src, int factoryFeatures, int seed, TableInfo parentState)"
            },
            {
                "start_line": 690,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private void copyArrays() {\n        final String[] oldSyms = _symbols;\n        _symbols = Arrays.copyOf(oldSyms, oldSyms.length);\n        final Bucket[] oldBuckets = _buckets;\n        _buckets = Arrays.copyOf(oldBuckets, oldBuckets.length);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "copyArrays",
                "documentation": "/**\n     * Method called when copy-on-write is needed; generally when first\n     * change is made to a derived symbol table.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "CharsToNameCanonicalizer"
                    },
                    {
                        "start_node": "CharsToNameCanonicalizer",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "copyArrays"
                    }
                ],
                "similarity": 0.11478862146847758,
                "end_line": 695,
                "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer.copyArrays(): void"
            },
            {
                "start_line": 848,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public StreamReadConstraints streamReadConstraints() {\n        return _streamReadConstraints;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "streamReadConstraints",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "streamReadConstraints"
                    }
                ],
                "similarity": 0.11464578527267073,
                "end_line": 850,
                "signature": "com.fasterxml.jackson.core.JsonFactory.streamReadConstraints(): StreamReadConstraints"
            },
            {
                "start_line": 1901,
                "file_path": "playground/fasterxml__jackson-core/src/main/java/com/fasterxml/jackson/core/JsonFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException {\n        return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n                _rootCharSymbols.makeChild());\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_createParser",
                "documentation": "/**\n     * Overridable factory method that actually instantiates parser\n     * using given {@link Reader} object for reading content.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     *\n     * @param r Reader to use for reading content to parse\n     * @param ctxt I/O context to use for parsing\n     *\n     * @return Actual parser to use\n     *\n     * @throws IOException if parser initialization fails due to I/O (read) problem\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "JsonFactory"
                    },
                    {
                        "start_node": "JsonFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_createParser"
                    }
                ],
                "similarity": 0.1144002263350125,
                "end_line": 1904,
                "signature": "com.fasterxml.jackson.core.JsonFactory._createParser(Reader r, IOContext ctxt): JsonParser"
            }
        ],
        "classes": [],
        "issues": [
            {
                "content": "(note: off-shoot of a comment on #1001)\r\n\r\nAs reported by @denizk there is a problem in applying overrides for one of constraints:\r\n\r\n```\r\nJsonFactory.setStreamReadConstraints(StreamReadConstraints.builder().maxNameLength(100_000).build());\r\n```\r\n\r\ndoes not update symbol table set by:\r\n\r\n```\r\nJsonFactory._rootCharSymbols = CharsToNameCanonicalizer.createRoot(this); \r\n```\r\n\r\nand only Builder-based alternative works.\r\nIt should be possible to apply constraints with `setStreamReadConstraints()` too.\r\n\n",
                "distance": 0,
                "title": "JsonFactory.setStreamReadConstraints(StreamReadConstraints) fails to update \"maxNameLength\" for symbol tables",
                "name": "root",
                "path": [],
                "issue_id": "root",
                "similarity": 2.0,
                "type": "issue"
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1207",
                "type": "issue",
                "content": "(note: off-shoot of a comment on #1001)\r\n\r\nAs reported by @denizk there is a problem in applying overrides for one of constraints:\r\n\r\n```\r\nJsonFactory.setStreamReadConstraints(StreamReadConstraints.builder().maxNameLength(100_000).build());\r\n```\r\n\r\ndoes not update symbol table set by:\r\n\r\n```\r\nJsonFactory._rootCharSymbols = CharsToNameCanonicalizer.createRoot(this); \r\n```\r\n\r\nand only Builder-based alternative works.\r\nIt should be possible to apply constraints with `setStreamReadConstraints()` too.\r\n\n\n",
                "source_code": null,
                "distance": 0.25,
                "title": "JsonFactory.setStreamReadConstraints(StreamReadConstraints) fails to update \"maxNameLength\" for symbol tables",
                "name": "issue#1207",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1207"
                    }
                ],
                "similarity": 0.7990692962388057,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1001",
                "type": "issue",
                "content": "On very big json (~20MB), convertion (serialization) string to object is not possible, error is thrown:\r\ncom.fasterxml.jackson.databind.JsonMappingException: String length (5046272) exceeds the maximum length (5000000) ..\r\nConversion works on version: 2.14.2\r\nConversion does not work on version: 2.15.0\n\n\nComment by pjfanning:\nThis is one the main features of the Jackson 2.15 release - an attempt to have Jackson fail if malicious input is provided.\r\n\r\nMost users do not use such large text entries in their JSON.\r\n\r\nYou can increase the limits by creating a [StreamReadConstraints](https://javadoc.io/static/com.fasterxml.jackson.core/jackson-core/2.15.0/com/fasterxml/jackson/core/StreamReadConstraints.html) instance and configuring your ObjectMapper with it.\r\n\r\nYou can increase the string limit from 5 million to 10 million like this:\r\n\r\n```\r\nobjectMapper.getFactory()\r\n\t\t.setStreamReadConstraints(StreamReadConstraints.builder().maxStringLength(10_000_000).build())\r\n```\r\n\r\nOr\r\n```\r\nJsonFactory jsonFactory = JsonFactory.builder()\r\n  .streamReadConstraints(StreamReadConstraints.builder().maxStringLength(10_000_000)\r\n  .build();\r\n\r\nObjectMapper objectMapper = JsonMapper.builder(jsonFactory).build();\r\n```\n\nComment by mail4csm:\nperfect\n\nComment by denizk:\nJust came across this ticket after upgrading to `2.16.1`.\r\n\r\nI've tried the method to override the default StreamReadConstraints._maxNameLen value of `50_000` with \r\n```\r\nobjectMapper.factory.setStreamReadConstraints(StreamReadConstraints.builder().maxNameLength(100_000).build())\r\n```\r\n\r\nHowever, this does not adjust the StreamReadConstraints used in \r\n```\r\nJsonFactory._rootCharSymbols = CharsToNameCanonicalizer.createRoot(this); \r\n``` \r\n\r\nwhich are initialised at JsonFactory construction time, so will end up with the defaults and inherit it to children used in JsonParsers when calling  `this._rootCharSymbols.makeChild()`\r\n\r\nSo, best to use the 2nd approach mentioned by @pjfanning in https://github.com/FasterXML/jackson-core/issues/1001#issuecomment-1527216221\n\nComment by cowtowncoder:\n@denizk Ok thank you for bringing this up. It is unfortunate. I will file an issue for this problem.\r\n\r\nSecond method would be preferred in general, but both should work.\r\n",
                "source_code": null,
                "distance": 0.25,
                "title": "2.15.0 com.fasterxml.jackson.databind.JsonMappingException: String length (5046272) exceeds the maximum length (5000000)",
                "name": "issue#1001",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    }
                ],
                "similarity": 0.6504988953293177,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "863",
                "type": "issue",
                "content": "So, similar to #827 there should be some upper limit for length of `String` values. We can start with something rather long -- 5 megs -- since the handling of textual values is not nearly as sensitive to input length as that of numeric (in particular floating-point). And also because there are likely use cases that rely on ability to process sizable Strings (different from numbers once again).\n\nDifferent from number constraints we can and should apply limit during accumulation of textual value, into `TextBuffer` (either within it, or maybe more likely, when caller fetches new local `char[]` buffer). The idea being that we do want to avoid processing of the whole String before failing.\nThis would probably mean that the limit applies to `char` length after entity resolution. That should be fine too; the goal is not to impose byte-accurate limits but to prevent overloading.\n\nNote: this is also distinct from total document length limit that we likely want to impose too, eventually.\n\n**EDIT**: (21-Mar-2023) 2.15.0-rc1 had limit of 1M, rc2 planned to use 5M. Updated description and title accordingly.\n**EDIT/2**: 2.15.1 raised default limit to 20M\n**EDIT/3**: (20-May-2025) see #1019 for globally configuring default limit, in case you cannot properly configure `JsonFactory` instances.\n\n\n\nComment by cowtowncoder:\ncc @pjfanning Just creating placeholder, based on our discussions. Even at the risk of security mongerers reading this :)\n\nComment by pjfanning:\nthis one may not be that useful - users would be better off setting a max length on the JSON stream that they will accept\n\nComment by cowtowncoder:\n@pjfanning I am not sure -- I guess I am considering bigger streaming use cases (where total content length cannot be easily limited), although granted those would probably not accept external untrusted input.\r\n\n\nComment by motlin:\nI upgraded to Jackson 2.15 and ran into the error:\r\n\r\n```\r\nCaused by: com.fasterxml.jackson.core.exc.StreamConstraintsException: String length (X) exceeds the maximum length (5000000)\r\n```\r\n\r\nSearching for that error message led me here. It's clear this is an intentional change. It would be helpful to add instructions here on how to fix it. Am I able to configure that limit to be higher? Do I need to switch to a more efficient API?\n\nComment by pjfanning:\n@motlin see https://github.com/FasterXML/jackson-core/issues/1001#issuecomment-1527216221\n\nComment by motlin:\nThank you @pjfanning.\r\n\r\nThat comment shows that we're able to set the max length higher with code like:\r\n\r\n```java\r\nobjectMapper.getFactory()\r\n\t\t.setStreamReadConstraints(StreamReadConstraints.builder().maxStringLength(10_000_000).build())\r\n```\r\n\r\nI'm able to effectively disable the feature by setting the max length to `Integer.MAX_VALUE`, but not 0.\r\n\r\n```java\r\nObjectMapper objectMapper = ...;\r\nStreamReadConstraints streamReadConstraints = StreamReadConstraints\r\n    .builder()\r\n    .maxStringLength(Integer.MAX_VALUE)\r\n    .build();\r\nobjectMapper.getFactory().setStreamReadConstraints(streamReadConstraints);\r\n```\r\n\r\nI'm going to set the max length high to unblock the upgrade. It's not clear to me if this is a good idea or if this indicates a real performance problem in my code. Are there other options I ought to consider?\n\nComment by pjfanning:\n@motlin this is your decision - Integer.MAX_VALUE is the right value if you don't want to apply a limit.\n\nComment by motlin:\nThe json I'm parsing has huge string values inside, so I think this is the correct thing to do. What confused me is that the error mentions StreamConstraintsException which made me think of Jackson's streaming apis. I'm using `objectMapper.readValue(...)` and thought the error might be telling me to switch to the streaming api.\n\nComment by cowtowncoder:\nAh. No, it refers to where the constraints are enforced.\r\n\r\n@pjfanning Remember when I mentioned it matters what exception says, wrt users trying to figure out how to change settings? :)\n\nComment by pjfanning:\nExceptions should not have essay length messages. Could we create a FAQ entry that describes what to do when you get this exception? We could even put a link in the exception message. The text of how to set these constraints is going to take 10-20 lines.\n\nComment by cowtowncoder:\nJust to make clear: no one is asking for essay-length messages but rather useful pointer(s): for that FAQ + link sounds like a good idea (for example). Keywords in message help too.\r\n\r\n@motlin What do you think? What was the exact message if you still have access? (I know, it's in code too but just for convenience for readers here).\r\n\n\nComment by motlin:\nAnonymized error below. I don't have strong opinions on what the error message ought to look like. As long as users can search for the error and find a pointer to the advice above about `objectMapper.getFactory().setStreamReadConstraints(streamReadConstraints)` then I think we're good. Right now, searching for \"jackson String length exceeds the maximum length\" in Google leads me here to this issue, but it's not the top result.\r\n\r\n```\r\njava.lang.RuntimeException: com.fasterxml.jackson.databind.JsonMappingException: String length (5000001) exceeds the maximum length (5000000) (through reference chain: MyClass[\"myMap\"]->java.util.LinkedHashMap[\"myKey\"]->MyClass2[\"myLongString\"])\r\n\tat <my code>\r\nCaused by: com.fasterxml.jackson.databind.JsonMappingException: String length (5000001) exceeds the maximum length (5000000) (through reference chain: MyClass[\"myMap\"]->java.util.LinkedHashMap[\"myKey\"]->MyClass2[\"myLongString\"])\r\n\tat com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:402)\r\n\tat com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:361)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.wrapAndThrow(BeanDeserializerBase.java:1830)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeWithErrorWrapping(BeanDeserializer.java:570)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:439)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1409)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBind(MapDeserializer.java:557)\r\n\tat com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:451)\r\n\tat com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:32)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:545)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeWithErrorWrapping(BeanDeserializer.java:568)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:439)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1409)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3637)\r\n\tat <my code>\r\n\t... 16 more\r\nCaused by: com.fasterxml.jackson.core.exc.StreamConstraintsException: String length (14408) exceeds the maximum length (10000)\r\n\tat com.fasterxml.jackson.core.StreamReadConstraints.validateStringLength(StreamReadConstraints.java:290)\r\n\tat com.fasterxml.jackson.core.util.ReadConstrainedTextBuffer.validateStringLength(ReadConstrainedTextBuffer.java:27)\r\n\tat com.fasterxml.jackson.core.util.TextBuffer.contentsAsString(TextBuffer.java:482)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._finishAndReturnString(UTF8StreamJsonParser.java:2561)\r\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.getText(UTF8StreamJsonParser.java:335)\r\n\tat com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:42)\r\n\tat com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:11)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:545)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeWithErrorWrapping(BeanDeserializer.java:568)\r\n\t... 35 more\r\n```\n\nComment by cowtowncoder:\nOk so message has no reference to any class or such. We could add a reference to `StreamReadConstaints.[CONSTRAINT]` and that would probably be more searchable.\r\n\n\nComment by stolsvik:\nGot surprised by this. Would have appreciated more info in Exception, yes! I am not scared of essay-length exceptions - it is better with a bit on the verbose side, than leaving users (devs) completely dumbfounded. \r\n\r\nSituation: I have a use case in https://mats3.io/ where I stick one JSON serialized DTO inside another DTO, the containing envelope \"MatsTrace\". Although this might not be seen as ideal from a performance perspective, I want these two to be completely separate (they are separately deser'ed, and the \"outer\" container doesn't know the \"inner\" classes, and the inner might even use another deser entirely), and it works just fine.\r\n\r\nThe 5M limit bit pretty hard, and is quite small, and I really don't quite see the need for a default limit at all - when the previous version had no limit. One can also envision large XML, other markup documents, in addition to JSON (as with me)  being carried inside strings, and 5 meg is not much. **Should this not be a configurable constraint which default is non-constrained?** Or at least have a _much_ higher limit as default?\r\n\r\nI assume this is meant as a security measure. However, this gives the possibly unintended consequence: Jackson _serializes_ an object just fine, but then refuses to _deserialize_ its own output. This is not a good situation.\r\n\r\nI cannot be the only one being bitten by this - and it can come at rather inopportune times, where the data can slide through in staging, but then hit this .. rather arbitrary limit .. in prod. Cc @cowtowncoder \r\n\r\n\n\nComment by cowtowncoder:\n@stolsvik We had long discussions on this, and were really hoping that more developers had tried out release candidates so we'd get feedback on possible issues.\r\nAnd yes, this is specifically to address security concerns (although TBH, of 3 limits imposed, String values are probably the least important due to various reasons).\r\n\r\nFor what it is worth, the original setting was lower -- 1 MB -- but based on feedback by one of developers increased it to 5 MB (was considering 10 MB but his tests found maximum size below 4MB or so for production usage).\r\nThere is currently no limit for the total document size.\r\n\r\nAs to why introduce any limits: this is a hot topic in security community and I think that in general it would make sense to start with some limits, even if high -- many would consider 5 meg Strings rather large fwtw, but of course if your use cases require higher it's not high.\r\nI do understand it is problematic in cases like ours where formerly there was no limit aside from memory usage.\r\n\r\nGiven that 2.15.0 release is out, I am not sure there is much point in trying to tune the defaults. Problem exists for those who do need to process humongous Strings.\r\n\r\nBut just in case: what would you think would be limit that works for your use cases? How big are biggest string values seen in production (if you have such data).\r\n\r\n\r\n\n\nComment by stolsvik:\n@cowtowncoder Thanks.\r\nI have a \"this is crazy, something must be wrong!!\" hard limit on 100M total.\r\nThat is on the serialization-side.\r\n\r\nThat is what I find the most problematic here: Jackson _serializes_ an object just fine, and then you turn around, and it crashes on deserialization.\r\n\r\nI do not agree to you being too late with adjusting that limit. Judging by mvnrepository: https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core, it seems like rather few have gotten around to update yet, and I bet it is much worse inside organizations. A quick 2.15.1 would most probably hinder many heavy in-prod gotchas!\r\n\r\nPS: Wrt. to security concerns, does it not arguably make more sense to limit the total memory usage when deserializing? Have some kind of \"global counter\" for the current object? I mean, as a bad guy, I can possibly bypass this individual limit if I have access to a list or array of strings? Just include a ton of 4.99M strings?\n\nComment by cowtowncoder:\n@stolsvik My point on \"too late\" is that there seem to be many devs not picking up the latest, but somehow get 2.15.0 and so on. But perhaps you are right.\r\n\r\nAs to limit, 100 MB is bit high but then again since this is NOT the limit that has been specifically requested (max number limit and nesting have specific vulns disclosed) it'd be doable.\r\n\r\nAs to total memory: things get complicated and I don't think keeping track of separate pieces is worth it. Conceptually I think combination of max-doc-length (not yet added; quite possible to be done outside Jackson until then) and longest-individual value are suitable building blocks to add service protection. So yeah, focus only on single values would be misplaced.\r\nBut I think I need to prioritize max-input-doc-length for 2.16 for completeness.\r\n\r\nOn serialization vs deserialization, I don't know -- I don't that as a strong argument mostly because there are so many tools & common case being one where library/framework reading is different from one doing writing. So Jackson applying same limits for both is probably not all that important. YMMV.\r\nThere is still an idea to add similar limits on output side, fwtw (`StreamWriteConstraints`), just not been as much a priority as input side.\r\n\r\nNow: could file a new issue for raising String value max length for 2.15.1 to.. whatever you think more reasonable?\r\n100 MB means 200 meg size chunk which is somewhat high, but maybe we could go with 20 megs?\r\nI know it is arbitrary at any rate.\r\n\r\n\r\n\n\nComment by darrenoc3:\nWe have been hit by this error too and it's quite frustrating to have to override the limit separately for every objectMapper we create, it should at least be possible to override the limit at a global level. Aside from that, the 5MB limit seems too low, as mentioned elsewhere Strings of this size do not pose much security risk compared to numbers so the limit could safely be set higher. A large config file can easily be over 10MB in the problem domain I'm working in.\r\n\n\nComment by cowtowncoder:\n@darrenoc3 Just to make sure: when you say config files, do you have config files with individual String values that big? I can see that Document limit, if imposed, should be much bigger, but individual String value of 10 MB+ would seem unusual.\r\n\r\nHaving said that, I am still looking for suggestions on default limit to set. As I mentioned, 5 megs was based on feedback. Hence my suggestions of going with 20 megs (characters).\r\n\n\nComment by darrenoc3:\n> @darrenoc3 Just to make sure: when you say config files, do you have config files with individual String values that big? I can see that Document limit, if imposed, should be much bigger, but individual String value of 10 MB+ would seem unusual.\n> \n> Having said that, I am still looking for suggestions on default limit to set. As I mentioned, 5 megs was based on feedback. Hence my suggestions of going with 20 megs (characters).\n> \n\nThe config files are not JSON themselves (legacy format), but they still get marshalled in and out of JSON as HTTP requests/responses. So in essence the string limit becomes the document limit for this kind of use case. \n\nComment by cowtowncoder:\nCreated #1014 for possible increase of the default limit for 2.15.1; please comment there.\r\n\r\n/cc @stolsvik \r\n\n\nComment by cowtowncoder:\n> > @darrenoc3 Just to make sure: when you say config files, do you have config files with individual String values that big? I can see that Document limit, if imposed, should be much bigger, but individual String value of 10 MB+ would seem unusual.\r\n> > Having said that, I am still looking for suggestions on default limit to set. As I mentioned, 5 megs was based on feedback. Hence my suggestions of going with 20 megs (characters).\r\n> \r\n> The config files are not JSON themselves (legacy format), but they still get marshalled in and out of JSON as HTTP requests/responses. So in essence the string limit becomes the document limit for this kind of use case.\r\n\r\nAh. Sort of like config files embedded in K8s YAML specs (or XML in JSON or legacy format) etc.\r\n\r\nAs per my other comment, I am considering raising the default for ergonomic reasons. But would like to find a sweet spot fully knowing that no limit will work perfectly.\r\n\r\n\n\nComment by davidmoten:\nI'd prefer to see the default stream limit being unlimited. Nice to be able to set it but should be the user's choice. \r\n\r\nMy argument for this is that this change will break a lot of systems at runtime in production, including the Australian Government Search and Rescue system that I work on. I was lucky to notice it in a lower environment so we will be ok but this will hurt a lot of production systems out there.\r\n\r\nNote that I am happy to see that it was well described in the 2.15 release notes, that was on me to miss it as I review these things normally.\n\nComment by cowtowncoder:\n> I'd prefer to see the default stream limit being unlimited. Nice to be able to set it but should be the user's choice.\r\n\r\nAnd it is unlimited, as you wish! 2.15 does not limit maximum content length at all. Limits are only for JSON values of type Text/String (this issue) and Numbers.\r\n\r\n2.16 will add this via #1046 but will default to \"unlimited\".\r\n\r\n\n\nComment by davidmoten:\n> And it is unlimited, as you wish! 2.15 does not limit maximum content length at all. Limits are only for JSON values of type Text/String (this issue) and Numbers.\r\n\r\nAh I needed be more precise. I was referring to JSON text values. We encounter them in JSONified emails from O365. Pretty easy to encounter >5MB fields in that context.\r\n\r\n\n\nComment by cowtowncoder:\n@davidmoten As per #1014 the default was raised to 20 megs in 2.15.1 where it is planned to stay. For what that's worth.",
                "source_code": null,
                "distance": 0.5,
                "title": "Add `StreamReadConstraints` limit for longest textual value to allow (default: 5M in 2.15.0; 20M in 2.15.1)",
                "name": "issue#863",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    }
                ],
                "similarity": 0.4845061530967801,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1047",
                "type": "issue",
                "content": "(note: part of #637) \r\n\r\nSimilar to token-length limits for Numbers (see #815) and Strings (see #863), we need an option to limit maximum Object Property name length to something reasonable, as otherwise name tokenization can become performance issue for very long names.\r\n\r\nAs with other limits, units would related to underlying input units -- `byte`s or `char`s depending on input source.\r\n\r\nWe need to decide on reasonable defaults to use: my initial suggestion is to limit to 64k but this probably needs to correlated to:\r\n\r\n1. Performance-characteristics (can we find a pivot point where length increase has super-linear negative effect?)\r\n2. Longest legit (non-malicious) property names used in the wild.\r\n\r\nThat is: figure out highest limit that works for DoS aspect, balanced with lowest limit that would be unlikely to break existing legit usage.\r\n\r\n\n\n\nComment by ghost:\nI am also in favor of this ticket, as I wrote in this comment: https://github.com/FasterXML/jackson-core/issues/1014#issuecomment-1623045770\n\nComment by cowtowncoder:\n@AlessandroPerucchi note that there is already ability to change existing limits: this would introduce one more limit.\n\nComment by yhojann-cl:\nRelated issue: https://github.com/spring-projects/spring-boot/issues/36666 the key names are not controlled and produces an integer overflow when try copy the byte array. Confirmed in Java Spring Framework.\n\nComment by cowtowncoder:\nQuick note: based on simple local testing with longer names, it looks like performance of, say, 1_000_000 (ascii) bytes/chars decoding is not superbly bad -- actually, unit test with cold start seems to process doc with 10 meg name in about 150 msecs. And although other factors (escaping, UTF-8 chars) no doubt change things (quick testing with escapes and 2-byte chars actually increases time to almost 500 msecs), I think we can -- if we want to -- allow larger names than 50k, by default, if we want to.\r\n\r\nI'll see if I can find limits other processors impose.\r\n\n\nComment by cowtowncoder:\nImplemented via #1078.",
                "source_code": null,
                "distance": 0.75,
                "title": "Add configurable limit for the maximum length of Object property names to parse before failing (default max: 50,000 chars)",
                "name": "issue#1047",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1047"
                    }
                ],
                "similarity": 0.4432569659257429,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "637",
                "type": "issue",
                "content": "(note: related to/inspired by https://github.com/FasterXML/jackson-databind/issues/2816)\r\n\r\nSome aspects of input document are prone to possible abuse, so that malicious sender can create specifically crafted documents to try to overload server. This includes things like:\r\n\r\n1. Ridiculously deeply nested documents (it only takes 2 characters to create Array context so 8k document can have 4000 levels of nesting) -- implemented via #943\r\n2. Very long documents (in general): while streaming decoder has no problems with length per se, higher level databind can easily exhaust memory even with somewhat normal amplification (that is, input content of 10 megabytes can result in a data structure of 100 megabytes) -- implemented via #1046\r\n3. Very long names: Jackson's name decoding is optimized for short names and while it can handle any length (within bounds of total memory available) performance characteristics are not great beyond, say, couple of thousands of characters -- implemented via #1047\r\n4. Very long numbers: textual length of tens of thousands of numbers might be problematic for some uses -- implemented via #827\r\n5. (possibly?) Huge number of properties per JSON Object -- for some use cases construction of data structures with tens or hundreds of thousands of distinct keys can be problematic -- not implemented, no immediate plans; can create new issue if this is still desired (ditto for big Arrays)\r\n6. Extra long text segments (megabytes of content) can similarly become problematic -- this could also result from broken encoding (missing closing quote) -- implemented via #863\r\n\r\nand although streaming parser can typically handle many of these cases quite well, they can be very problematic for higher-level processing -- and even for streaming, for highly parallel processing.\r\n\r\nSo. It would be good to create a configurable set of options that:\r\n\r\n1. Default to same safe set of limits for likely problematic cases (like limit nesting to what is known to typically fit in wrt stack frames; limit maximum property names)\r\n2. Leave more speculative limits (text length) to unlimited (or very high)\r\n3. Offer a simple way to configure limits (possibly only per `JsonFactory`, although it'd be really nice if per-parser overrides were possible)\r\n\r\nFurther reading: related material.\r\n\r\nHere are some relevant links:\r\n\r\n* https://github.com/zio/zio-json#security outlines some general problem areas (overlaps with some of points above)\r\n\r\n\n\n\nComment by cowtowncoder:\nSince 2.13 has been released marking as 2.14 (earliest) due to need for API additions and possible compatibility concerns for some maximum limits.\r\n\r\nAlso: I think this issue is still important even if databind tackles some of more immediate concerns (via https://github.com/FasterXML/jackson-databind/issues/2816).\r\n\n\nComment by cowtowncoder:\nSome thinking out aloud:\r\n\r\n* Limits for total input document size can probably be checked at points when input blocks are read (blocking) or fed (async): this is what Woodstox does and appears to work beautifully with minimal overhead. Limits probably need to be in units of \"whatever input unit is, byte/char\"\r\n* Limit for nesting is a much bigger challenge but my first instinct is to integrate this to `JsonStreamContext`/`JsonReadContext` (2.x) (`TokenStreamContext` in 3.0) -- that is, check it when trying to add next context. This can get tricky due to inability to throw checked (in 2.x) `JsonProcessingException` but we'll cross that bridge if and when we get that far.... there's also the obvious challenge of how to pass limit configuration in the first place.\r\n\r\nAs to configuration settings, there probably needs to be a shared base type (`StreamProcessingLimits`), as concrete implementation, and with a singleton \"default\" or \"empty\" instance to feed in case where no explicit configuration is used. And then with format-specific extensions allowed.\r\nShould probably use Builder-style construction, limits instances fully immutable (obviously) to be shareable.\r\n\r\nOne immediate concern I have, however, is that of adding state to `JsonReadContext`: seems like we need both current level (int) and configuration settings; latter to be passed when creating \"root\" instance, then passed to children.\r\nAlternative would be to require config to be passed on every \"createXxx()\" call -- this would prevent need to hold on to a reference (save 1 field) but would be much more intrusive as callers would need to be changed.\r\nSo probably better to add 2 fields.\r\n\r\n\n\nComment by cowtowncoder:\nWill not happen for 2.14 but should be the first thing for 2.15.\n\nComment by cowtowncoder:\nImplemented for inclusion in 2.15:\r\n\r\n* Maximum number lengths: #827 \r\n* Maximum String value length: #863\n\nComment by pjfanning:\n@cowtowncoder are there any more of these that you want to do for 2.15?\n\nComment by pjfanning:\nThe total size could readily be limited using stream wrappers like those in https://github.com/pjfanning/json-size-limiter/tree/main/src/main/java/com/github/pjfanning/json/util . That code is borrowed. It should also be possible to find ByteBuffer equivalents. There is an argument that many web service frameworks have support for limiting the acceptable size of inputs - and that users should prefer those approaches. The earlier that the large input size is spotted, the better \n\nComment by cowtowncoder:\nYes, ideally we'd be able to target (1) by `JsonStreamContext`, and (2) for input and output sizes.\r\nBut I don't know how timing would work.\r\n\r\nI think existence of stream wrappers is useful and can work for now even if eventually in-core limits were added.\r\n\r\nBut deeper nesting checks should definitely be added in core at some point. Just not sure if timing works for 2.15.\r\n\r\nAnd field names... that's an interesting thing. Not commonly reported as attack but conceivably it would be vector same way (... and more) as max String token length.\r\n\n\nComment by pjfanning:\nIt seems like (2) is something that can be left to users. I think it is reasonable for jackson to concentrate on the cases where comparatively fewer bytes in input can lead to bad outcomes.\n\nComment by cowtowncoder:\n@pjfanning It could be, altough I implemented this with Woodstox few years back and it really is rather easy to add. Then again Jackson-core supports decorators so it's... even easier to wrap by users.\r\n\r\nBut I agree it's not a high priority at this point.\r\n\r\n\n\nComment by cowtowncoder:\nFiled #1046 for max document length -- I think it is worth adding, after thinking it through. Hope to work on it for 2.16.\r\n\n\nComment by cowtowncoder:\nOut of 6 ideas, 5 now implemented and included in `2.16.0-rc1`; no plans yet for last one (max # of properties per Object); can file a new issue if need be.\r\n\r\nClosing this issue as completed.",
                "source_code": null,
                "distance": 0.75,
                "title": "Add configurable processing limits for JSON parser (`StreamReadConstraints`)",
                "name": "issue#637",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#637"
                    }
                ],
                "similarity": 0.4421110825473388,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1014",
                "type": "issue",
                "content": "(note: possible follow-up to #959)\r\n\r\nBased on user/dev feedback wrt 2.15.0 release, there seem to be use cases where JSON String values (note: NOT Document size) exceed 5 million characters. While this is configurable limit it seems best to try to change default to be yet more lenient, given that this is not the likeliest way to try to cause DoS. It is also the case that those who do wish to use more modest sizes will anyway need to lower limits, regardless of defaults we choose.\r\n\r\nMy initial thinking is to increase this further to 20 million (giving max memory usage of about 40 megs in JVM -- although temporarily up to twice that due to segmented storage), for Jackson 2.15.1.\r\n\r\n\r\n\n\n\nComment by gdimitrov7:\nWe hit the same issue in our product. 20M should be much better and less intrusive and I fully support it.\r\n\r\n**Q1**: Why there is a limit for the max String value? I mean I understand the other limits - `maxDepth`, `maxNumLen` - there are performance penalties for them. In the same I do not see exponential increase for the String values length. And yes, there can be OOM but most apps limit the input to be processed - for example on HTTP request body length. Example: Our server has 2GiB heap with max request body 20M - it does not matter if we have JSON with: \r\n\r\n- 2000 fields by 10k chars each (~20M)\r\n- or 1 field by 20M chars (~20M)\r\n\r\nin both cases it should take 2x40M bytes to process the request and parse the body, meaning that we can process ~25 request in the same (if there is no other mem consumed).\r\n\r\nI do not say we have to remove the limit, but can it be much bigger by default? \r\n\r\n**Q2**: Is it possible to read the default max from system property?\r\n\r\n>        public static final int DEFAULT_MAX_STRING_LEN =  \r\n>                   Integer.getInteger(\"com.fasterxml.jackson.core.StreamReadConstraints.maxStringLen\", 20_000_000);\r\n\r\nIt will be much easy to be overwritten by apps that need bigger limit by some valid reasons.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\nComment by cowtowncoder:\nYeah, String value length limit is sort of inspired by number value limit; but practical effects are quite different. In theory I think that if limits were included from beginning they wouldn't have been problematic; going from unlimited to limit is the issue.\r\nOn multiple vs individual fields; this is where maximum doc length limit (not yet implemented) would be needed anyway.\r\n\r\nAs to system properties: for libraries like Jackson, which may be used by multiple other things, frameworks, concurrently, system-wide settings do not make sense in my opinion (system properties essentially being mutable singletons).\r\n\r\nBe that as it may, Jackson does not use system properties for anything and my view is that while I do not object to their use, it should occur via extension modules (although in this particular case that'd be difficult to apply).\n\nComment by gdimitrov7:\nI understand that system properties are not used in Jackson. In the same time they have place in other libraries like logback or even in the JDK.\r\n\r\nI agree they are mutable singletons but in cases like this - enforcing new limits - they provide easy way to change to custom bigger value at runtime with just restarting the application and with no code changes and no new version. And provides much easy support when we have issue at the customer environment.\n\nComment by pjfanning:\nI suggested before the idea of having static methods on StreamReadConstraints that can be used to change the settings for the default StreamReadConstraints. I think this is a viable solution with one downside - some rogue lib maintainer could set values using this approach and that affects any other code running using that ClassLoader. The static methods would ideally only be used by users providing the actual services.\r\n\r\nMost users should strongly consider creating their own factory methods for creating ObjectMapper instances - so that they can centralise their preferred config settings.\n\nComment by cowtowncoder:\nOk. So, although I have been resistant to ideas like what @pjfanning proposed, I am starting to think about this bit more. And I prefer static setter methods over system properties, as mechanism jackson-core could provide; and then allow something else to offer system properties mechanism if that is deemed useful.\r\n\r\nAs long as static setter method was properly documented with all the caveat and warnings -- basically stating that it is not recommended to be used except by end-user application; and that there are problems with stateful global singletons in general -- I think I'd be +1 for adding such methods in 2.16.\r\nIt seems like one of those things that while not generally recommended, could solve some actual real-world issues.\r\n\n\nComment by pjfanning:\n@cowtowncoder the static methods are most useful for v2.15.1 - to make it easier for people who are migrating now. They won't be very useful if left till v2.16.0.\r\n\r\nI've raised issues in a number of projects (libs and apps) that use Jackson and there hasn't been much interest in them supporting allowing their users to configure StreamReadConstraints.\r\n\r\nI think we are stuck with having to support a mechanism that allows users to modify the default values that StreamReadConstraints applies when users don't set their own via creating their own JsonFactory with their own StreamReadConstraints instance attached.\n\nComment by cowtowncoder:\nAt this point I don't want to make API changes against semantic versioning, adding new functionality in patch versions.\r\nWe'll see if this change alone helps wrt 2.15.1.\r\n\r\nAs to adding change in 2.16 I'll wait for someone requesting such a thing; all I am saying is am no longer against that possibility.\r\n\n\nComment by cowtowncoder:\nChanged my mind, see #1019 to be included in 2.15.2. \n\nComment by stolsvik:\nI realize I am late to the party here, but I'd prefer you set the default limit to some very high value, like 1G or even higher.\r\n\r\nIt makes exceptionally little sense for me that a deserialization library should hinder the sizes of something as ordinary as the individual strings within a JSON.\r\n\r\nI do get the problem of DoS-style attacks, and that the other limits makes some sense. But string values are absolutely fundamental. If you have problems with \"random JSONs\" coming over your wires, I fail to see why it should be the (de)serialization library that hinders very long strings - this should be caught by some earlier mechanism where you control the size of the received payload.\r\n\r\nAgain, the other limits (e.g. excessive number of decimals, excessive nesting etc) makes more sense: These are arguably more subtle vectors for DoSing when using deserialization mechanisms, that are harder to envision and comprehend, compared to plain \"large payload size\". But even here the default limits should be very high, so that they never come in the way for something that _most probably_ are standard processing.\r\n\r\nIf you as a developer uncritically accept a payload of 10GB, then that is on you - I just fail to see why \"a random JSON deserialization library\" should have the _default_ obligation to protect you from this. It could be an optional feature, but why default?\r\n\r\nDo I make any sense here?\r\n\r\nEdit: Also, as probably mentioned earlier: The total document size (either just the consumed bytes - or the deserialized object tree or whatever) would be much saner to limit the size of - not any individual strings within such a document. I mean, as a DoS attack, I could now just hammer in 1M x 20M strings and rip your memory to pieces anyway.\n\nComment by cowtowncoder:\nI think it's safe to say that opinions on how much \"default protection\" should be provided vary A LOT. From \"why would you ever accept longer than 64k string unless someone enables it\" to \"just leave it at Integer.MAX_VALUE unless _I_ say otherwise\". There are valid points to all views and it really depends.\r\n\r\nIn hindsight this particular setting should probably have been left at relatively high value; but with versions being out there I don't think I'll be changing defaults for 2.15.x at least.\r\nFor 2.16 we can still consider changes; if so, please file a new issue.\r\n\r\nAnd yes, I agree wrt points on max doc size limit -- it was left out due to timing constraints.\r\nI do not necessarily agree that max doc size only matters (if we are talking about max input length), since there is streaming use case where input size may be sort of infinite, as it is never read fully in memory in its entirety: this is different from JSON Strings which are always read fully in memory (even if lazily).\r\n\r\nAnd conversely limiting String value length was inspired by number length limit; however, it's not a good analogy as the trade-offs are quite different.\r\n\r\nOne takeway for me, too, is that I should have heeded my own \"never add a feature just for sake of consistency; only implement things that have been specifically requested\".\r\nThat'd have worked well here, addressing just number length & nesting depth -- both of which have specific known threats.\r\n\r\nThank you everyone for your feedback here!\r\n\n\nComment by ghost:\nHi,\r\nI'm late in the game too, but I would like to thank you for correcting that \"bug\" with the 5'000'000 bytes size and increasing to 20'000'000 bytes. That solved our issue.\r\nThat said, since we are handling documents that can vary very much in size, even the 20'000'000 limit that you put, is already too small for us.\r\nWe installed the patch for our application yesterday with the version 2.15.2, and it solved all our problems, and today we receive a document which was bigger, and got the following error:\r\n\r\n Caused by: org.springframework.core.codec.DecodingException: JSON decoding error: String length (20054016) exceeds the maximum length (20000000)\r\n \r\n And for end of year, it will probably skyrocket to even higher numbers.\r\nSo for me, what would make more sense, is to have a generic solution, where the developer can decide what is the limit he wants.\r\nI will open a new issue ticket that in mind.\r\nFor the moment, we will try to have a custom version of this library and set the limit higher, so until an official solution is found, we can go back to the official one.\r\n\r\nPS: In our case, we are not subject to attacks, since our systems are not in internet, and the cycle of handling documents are well controlled from each step of the process. So we don't \"care\" if the limit was set to 10GB. Well we care about the memory used :-D of course!!! But these potential DOS-style attack in our really particular case is not a concern.\r\n\r\nPS2: Well I didn't open a new ticket since there are already tickets open for that and other aspects that are also important! So I won't pollute by opening a duplicate one! :-D\n\nComment by cowtowncoder:\nThere is already way to change maximum limits; both via per-factory `StreamReadConstraints` configuration and static (2.15.2) setter method on `StreamReadConstraints`.\n\nComment by singleta:\nHi, I came across this discussion when the system I work on encountered the limit error this week after we updated our dependency to 2.15.2. We process PDF and JPEG files from a few KB up to 100MB as Base64 encoded strings in the request body. We have a data security restriction that prevents us from storing this data as a temporary file so we have to process it from the request body. \r\n\r\nFortunately our production code is still using 2.14.0-rc1 so that is not suffering.  \r\n\r\nAs AlessandroPerucchi mentioned in his comment, we would also appreciate a user-configurable limit. Our data comes from trusted sources that have already had to jump through some security hoops so we are only concerned with the memory footprint of the large files.\n\nComment by pjfanning:\n@singleta StreamReadConstraints is configurable - have you read https://github.com/FasterXML/jackson-core/issues/1014#issuecomment-1624350361 ?\n\nComment by ghost:\n@cowtowncoder Thank you, I wasn't aware of this possibility :)\n\nComment by dan2097:\n> My initial thinking is to increase this further to 20 million (giving max memory usage of about 40 megs in JVM -- although temporarily up to twice that due to segmented storage), for Jackson 2.15.1.\r\n\r\nTypical machines have gigabytes of memory! \r\n\r\nThe limits like nesting depth make sense as these can't easily be checked by the caller, but string length definitely is checkable. \r\nGiven that the JSON specification doesn't set a maximum length there should be a damn good reason for the out of the box behaviour to be incompatible with the specification and a \"unlikely attack vector\" that can be easily checked by the caller to me doesn't seem like sufficient justification. (EDIT RFC 7159 does allow a limit on length to be specified, so it is still technically complain with the JSON specifications)\r\n\r\nThese sort of limits are especially insidious as code that worked on test examples can fail for a small percent of input in production that happens to exceed this arbritrary limit.\r\n\r\n\n\nComment by mrexodia:\nIn case anyone needs to set a reasonable limit (`String length (5041581) exceeds the maximum length (5000000)`):\r\n\r\n```java\r\n// NOTE: This object mapper should be reused across the application\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(\r\n            new JsonFactoryBuilder()\r\n                    .streamReadConstraints(\r\n                            StreamReadConstraints\r\n                                    .builder()\r\n                                    .maxStringLength(Integer.MAX_VALUE) // your limit here\r\n                                    .build()\r\n                    ).build()\r\n    );\r\n ```\r\n\r\nThere is no security issue being fixed here (see https://www.youtube.com/watch?v=lr1KuL8OmJY for a good explanation), so all this limit does is cause unexpected breakages in production systems and waste engineering time \ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f",
                "source_code": null,
                "distance": 1.0,
                "title": "Increase default max allowed String value length from 5 megs to 20 megs",
                "name": "issue#1014",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1014"
                    }
                ],
                "similarity": 0.3666269910154894,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "443",
                "type": "issue",
                "content": "Please update the release notes for 2.9.2, 2.9.3, and 2.9.4 in https://github.com/FasterXML/jackson-core/blob/master/release-notes/VERSION-2.x\n\n\nComment by cowtowncoder:\nGit merge bothced wrt renaming, fixed.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Please update the release notes for 2.9.2, 2.9.3, and 2.9.4 in https://github.com/FasterXML/jackson-core/blob/master/release-notes/VERSION-2.x",
                "name": "issue#443",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1149"
                    },
                    {
                        "start_node": "issue#1149",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#443"
                    }
                ],
                "similarity": 0.3465227131217664,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1019",
                "type": "issue",
                "content": "if this approach is acceptable, I can extend this PR with some tests\n\n\nComment by cowtowncoder:\nAs per my other note, I don't want to make API changes in 2.15. Will release 2.15.1 soon; this PR may be left as fallback in case there really is enough push back to require addition (i.e. I can still consider change, 2.15.2 or 2.15.1 makes little difference semantically).\n\nComment by darrenoc3:\n@cowtowncoder I am just one person, but consider this my pushback: it's extremely inconvenient for legacy projects that are already handling strings* >5MB or greater in production to have no mechanism to configure the default globally. You can see another example in Github where Palantir have had to jump through hoops and use Reflection to override the default in their codebase. \n\nOriginally I wrote \"documents\" but I meant \"strings\". It just so happens that in our largest documents, string size is equivalent  to document size \n\nComment by cowtowncoder:\n@darrenoc3 Documents can be as big as necessary, 5 MB is for String values, not documents (currently no limit although we'll likely introduce mechanism for enabling one).\r\nI am also bit surprised about P as a company since I thought we had feedback from them during pre-release phase suggesting 5 meg limit was actually fine for them in particular (I may have mistaken company with another one tho).\r\n\r\nBut fwtw as per #1014 limit will be bit higher (20 MB)  in 2.15.1, to be released today.\r\n\r\n\n\nComment by pjfanning:\n@cowtowncoder I think this is the Palantir change - https://github.com/palantir/conjure-java-runtime/pull/2601 - they are using the 2.15.0 API but setting a 50Mb per string limit, just using Reflection because they want to support jackson 2.14 too.\r\n\r\nThey seem to have control over the ObjectMappers that get created. Many users do not - they get them created via 3rd party libs - and there is no rush by 3rd party lib maintainers to allow users to configure the ObjectMappers that the 3rd party libs create.\n\nComment by cowtowncoder:\nI am coming around to thinking this would make sense for 2.15.2. I'll think about it bit more but will probably merge it.\n\nComment by cowtowncoder:\n@pjfanning Is this ready to be merged? Only asking as it's still in Draft stage.\n\nComment by pjfanning:\n@cowtowncoder this is ready to merge",
                "source_code": null,
                "distance": 1.0,
                "title": "Allow override of `StreamReadContraints` default with `overrideDefaultStreamReadConstraints()`",
                "name": "pr#1019",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#1019"
                    }
                ],
                "similarity": 0.33810442952813086,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "891",
                "type": "issue",
                "content": "Fixes #890.\n\n\nComment by cowtowncoder:\nThank you @DemonicTutor! Happy to merge this ASAP.\r\n\r\nJust one clerical thing: have I yet asked for a CLA?  If not, it's here\r\n\r\nhttps://github.com/FasterXML/jackson/blob/master/contributor-agreement.pdf\r\n\r\n(and alternatively Corporate CLA if preferred)\r\n\r\nand the usual mechanism is to print it, fill & sign, scan/photo, email to `info` at fasterxml dot com.\r\nOnly needs to be done once for all future contributions.\r\n(also if you have sent one earlier let me know; I didn't see one but might have missed it).\r\n\r\nLooking forward to merging this!\r\n\r\n\n\nComment by cowtowncoder:\nOh also, not sure if it's easy to rebase but this could be merged into `2.14` branch. Or I can try to cherry-pick after merge to 2.15.\n\nComment by DemonicTutor:\n@cowtowncoder hey! i sent you the requested document from my company mail account.\r\n\r\nyeah if you are happy with this one as-is i can also open a Pull-Request against 2.14?\n\nComment by cowtowncoder:\nThanks, I can see that now. And yes, the other request is fine; could have rebased this one but separate PR is ok too.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "filter generator: create child object context when writing start object. fixes #890",
                "name": "pr#891",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#891"
                    }
                ],
                "similarity": 0.33777787119304065,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1046",
                "type": "issue",
                "content": "(note: part of #637) \r\n\r\nJackson 2.15 included a few processing limits that can be applied to limit processing for \"too big content\"; first focusing on general nesting depth and max. length of individual tokens.\r\nWhile this is good first step, it also makes sense to offer a simple way to limit maximum content in total allowed to be read -- typically a maximum document size, but in case of line-delimited input, maximum streaming content.\r\n\r\nThe reasoning for addition of such feature is that although users can -- if they must -- implement this at yet lower level (length-limited `InputStream`, for example), there are some benefits from Jackson streaming component offering this:\r\n\r\n1. Less work for user (obviously), better accessibility leading to wider adoption and helping against possible DoS vectors\r\n2. Better integration via well-defined exception type common to constraints violations (`StreamConstraintsException`)\r\n3. More reliable limits when shared implementation used (i.e. less like users/devs implement faulty limits checks)\r\n\r\nNote, too, that this feature significantly improves usefulness (or right now, lack thereof) of #863 to combine per-token limits with overall limits.\r\n\r\nNOTE: the default setting for this limits should, however, be left as \"unlimited\": using anything else is likely to break some processing somewhere.\r\nLimit has to be defined as 64-bit `long` (not `int`); default value to use then is likely `Long.MAX_VALUE`.\r\n\r\n\r\n\n\n\nComment by pjfanning:\nI guess built-in support would be good - but this limit is straightforward for users to apply themselves without waiting for a jackson solution.\r\n\r\nIf your input data is the form of\r\n* InputStream - try [SizeLimitInputStream](https://github.com/pjfanning/json-size-limiter/blob/main/src/main/java/com/github/pjfanning/json/util/SizeLimitInputStream.java) or equivalent\r\n* Reader - try [SizeLimitReader](https://github.com/pjfanning/json-size-limiter/blob/main/src/main/java/com/github/pjfanning/json/util/SizeLimitReader.java) or equivalent\r\n* String - just check `length()` of String\r\n* ByteBuffer - jackson-databind has [ByteBufferBackedInputStream](https://www.javadoc.io/static/com.fasterxml.jackson.core/jackson-databind/2.15.2/com/fasterxml/jackson/databind/util/ByteBufferBackedInputStream.html) - you can write the ByteBuffer with this and then wrap the InputStream with the SizeLimitInputStream above\r\n  * it may also be feasible to check the ByteBuffer capacity before reading from it\n\nComment by cowtowncoder:\nStill hoping to get this in 2.16 as it would be the last processing limit formally requested. But we'll see :)\r\n\n\nComment by cowtowncoder:\nImplemented for JSON backend (`InputStream`, `Reader`, non-blocking/async).\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Add configurable limit for the maximum number of bytes/chars of content to parse before failing",
                "name": "issue#1046",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1046"
                    }
                ],
                "similarity": 0.314715415231435,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1197",
                "type": "issue",
                "content": "resolves #507 \n\n\nComment by JooHyukKim:\nI figured we should do https://github.com/FasterXML/jackson-core/pull/1198 separately.\n\nComment by cowtowncoder:\nOk, I changed things I wanted to change.\r\n\r\nLooking at how escape-table is created, I don't think it is easy to try to make it happen by `JsonFactory` so let's forget about that wrt 2.x.\r\n\r\nBut it might still make sense to add an overload for `CharTypes.get7BitOutputEscapes()` (one that takes second argument, if forward slash is to be escaped), and be able to use eagerly constructed table unless (except if non-standard quote char is specified).\n\nComment by cowtowncoder:\n@JooHyukKim Ok, I rewrote this a bit and I think it might be ready for merging. Thank you for providing the base & let me know if you think some changes are needed. Otherwise (or after changing) if you can convert it from draft to regular PR I can go ahead and merge it.\r\n\r\nThank you again!\n\nComment by JooHyukKim:\n@cowtowncoder seems good now \ud83d\udc4d\ud83c\udffc\r\nI just did a small minor test code deduplication via https://github.com/FasterXML/jackson-core/pull/1197/commits/b348b5aee1ed97d63716118f656f8df83f8d2fc9.\n\nComment by cowtowncoder:\nThank you @JooHyukKim. I'll go ahead and merge this then.\n\nComment by cowtowncoder:\nFollow-up wrt 3.0: #1200 ",
                "source_code": null,
                "distance": 1.0,
                "title": "Add new `JsonWriteFeature.ESCAPE_FORWARD_SLASHES`",
                "name": "pr#1197",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#507"
                    },
                    {
                        "start_node": "issue#507",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#1197"
                    }
                ],
                "similarity": 0.30146422328386313,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "864",
                "type": "issue",
                "content": "Relates to #863\r\n\r\n* Open for discussion\r\n* The TextBuffer append methods have been updated to police the string length. This will lead to more timely exceptions than waiting until contentsAsString method is called.\r\n* A new class ReadConstrainedTextBuffer has been created. The legacy TextBuffer can still be used in cases where you don't want to apply the read constraints.\r\n* Needs tests\r\n* Needs uptake in jackson-databind and jackson-dataformat* libs\n\n\nComment by pjfanning:\n@cowtowncoder I think it would be tidier to add a constructor to TextBuffer where a streamReadConstraints can be supplied. Then all the methods that take a streamReadConstraints will be changed not to take this any more. We could end up with virtually every method on TextBuffer taking streamReadConstraints as input otherwise.\r\n\r\nFor 'write' use cases like SegmentedStringWriter, we would support creating TextBuffer with no streamReadConstraints and no limits would be applied by TextBuffer.\n\nComment by cowtowncoder:\n> @cowtowncoder I think it would be tidier to add a constructor to TextBuffer where a streamReadConstraints can be supplied. Then all the methods that take a streamReadConstraints will be changed not to take this any more. We could end up with virtually every method on TextBuffer taking streamReadConstraints as input otherwise.\r\n> \r\n> For 'write' use cases like SegmentedStringWriter, we would support creating TextBuffer with no streamReadConstraints and no limits would be applied by TextBuffer.\r\n\r\nI really do not like the idea of `TextBuffer` being tied to `StreamReadConstraints` tho...\r\n\n\nComment by cowtowncoder:\nOk so yeah, thank you for starting with this! I think the place to check for exceeding limit(s) is when caller asks for new segment to use (usually as side effect of \"finishing\" current segment).\r\n\r\nBut the question of whether to construct `TextBuffer` with constraints, or always pass is... I can see why this is challenging.\r\n\r\nIt may be necessary to see what to do with `SegmentedStringWriter` which (as you noticed) should not be affected by limits.\r\n\r\n\n\nComment by pjfanning:\n@cowtowncoder I had a look at the jackson-dataformat-csv code. It has its own TextBuffer class. I was trying to debug it because it has no 'append' methods. The appending is done by leaking the internal segment state into CsvDecoder. I haven't investigated if there is equivalent code in jackson-core code but if there is then checking in the append methods is not enough. I suspect that I don't know enough about how the TextBuffer is used.\n\nComment by cowtowncoder:\n@pjfanning I don't remember details of `CsvTextBuffer` but I am sure we can figure that out if we can handle standard `TextBuffer`. I'll see if I can find bit more to remind myself why there is the discrepancy; I thought it had to do with buffer recycling (probably not a great reason to have custom one).\n\nComment by pjfanning:\n@cowtowncoder I did some testing today with the latest code here. The tests are in jackson-databind and test very large strings. I found that I had to check for the length in a lot of places - because of the different paths that you can hit going through the TextBuffer code.\r\n\r\nOf all the checks, the append ones seem like they are not useful. The checks in contentsAsString seem to be needed for the edge case where the segmentLen + currentLen is just a little over the limit.\n\nComment by cowtowncoder:\n> @cowtowncoder I did some testing today with the latest code here. The tests are in jackson-databind and test very large strings. I found that I had to check for the length in a lot of places - because of the different paths that you can hit going through the TextBuffer code.\r\n> \r\n> Of all the checks, the append ones seem like they are not useful. The checks in contentsAsString seem to be needed for the edge case where the segmentLen + currentLen is just a little over the limit.\r\n\r\nAs I've mentioned `contentsAsString()` is not something I want to use. But I can accept that various `append()`s are probably not worth worrying about.\r\n\n\nComment by pjfanning:\nThe new contentsAsString() checks could be removed - the impact is that strings that are a bit bigger than the supposed max can get through. It may be possible to track down somewhere else that this can be remedied.\r\n\r\nThe impact of the PR change in contentsAsString is a small extra if check (is the len greater than the limit). Is this something to worry about?\n\nComment by cowtowncoder:\nI am not sure I am supportive of this approach: I will actually propose a bit different way to go about for numeric checks too, trying to instead reduce work `TextBuffer` is to do, not increase it.\r\n\r\nLooking at `ParserBase.resetInt()` and `.resetFloat()` I think I'd favor making checks from those points (for the most part) and reducing validation done at `TextBuffer` where possible.\r\nI will also see if methods like `TextBuffer.contentsAsDecimal()` are actually needed at all.\r\n\r\n\n\nComment by pjfanning:\n@cowtowncoder is this PR/issue worth pursuing for v2.15.0?\n\nComment by cowtowncoder:\n@pjfanning I haven't had time to think more about this, but I would like to keep this open still; maybe this is the way to go. I think my main concern has always been that it'd be better to tackle length constraints before final aggregation -- probably in spot where next buffer is being requested (there are couple of methods).\r\nDo you think that'd be possible? We could also there limit new buffer size to maximum allowed wrt limits, and so check would only be failing when requesting the next buffer, last being full.\r\n(LMK if my explanation doesn't make sense, I can try to elaborate)\r\n\r\nI think split into length-constrained and regular one makes actually sense; the only (?) concern is whether `TextBuffer` recycling could be problematic. I don't think so -- `BufferRecycler` only handles underlying `char[]`, not `TextBuffer`?\r\n\n\nComment by pjfanning:\n@cowtowncoder I'm not sure if your biggest objection to having the checks in TextBuffer or specifically, in TextBuffer.contentsAsString.\r\n\r\nIn the latest iteration of this PR, I have removed the check in TextBuffer.contentsAsString. This leads to a failure in https://github.com/FasterXML/jackson-databind/pull/3704 (a PR in jackson-databind that relies on this PR - using `./mvnw install` on the branch used for this PR and testing jackson-databind with some extra tests in that 3704 PR). The reason is that testing at the buffer expansion point means that we will miss issues where the total size is a little bigger than the limit. Testing in contentsAsString means, we get the benefit of early failures at the buffer expansion point but that we apply the limit exactly in contentsAsString. The test in PR 3704 that fails is `TestBigStrings.testBigString` where the string is 1,001,000 chars when the limit is 1,000,000 chars - the test fails because we do not fail with the slightly too large string.\r\n\r\nI'm happy enough if we decide that the max limit is an approx limit that errs a little (proportionally) on the side of allowing strings that are sized a little over the limit size.\n\nComment by cowtowncoder:\n@pjfanning First of all, apologies once again for being very slow to follow up here.\r\n\r\nHaving said that, to me approximate check is perfectly reasonable, so limit is sort of minimum -- will not fail at below that level. And also that relative accuracy matters more for bigger Strings; there's no need to worry about super low limits (IMO) like keeping things to 1k or something. Those should, I think, be handled by something else. At this level we worry about service protection kinds of things.\r\n\r\nMy only concern about relying on `contentAsString()` is if it's the only thing and we could, f.ex, read 400k even if limit was 10k or so. I do not mind having check also there if that makes sense.\r\n\r\nI hope to get back to checking this out soon, sometime this week.\r\n\r\nAnd will try to keep thinking about the other dimension: that of nesting.  It's even more performance sensitive as the best place to add limits would be within StreamReadContext / StreamWriteContext. But changes to that interface get... tricky.\r\n\n\nComment by cowtowncoder:\nOk this is looking pretty good and I think I am starting to feel better about having length-limited `TextBuffer` sub-class.\r\nSo I think this might be the way to go!\r\n\r\nCouple of questions, thoughts:\r\n\r\n1. CSV module has `CsvTextBuffer`; wonder if we could somehow make CSV module use standard one(s) instead -- I don't quite remember why I did the \"fork\" here :-/\r\n2. Although 1M characters sounds reasonable, I have a nagging feeling someone somewhere might still use slightly bigger sizes. So I wonder if there'd be any alternative bigger limit that makes sense. I think 10 megs is quite common for maximum uploadable file/doc size, fwtw.\r\n\r\n\r\n\r\n\r\n\n\nComment by pjfanning:\nI would ignore CSV for the moment. jackson-databind and other dataformat modules would need to be updated to add tests. We could circle back around to CSV module later. As part of adding a test, we can see if it is easier to recreate the new feature in CsvTextBuffer or to change CSV module to use TextBuffer. I did try the latter before and it didn't look straightforward. At this stage, CsvTextBuffer is something of its own beast.\r\n\r\nI can look at changing the 1m default to a 10m default.\n\nComment by cowtowncoder:\n> I can look at changing the 1m default to a 10m default.\r\n\r\nJust realized that I didn't mean to suggest 10 meg as default necessarily as much as sort of data point: if the max document is 10 megs, then perhaps max value length of 1 meg is reasonable.\r\n\r\n\r\n\r\n\n\nComment by cowtowncoder:\n@pjfanning  Ok, I am almost ready to merge.\r\n\r\nAnd now I think that I actually agree with you on also checking length on `contentsAsString()`: we may get check fail earlier on buffer alloc, but if not, this is where we get the exact check that users expect\r\n\r\nDoing this would make tests pass I think, since buffer size wouldn't matter on eventual check accuracy; we would temporarily handle longer content but catch that when String actually accessed.\r\n\n\nComment by pjfanning:\n> @pjfanning Ok, I am almost ready to merge.\r\n> \r\n> And now I think that I actually agree with you on also checking length on `contentsAsString()`: we may get check fail earlier on buffer alloc, but if not, this is where we get the exact check that users expect\r\n> \r\n> Doing this would make tests pass I think, since buffer size wouldn't matter on eventual check accuracy; we would temporarily handle longer content but catch that when String actually accessed.\r\n\r\nI added back some checks to contentsAsString and contentsAsArray. I think the checks are strategically placed so that we don't validate too often but it would be worth going through them again to make sure that none are superfluous.\n\nComment by pjfanning:\nIn my testing, resetWithString check was needed - it shouldn't add much overhead.\r\n\r\nI've marked this a ready for review. \n\nComment by cowtowncoder:\nOk phew! It finally went in. Thank you again @pjfanning !\r\n\r\nAlso, I decided I should add you as co-author for `jackson-core` due to massive number of contributions; modified `release-notes/CREDITS-2.x` to state that.",
                "source_code": null,
                "distance": 0.75,
                "title": "StreamReadConstraints: add maxStringLen",
                "name": "pr#864",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#864"
                    }
                ],
                "similarity": 0.2842087722716096,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "507",
                "type": "issue",
                "content": "Jackson 2.x only escapes minimum set of characters, as defined by JSON specification. This does not include forward slash character ('/'). But while legal, it turns out that more often than not users do want escaping, to guard against potential inclusion-in-HTML problems, particularly for embedded JSON constants in Javascript sources, in script tags.\r\n\r\nNow: although it is possible to enable escaping already (via `CharacterEscapes`), it is bit verbose, and also adds some measurable (not huge, but not completely trivial) overhead.\r\nSo for 3.0 let's add this character as escape-by-default, but also add a simple mechanism for turning that off if feasible (`JsonWriteFeature`, most likely?).\r\n\r\n\r\n\n\n\nComment by MrBuddyCasino:\nI just encountered this difference in a project migrating PHP code to Kotlin. I'm not sure it should be enabled by default, as it makes URLs in Json objects hard to read, but it should be a feature that can easily be enabled. As you have stated, the main reason is to prevent the injection of closing script tags.\r\n\r\nHere is an implementation of `CharacterEscapes` for Java & Kotlin: https://stackoverflow.com/questions/6817520/escape-forward-slash-in-jackson/73770950#73770950\n\nComment by cowtowncoder:\nRight, the setting probably should be disabled by default for Jackson 2.x for backwards-compatibility.\r\nBut possibly enabled for 3.0 (master).\r\n\r\nBut first, it'd need to be implemented; something that is surprisingly bit more complicated than I thought (at least to do it efficiently, and across generator implementations).\r\n\n\nComment by cowtowncoder:\ncc @JooHyukKim This is something that would be nice to implement -- basically `JsonWriteFeature` to force escaping of `/`, without requiring full `CharacterEscapes` but also not changing current default behavior.\r\n\n\nComment by JooHyukKim:\nWDYT of usage like below? @MrBuddyCasino @cowtowncoder \r\n\r\n```java\r\n    @Test\r\n    public void testEscapeForwardSlash() throws Exception\r\n    {\r\n        // Given\r\n        Writer jsonWriter = new StringWriter();\r\n        JsonGenerator generator = JsonFactory.builder()\r\n                .enable(JsonWriteFeature.ESCAPE_FORWARD_SLASHES)\r\n                .build()\r\n                .createGenerator(jsonWriter);\r\n\r\n        // When\r\n        generator.writeStartObject(); // start object\r\n        generator.writeStringField(\"url\", \"http://example.com\");\r\n        generator.writeEndObject(); // end object\r\n        generator.close();\r\n\r\n        // Then\r\n        assertEquals(\"{\\\"url\\\":\\\"http:\\\\/\\\\/example.com\\\"}\", jsonWriter.toString());\r\n    }\r\n```\n\nComment by labkey-matthewb:\n\r\nI understand the concern about backward compatibility w/o a major version change.  However, the proposal to configure every new instance of ObjectMapper to get the desired behavior is challenging in practice.  Because new ObjectMapper() is public it is hard to enforce consistent configuration.\r\n\r\nI would propose a way to register a static method to register a Factory for the relevant configuration class.  I'm not sure if this should be a Factory of JsonFactory or a lower level configuration class (CharacterEscapes?).  This would be a backward compatible mechanism and generally useful beyond the specific issue of escaping the '/' character.\r\n\r\ne.g. \r\n\r\nJasonFactory registerDefaultJsonFactory(Factory<JsonFactory> f)\r\n\n\nComment by cowtowncoder:\nI am generally against any static, JVM-wide configuration, due to Jackson's usage as an embedded library. This means that trying to force changes for your app/framework/library's needs can easily break other usage.\r\n\r\nBut there is precedence for doing something like this with `StreamReadConstraints` / `StreamWriteConstraints`, wherein ultimate defaults can be changed but can then still be overridden by explicit settings.\r\nThis could be considered in this case.\r\n\r\nAlthough TBH, I am not sure I see this as necessarily warranting such change: use case of producing JSON serializations for embedding in HTML is an existing but dominating use case.\r\n\r\nEither way, the first step would be to implement `JsonWriteFeature`, after which possible defaulting could be considered (including implementation technique, something along lines suggested).\r\n\r\n\n\nComment by cowtowncoder:\n@JooHyukKim yes, exactly, that'd be way to do it. Question is that of how to change encoding tables to add minimal/no overhead.\n\nComment by cowtowncoder:\nLooking at `JsonGeneratorImpl` subtypes -- `WriterBasedJsonGenerator` and `UTF8JsonGenerator` -- the way to go is to figure out how to use alternate output encoding table `_outputEscapes`. Care needs to be taken as these are shared arrays, but the thing to do is just to make sure index for `/` (0x2F) forces ecaping; and that's it really.\r\n\r\nThis would be quite simple if it wasn't for existing setting of custom quote character, for which encoding table is changed.\r\n\n\nComment by JooHyukKim:\nWrote #1197 draft. Seems oddly straight-forward. Could you PTAL at what I am missing \ud83e\udd14, @cowtowncoder ?\n\nComment by labkey-matthewb:\nThis is great, and cleans up my code quite a bit.  So thank you.  Is this request considered closed for 3.0?  Or is the option of changing the default to include '/' still on the table?\n\nComment by JooHyukKim:\n> So for 3.0 let's add this character as escape-by-default, but also add a simple mechanism for turning that off if feasible (JsonWriteFeature, most likely?).\r\n\r\nSeems like original plan was to enable by default (currently disabled in 2.x) @labkey-matthewb.\n\nComment by cowtowncoder:\nI'll create follow-up ticket to change the default for 3.0, and yes agree with @JooHyukKim .",
                "source_code": null,
                "distance": 0.5,
                "title": "Add `JsonWriteFeature.ESCAPE_FORWARD_SLASHES` to allow escaping of '/' for String values",
                "name": "issue#507",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#507"
                    }
                ],
                "similarity": 0.2770467395689882,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "827",
                "type": "issue",
                "content": "* Introduces a default max length for numbers of 1000 chars - this default can be overridden (eg set to a much higher limit)\r\n* we shouldn't allow super large numbers as a default (I can justify this in private exchanges but don't want to spell it out in a public forum)\r\n* checks the string/char[] length before parsing the text as a number\r\n* this is a bit late but better than not checking at all - because parsing numbers is expensive and slower than O(n)\r\n* the problem with doing an earlier check (while building the char[] is that is not always clear how the TextBuffer is going to be used. Is it being used to get text or is it being used to buffer up the chars needed to parse a number\r\n  * if someone can point out how we can know in advance if the TextBuffer is destined to used for number parsing, then the num size limit can be checked earlier \r\n\r\nTo create a JSONFactory that allows larger numbers, you can use this code\r\n```\r\n        JsonFactory f = JsonFactory.builder()\r\n                .streamReadConstraints(StreamReadConstraints.builder().withMaxNumberLength(10000).build())\r\n                .build();\r\n```\r\n\r\n**EDIT**: fixes [sonatype-2022-6438](https://ossindex.sonatype.org/vulnerability/sonatype-2022-6438)\r\n\r\n\n\n\nComment by pjfanning:\n@cowtowncoder would you be able to re-review this when you get a chance?\n\nComment by cowtowncoder:\nYes @pjfanning I will try to get back to this as soon as possible.\r\n\n\nComment by pjfanning:\n@cowtowncoder I think I've addressed most of your issues with some recent commits. I've updated the PR description with how the code is called. The class is now StreamReadConstraints and has a builder().\n\nComment by cowtowncoder:\nOk couple of follow-up question on limits:\r\n\r\n1. Is it reasonable to have same length limit for integral and floating-point numbers? Latter are (afaik) much more expensive to handle -- and former might have more legit use cases (for encryption keys, I think?). Or should those be split into 2 settings\r\n2. Is `1000` bit low as a limit? I don't know if there are use case past that, or perhaps limits other parsers use. I know it's to some degree arbitrary, but since we are adding a new constraint it'd be nice to reduce chance of breaking existing use cases\r\n\r\n\n\nComment by pjfanning:\n> Ok couple of follow-up question on limits:\r\n> \r\n> 1. Is it reasonable to have same length limit for integral and floating-point numbers? Latter are (afaik) much more expensive to handle -- and former might have more legit use cases (for encryption keys, I think?). Or should those be split into 2 settings\r\n> 2. Is `1000` bit low as a limit? I don't know if there are use case past that, or perhaps limits other parsers use. I know it's to some degree arbitrary, but since we are adding a new constraint it'd be nice to reduce chance of breaking existing use cases\r\n\r\n1. I think you'd want to want to have some very specialised requirement to want to set a different limit for integers and for BigDecimals. For normal users, it's simpler to have 1 setting. For edge case users, they would have to set the single limit to be the higher of the limits that they have in their heads.\r\n2. 1000 is a very long number under almost any user's definition. From my testing, parsing performance of both integers and BigDecimals tails off dramatically after about 1000 digits - exponential loss in performance. \n\nComment by cowtowncoder:\n> > Ok couple of follow-up question on limits:\r\n> > \r\n> > 1. Is it reasonable to have same length limit for integral and floating-point numbers? Latter are (afaik) much more expensive to handle -- and former might have more legit use cases (for encryption keys, I think?). Or should those be split into 2 settings\r\n> > 2. Is `1000` bit low as a limit? I don't know if there are use case past that, or perhaps limits other parsers use. I know it's to some degree arbitrary, but since we are adding a new constraint it'd be nice to reduce chance of breaking existing use cases\r\n> \r\n>     1. I think you'd want to want to have some very specialised requirement to want to set a different limit for integers and for BigDecimals. For normal users, it's simpler to have 1 setting. For edge case users, they would have to set the single limit to be the higher of the limits that they have in their heads.\r\n> \r\n>     2. 1000 is a very long number under almost any user's definition. From my testing, parsing performance of both integers and BigDecimals tails off dramatically after about 1000 digits - exponential loss in performance.\r\n\r\nOk. Besides, I hope we get some feedback during 2.15 RC phase (I'm incurable optimist).\r\nBut maybe I should do some googling to see how others set these limits.\r\n\n\nComment by cowtowncoder:\n@pjfanning Ok one more practical thing. Due to 2.x/3.0 differences, I think it'd be easier to try to merge this in pieces; first adding scaffolding for `StreamReadConstraints` (class itself, passing to `TokenStreamFactory`/`JsonFactory`); merge that 2.15 -> 3.0. And then go back add actual handling. Unfortunately this is kind of change where merging gets bit painful.\r\n\r\nI wonder what's the best way to do do that: should I copy parts from this PR and take a first crack; or would you like to do smaller PR based on this, and keep this as the second stage?\r\nI can try to do 2.x -> 3.0 merge for either case.\r\n\n\nComment by pjfanning:\nI created #845\n\nComment by cowtowncoder:\nI'll merge this: I have an idea of how to remove need to add parameter for constructing `TextBuffer`, instead taking it to calls to `contentsAsXxx()`\n\nComment by phatblat:\nWill this fix be backported to any minor versions before `2.15`?\n\nComment by cowtowncoder:\n> Will this fix be backported to any minor versions before `2.15`?\r\n\r\nNo, this cannot be backported in any earlier versions due to API changes and general complexity of changes.\r\n\n\nComment by kingsfleet:\n+1 for a backport, 2.15 is not until March\n\nComment by JoshDM:\n> +1 for a backport, 2.15 is not until March\r\n\r\n+1 for an early release of 2.15.\n\nComment by crahen:\nSurely there is a functional patch we can make to existing already released versions of Jackson to limit large numbers. Even if we connect whatever override for length to an environment variable or system property. You can't expect folks to rush out a major version upgrade to protect themselves, very risky.\r\n\r\nAre the maintainers doing this? When can we expect the patch?\n\nComment by pjfanning:\nYou're welcome to fork jackson and apply whatever fix you see fit.\n\nComment by cowtowncoder:\n@crahen No. Addition of new functionality needs to go in a new minor version. We will not be backporting the changes. So do not expect it at all.\r\n\r\n\n\nComment by sepatel:\n> You can't expect folks to rush out a major version upgrade to protect themselves, very risky.\r\n> \r\n> Are the maintainers doing this? When can we expect the patch?\r\n\r\nThey already answered that it cannot be backported. \r\n\r\n> > Will this fix be backported to any minor versions before `2.15`?\r\n> \r\n> No, this cannot be backported in any earlier versions due to API changes and general complexity of changes.\r\n\r\nSo yes businesses will have to weigh for themselves the risk of leaving the vulnerability in place or upgrading. Personally, we are going to be upgrading as soon as it is released and already prepping for it. Lot less risk of just upgrading to a new minor release instead.\r\n\n\nComment by cowtowncoder:\nJackson 2.15.0 was just released on April 23, 2023 so this is now available for production.\n\nComment by phatblat:\nThanks for the update, @cowtowncoder !\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Add numeric value\tsize limits via\t`StreamReadConstraints` (fixes `sonatype-2022-6438`) -- default 1000 chars",
                "name": "pr#827",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#827"
                    }
                ],
                "similarity": 0.27209890038737683,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1149",
                "type": "issue",
                "content": "Currently `JsonParser` has method `getNumberType()`, with semantics that are loose for many textual formats.\r\nBasically formats like JSON do not have similar types as programming languages: so while we have separate `NumberType` entries representing `float` (32-bit binary FP), `double` (64-bit \"double\"precision binary FP) and `BigDecimal` (unlimited-precision, decimal FP), there is no efficient mechanism to actually produce correct `NumberType` for floating-point values.\r\nBecause of this, basically all FP values claim to be of `NumberType.DOUBLE` for such formats.\r\nThis can be problematic if values are converted first to `double`, then to `BigDecimal`, since former cannot accurately represent all decimal numbers.\r\n\r\nHowever, binary formats often have specific storage representations that can provide this type information.\r\n\r\nThe problem comes when converting to Java types: both `java.lang.Number` (or generally `java.lang.Object`) and `JsonNode`.\r\nIn this case we would ideally use either:\r\n\r\n1. Exact type if known (binary formats) OR\r\n2. Well-known type -- `Double` OR `BigDecimal`, based on configuration\r\n3. In some edge cases (not-a-number aka `NaN`), `Double` as that can represent such values.\r\n\r\n(further complicating things, we also have secondary means of producing `NaN` values: value overflow for `double` (and theoretically, but not practically, `float`) which can produce `+INFINITY`)\r\n\r\nGiven all above confusion, I think we need a new method like `getNumberTypeFP()` -- with matching `enum NumberTypeFP` (to be able to express value `UNKNOWN`, no need for integer types).\r\nThat will allow deserializers to know if \"true number type\", and base logic on that, specifically avoiding conversions in case of Binary formats and allowing their use for Textual formats (or in general formats without explicit type information for FP numbers).\r\n\r\n**EDIT**: originally thought we'd need `getNumberTypeExplicit()`, but since the need is specifically for floating-point numbers, let's call it `getNumberTypeFP()` instead; no need for non-FP types. And can indicate semantics are for strict/explicit type.\r\n\n\n\nComment by cowtowncoder:\n/cc @pjfanning This with #1137 might let us solve the problems: by using combination of `isNan()` (now reliable) and `getNumberTypeExplicit()` (which will not accidentally coerce type to `DOUBLE`) we should avoid most problems.\r\nThere may still be some complications wrt \"Double value overflow\".\r\n\r\n\n\nComment by cowtowncoder:\nInitial part for `JsonParser` itself implemented; as well as support for parser created from `TokenBuffer` (of `jackson-databind`). Next steps: add overrides by binary format parsers; then make \"untyped\" and `JsonNode` deserializers use.\r\n\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Add `JsonParser.getNumberTypeFP()`",
                "name": "issue#1149",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1149"
                    }
                ],
                "similarity": 0.2543481468959201,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "892",
                "type": "issue",
                "content": "\n\n\nComment by cowtowncoder:\nOk, I realized that I don't quite know what is the intended logic here, so would it be possible to add a brief description?\r\nLooks like there isn't much testing for this part (although since this seems to be based off the other PR, I may be missing something; may be easier to see once I merge #891), so I think tests would be useful (it looked like one of tests did exercise new code but most not).\r\n\n\nComment by cowtowncoder:\n@DemonicTutor I could proceed merging this next, if you have a chance to look at my suggestions. Also need to resolve the test conflict (merge from 2.15 I think)\n\nComment by DemonicTutor:\nhey! sorry i only noticed your comments recently and because this is so far outdated i opend a new PR here: https://github.com/FasterXML/jackson-core/pull/1026\r\n\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Feature Request - allow all array elements in JsonPointerBasedFilter",
                "name": "pr#892",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#891"
                    },
                    {
                        "start_node": "pr#891",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#892"
                    }
                ],
                "similarity": 0.254312910320572,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "72",
                "type": "issue",
                "content": "Hi,\non copying a JsonFactory all settings are reset to the defaults. Is this intentional?\n\nsome background:\nIn my application i keep a configured ObjectMapper with a configured JsonFactory inside of a facade to use in all places where it is needed with some convenience methods to use the ObjectMapper.\nTo defend against programming mistakes and in love of immutability i thought of giving out a copy of the ObjectMapper if someone needs it directly. The ObjectMapper copies the JsonFactory and so it looses all changed features.\n\n\n\nComment by cowtowncoder:\nI don't think this is intended, no. Can you give the small code snippet you are using? Also, just to make sure: is this with 2.2.0?\n\nOn immutability: I LOVE immutability, and have tried to change things over time to make things more immutable.\n`JsonFactory` is bit problematic, and probably can't be easily made immutable (due to backwards compatibility, mostly). But you can use `ObjectReader` and `ObjectWriter`, which at least make databinding fully immutable compared to `ObjectMapper`. So using those might make sense, even though it won't solve this particular problem.\n\n\nComment by squiddle:\nI hope this snippet clarifies what i meant with my facade. It is not some magic. At the moment everyone just has to be aware of not modifying the objectMapper.\n\n```\nclass JsonHelper {\n  private final ObjectMapper om;\n  public JsonHelper(ObjectMapper om){this.om = om;}\n\n  //some methods using om\n\n  /** returns the configured objectmapper in case this helper does not help enough */\n  public ObjectMapper getObjectMapper(){\n    return om; // here i would like to return om.copy() to be safe, but loose all enabled/disabled features on copy.\n  }\n}\n```\n\nWhen i look into JsonFactory#copy i think just copying the values of _parserFeatures, _generatorFeatures is a simple solution for my problem. But there are other state fields in the factory i do not grasp if there are safe to copy or safe to just stay on the default value (e.g. caches, do not need to be copied/shared IMO).\n\nObjectReader and Writer still allow access to the JsonFactory. But yes it is a bit harder to do the wrong thing.\n\nYes, this issue is still present in 2.2.0\n\n\nComment by cowtowncoder:\nOk. copy() certainly should return a true copy with same settings, possibly using recursive copy() on some components, but not changing any settings. So this does sound like a bug. Surprising one just because I thought I had fixed all issues surrounding it; there were couple for 2.1.\n\n\nComment by cowtowncoder:\nHoly guacemoley. You are right... I don't know how this was missed -- fixed now for `JsonFactory`, but I will also need to hunt down overridden variants for data format libs (smile, xml, csv ...)\n\n\nComment by squiddle:\nwow, that was fast. one reason more, why this library is such a pleasure to work with.\n\n\nComment by cowtowncoder:\nThank you. It goes both ways -- I tend to get really good bug reports, quickly. So as much as I hate having issues in releases, at least they get squashed quickly. So I appreciate these reports as well.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "copying of JsonFactory resets features to defaults",
                "name": "issue#72",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#72"
                    }
                ],
                "similarity": 0.2445207274915184,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "797",
                "type": "issue",
                "content": "Issue is described in the title.\r\nFailing compilation: https://github.com/cliu123/security/runs/7334731513?check_suite_focus=true\r\nI do see [the class](https://github.com/FasterXML/jackson-core/blob/2.13/src/main/java/com/fasterxml/jackson/core/exc/StreamWriteException.java) existing in 2.13 branch. Did I miss anything? Is the artifact in Maven repo the latest one?\n\n\nComment by cowtowncoder:\nYou have a too old `jackson-core` as dependency. Jackson-databind 2.13 requires jackson-core 2.13 (or newer, once 2.14 is released). That exception is defined in `jackson-core`, likely added in 2.13.\r\n\r\nWhen using Maven and Gradle -- and especially if using `jackson-bom` to help with version set compatibility -- jackson-databind 2.13 would pull in jackson-core 2.13.\r\nBut somehow your build definition is forcing an older version (or possibly there is a duplicate).\r\n\r\nSo you will need to figure out where the old dependency comes from and fix it.\r\n\r\n\r\n\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`class file for com.fasterxml.jackson.core.exc.StreamWriteException not found` when compiling with jackson-databind 2.13.x(Compilation is successful with 2.12.x )",
                "name": "issue#797",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#797"
                    }
                ],
                "similarity": 0.19987882387437894,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1150",
                "type": "issue",
                "content": "First part of fixes related to problems with number Overflow/Underflow for `Double` leading to problems with `BigDecimal` access. Second part of solution will be #1149.\n\n\nComment by cowtowncoder:\n@pjfanning I think that this first part should help a bit: we'll simply keep track of input that is NaN and not consider possible Overflow/Underflow-induced cases actual NaNs (since they would be decodable into `BigDecimal`).\r\nThis allows some changes, but more importantly if this goes cleanly, can implement #1149.\r\n\r\n/cc @JooHyukKim ",
                "source_code": null,
                "distance": 0.75,
                "title": "Fix `JsonParser.isNaN()` to be stable, only indicate explicit NaN values; not ones due to coercion",
                "name": "pr#1150",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1149"
                    },
                    {
                        "start_node": "issue#1149",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#1150"
                    }
                ],
                "similarity": 0.17544328749288207,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1200",
                "type": "issue",
                "content": "(follow-up to #507)\r\n\r\nNow that we have added ability to easily force escaping of `/` let's make that default for Jackson 3.0 stream writers.\r\n\r\n\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Change default for `JsonWriteFeature.ESCAPE_FORWARD_SLASHES` to be `true` for 3.0",
                "name": "issue#1200",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#507"
                    },
                    {
                        "start_node": "issue#507",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1200"
                    }
                ],
                "similarity": 0.17425632790130366,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "890",
                "type": "issue",
                "content": "The usecase is to filter Json while generating it but instead of a single property i wanted to be able to match multiples.\r\n\r\n\r\n\r\n\r\n\r\nsee: https://github.com/FasterXML/jackson-core/blob/2.15/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java#L314-L317\r\n\r\nfor arrays it already happens: https://github.com/FasterXML/jackson-core/blob/2.15/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java#L178-L182\r\n\r\n\r\n\r\nI wrote a simple OR composite:\r\n\r\n```\r\nprivate static final class OrTokenFilter extends TokenFilter {\r\n\u00a0  \u00a0\r\n\u00a0  private final List<? extends TokenFilter> delegates;\r\n\u00a0  \u00a0\r\n\u00a0  private OrTokenFilter(final List<? extends TokenFilter> delegates) {\r\n  \u00a0  this.delegates = delegates;\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  static OrTokenFilter create(final Set<String> jsonPointers) {\r\n\u00a0    return new OrTokenFilter(jsonPointers.stream().map(JsonPointerBasedFilter::new).toList());\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  @Override\r\n\u00a0  public TokenFilter includeElement(final int index) {\r\n\u00a0    return executeDelegates(delegate -> delegate.includeElement(index));\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  @Override\r\n\u00a0  public TokenFilter includeProperty(final String name) {\r\n\u00a0    return executeDelegates(delegate -> delegate.includeProperty(name));\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  @Override\r\n\u00a0  public TokenFilter filterStartArray() {\r\n\u00a0    return this;\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  @Override\r\n\u00a0  public TokenFilter filterStartObject() {\r\n\u00a0    return this;\r\n\u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0  // FIXME\r\n\u00a0  // @Override\r\n\u00a0  // protected boolean _includeScalar() {\r\n\u00a0  //   return delegates.stream().map(delegate -> delegate._includeScalar()).findFirst();\r\n\u00a0  // }\r\n\u00a0  \u00a0\r\n\u00a0  private TokenFilter executeDelegates(final UnaryOperator<TokenFilter> operator) {\r\n  \u00a0  List<TokenFilter> nextDelegates = null;\r\n\u00a0    for (final var delegate : delegates) {\r\n     \u00a0  final var next = operator.apply(delegate);\r\n     \u00a0  if (null == next) {\r\n        \u00a0  continue;\r\n\u00a0       }\r\n        if (TokenFilter.INCLUDE_ALL == next) {\r\n        \u00a0  return TokenFilter.INCLUDE_ALL;\r\n    \u00a0  }\r\n\u00a0  \u00a0\r\n\u00a0      if (null == nextDelegates) {\r\n  \u00a0       nextDelegates = new ArrayList<>(delegates.size());\r\n    \u00a0  }\r\n\u00a0      nextDelegates.add(next);\r\n\u00a0    }\r\n\u00a0    return null == nextDelegates ? null : new OrTokenFilter(nextDelegates);\r\n\u00a0    }\r\n\u00a0  }\r\n```\r\n\r\n`new FilteringGeneratorDelegate(createGenerator(new ByteBufOutputStream(unpooled)), OrTokenFilter.create(jsonPointers), TokenFilter.Inclusion.INCLUDE_ALL_AND_PATH, true)`\r\n\r\n\r\nexample:\r\n```\r\n[\r\n  {\r\n    \"id\": \"1\"\r\n    \"stuff\": [\r\n      {\"name\":\"name1\"},\r\n      {\"name\":\"name2\"}\r\n   ]\r\n  },\r\n {\r\n    \"id\": \"2\",\r\n    \"stuff\": [\r\n      {\"name\":\"name1\"},\r\n      {\"name\":\"name2\"}\r\n   ]\r\n }\r\n]\r\n```\r\n\r\n```\r\nSet.of(\"/id\", \"/stuff/0/name\")\r\n```\r\n\r\nwithout creating the new context the generator will fail at the second object in the stuff array because the _startHandled is set to true from the first object.\n\n\nComment by cowtowncoder:\nYes, I think you are right @DemonicTutor. It definitely looks like this:\r\n\r\n```\r\n  _filterContext = _filterContext.createChildObjectContext(_itemFilter, false);\r\n```\r\n\r\nshould be added before return statement.\r\n\r\nThis could be fixed to be included in 2.14.2, I think, all we need is a PR.\r\nI can do that, but one thing that'd really be useful would be a reproduction, unit test, to show what was not working before (and is working after) the fix.\r\nWould it be possible to create one from code sample above? Real world use cases are often nice to have as tests.\r\n\n\nComment by cowtowncoder:\nQuick note: adding fix as suggested does not break any of existing unit tests, fwtw.\r\nSo seems possibly safe, although granted test cases for filtering are not very extensive.\r\n\r\nAt any rate, would really love reproduction unit test.\r\n\n\nComment by DemonicTutor:\nyeah sure i can do that - will provide a PR for you!\n\nComment by DemonicTutor:\n@cowtowncoder let me know if this is somewhat how you expected it!\n\nComment by DemonicTutor:\nwhile i'm at it.. i also opened a feature-request: https://github.com/FasterXML/jackson-core/pull/892\r\n\r\nlet me know if that makes sense to you - maybe im just off the rails and misusing this one but for what im currently doing its a neat hack ",
                "source_code": null,
                "distance": 1.0,
                "title": "`FilteringGeneratorDelegate` does not create new `filterContext` if `tokenFilter` is null",
                "name": "issue#890",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#891"
                    },
                    {
                        "start_node": "pr#891",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#890"
                    }
                ],
                "similarity": 0.1688240855485826,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1137",
                "type": "issue",
                "content": "Currently it appears that too big (overflow) and too small (underflow) values can produce \"Not a Number\" (NaN) values from `JsonParser`, in addition to optionally supported tokens -- only allowed if enabled -- like `+INF` / `-INF` / `NaN`).\r\n\r\nBut doing this causes problem with `BigDecimal` handling since such \"too big\"/\"too small\" values CAN be represented as `BigDecimal`, whereas \"true\" Not-a-Numbers cannot.\r\n\r\nSo we should improve handling of `JsonParser.isNaN()` method so that it ONLY indicates explicit Not-a-Number cases, and not overflows.\r\n\r\n\r\n\n\n\nComment by pjfanning:\nThere is similar NaN checking in many Jackson modules. If we want to sort this for 2.16, we should delay the release to look at all the modules. I think NaN handling is a rarely needed use case and that it be better to leave this till after 2.16 release.\n\nComment by pjfanning:\nIf we were to tackle this, I would suggest adding isNaNOrInfinite(String) public static method to NumberInput class that does simple String checks instead of trying to parse the input as a number. This could be used in different Jackson modules.\r\n\r\nMost of our parsers keep the data as Strings/char[] and only parse to number representation if needed.\n\nComment by cowtowncoder:\nForgot to tag this as `2.17`, I 100% agree that due to timing we would increase risk by making changes now.\r\n\r\nI don't have a complete idea on how to go about this, due to differences between Double/double/Float/float (with NaN marker values, but limited ranges) vs `BigDecimal` (unlimited range but no NaN values).\r\n\r\nOne existing example of what might be doable are methods `canConvertToXxx` in `JsonNode` (canConvertToInt(), canConvertToLong(), canConvertToExactIntegral()).\r\nSo could potentially add something like\r\n\r\n    JsonParser.isInDoubleRange();\r\n\r\nwhich would be roughly same as `!isNaNOrInfiniteForDouble()`. But also potentially expensive depending on conversion.\r\n\r\nBut then again there is the question of changing observed behavior of `isNaN` even if not changing documented one -- Javadocs do not say that `isNaN` should return `true` in case value is outside range of `Double` and that just occurs as a side-effect of parsing into `double`.\r\n\r\n\n\nComment by cowtowncoder:\nWas implemented a while ago (forgot to add reference from commit). Tested via\r\n\r\nsrc/test/java/com/fasterxml/jackson/core/read/NonStandardNumberParsingTest.java\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Improve detection of \"is a NaN\" to only consider explicit cases, not `double` overflow/underflow",
                "name": "issue#1137",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1149"
                    },
                    {
                        "start_node": "issue#1149",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1137"
                    }
                ],
                "similarity": 0.16098823636291582,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "729",
                "type": "issue",
                "content": "This creates two new method on `TokenFilter` which you can override to\r\ndecide if empty arrays and objects should be included or excluded. An\r\noverride like this, for example, will include all arrays and objects\r\nthat were sent empty but strip any arrays or objects that were\r\n*filtered* to be empty:\r\n```\r\n        @Override\r\n        public boolean includeEmptyArray(boolean contentsFiltered) {\r\n            return !contentsFiltered;\r\n        }\r\n\r\n        @Override\r\n        public boolean includeEmptyObject(boolean contentsFiltered) {\r\n            return !contentsFiltered;\r\n        }\r\n```\r\n\r\nThe default to preserve backwards compatibility is to always *exclude*\r\nempty objects.\r\n\r\nCloses #715\n\n\nComment by nik9000:\n@cowtowncoder sorry it took me so long to get to it. I just cherry-picked this into 2.14 and it went in clean and the tests passed. I opened a new PR because I'm not really sure how to swing the old PR to the new branch.\r\n\r\nIs it right for me to target 2.14 instead of master? Will you forward port if you decide to merge?\n\nComment by cowtowncoder:\nYes, 2.14 is perfect; I do indeed merge forward usually.\r\n\n\nComment by cowtowncoder:\nNote: one of top items for me to get merged, not today probably but very soon. Thank you very much for your patience.\n\nComment by nik9000:\nThanks so much for merging this one! And for cleaning the rough edges I left.",
                "source_code": null,
                "distance": 0.75,
                "title": "Allow TokenFilter to preserve empty",
                "name": "pr#729",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1001"
                    },
                    {
                        "start_node": "issue#1001",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#863"
                    },
                    {
                        "start_node": "issue#863",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#729"
                    }
                ],
                "similarity": 0.1512632923182882,
                "end_line": null,
                "signature": null
            }
        ]
    },
    "artifact_stats": {
        "skipped_due_to_time": 17,
        "valid_related_items": 206
    }
}