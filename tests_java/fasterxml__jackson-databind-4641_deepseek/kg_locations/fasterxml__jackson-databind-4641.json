{
    "related_entities": {
        "methods": [
            {
                "start_line": 986,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findRootValueDeserializer(type);\n        if (deser == null) {\n            return reportBadDefinition(type,\n                    \"Could not find JsonDeserializer for type \"+ClassUtil.getTypeDescription(type));\n        }\n        return (T) deser.deserialize(p, this);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.08769347371331555,
                "end_line": 993,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readValue(JsonParser p, JavaType type): T"
            },
            {
                "start_line": 264,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected ObjectReader(ObjectReader base, TokenFilter filter) {\n        _config = base._config;\n        _context = base._context;\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n        _filter = filter;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "ObjectReader",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    }
                ],
                "similarity": 0.0808059740101119,
                "end_line": 277,
                "signature": "com.fasterxml.jackson.databind.ObjectReader(ObjectReader base, TokenFilter filter)"
            },
            {
                "start_line": 693,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        // Also, try re-linking, if possible...\n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "with",
                "documentation": "/**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonFactory} for constructing underlying Readers.\n     *<p>\n     * NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>\n     * (that is, ones that return <code>false</code> for\n     * {@link JsonFactory#requiresCustomCodec()}) can be used: trying\n     * to use one that requires custom codec will throw exception\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "with"
                    }
                ],
                "similarity": 0.07713572121910522,
                "end_line": 703,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.with(JsonFactory f): ObjectReader"
            },
            {
                "start_line": 262,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DeserializationContext(DeserializationContext src) {\n        _cache = src._cache.emptyCopy();\n        _factory = src._factory;\n\n        _config = src._config;\n        _featureFlags = src._featureFlags;\n        _readCapabilities = src._readCapabilities;\n        _view = src._view;\n        _injectableValues = src._injectableValues;\n        _attributes = null;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "DeserializationContext",
                "documentation": "/**\n     * Copy-constructor for use with <code>copy()</code> by {@link ObjectMapper#copy()}.\n     * Only called on blueprint objects.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    }
                ],
                "similarity": 0.07606909725841886,
                "end_line": 272,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext(DeserializationContext src)"
            },
            {
                "start_line": 2233,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n        // 26-Mar-2016, tatu: Need to allow multiple-matches at least if we have\n        //    have a multiple-value read (that is, \"readValues()\").\n        return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))\n                ? p : new FilteringParserDelegate(p, _filter, Inclusion.ONLY_INCLUDE_ALL, multiValue);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "_considerFilter",
                "documentation": "/**\n     * Consider filter when creating JsonParser.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_considerFilter"
                    }
                ],
                "similarity": 0.07408385962522189,
                "end_line": 2238,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._considerFilter(JsonParser p, boolean multiValue): JsonParser"
            },
            {
                "start_line": 1019,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {\n        JsonDeserializer<Object> deser = findContextualValueDeserializer(type, prop);\n        if (deser == null) {\n            return reportBadDefinition(type, String.format(\n                    \"Could not find JsonDeserializer for type %s (via property %s)\",\n                    ClassUtil.getTypeDescription(type), ClassUtil.nameOf(prop)));\n        }\n        return (T) deser.deserialize(p, this);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "readPropertyValue",
                "documentation": "/**\n     * Same as {@link #readPropertyValue(JsonParser, BeanProperty, Class)} but with\n     * fully resolved {@link JavaType} as target: needs to be used for generic types,\n     * for example.\n     *\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readPropertyValue"
                    }
                ],
                "similarity": 0.07325390628963913,
                "end_line": 1027,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readPropertyValue(JsonParser p, BeanProperty prop, JavaType type): T"
            },
            {
                "start_line": 998,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "_with",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_with"
                    }
                ],
                "similarity": 0.07037367695620342,
                "end_line": 1007,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._with(DeserializationConfig newConfig): ObjectReader"
            },
            {
                "start_line": 2004,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        // [databind#2162]: use specific exception type as we don't know if it's\n        // due to type definition, input, or neither\n        return ValueInstantiationException.from(_parser, msg, constructType(instClass), cause);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "instantiationException",
                "documentation": "/**\n     * Helper method for constructing instantiation exception for specified type,\n     * to indicate problem with physically constructing instance of\n     * specified class (missing constructor, exception from constructor)\n     *<p>\n     * Note that most of the time this method should NOT be called directly; instead,\n     * {@link #handleInstantiationProblem} should be called which will call this method\n     * if necessary.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "instantiationException"
                    }
                ],
                "similarity": 0.06873180481748875,
                "end_line": 2016,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.instantiationException(Class instClass, Throwable cause): JsonMappingException"
            },
            {
                "start_line": 612,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {\n        try {\n            return _cache.hasValueDeserializerFor(this, _factory, type);\n        } catch (DatabindException e) {\n            if (cause != null) {\n                cause.set(e);\n            }\n        } catch (RuntimeException e) {\n            if (cause == null) { // earlier behavior\n                throw e;\n            }\n            cause.set(e);\n        }\n        return false;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "hasValueDeserializerFor",
                "documentation": "/**\n     * Method for checking whether we could find a deserializer\n     * for given type.\n     *\n     * @param type Type to check\n     * @param cause (optional) Reference set to root cause if no deserializer\n     *    could be found due to exception (to find the reason for failure)\n     *\n     * @since 2.3\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasValueDeserializerFor"
                    }
                ],
                "similarity": 0.06863303650556606,
                "end_line": 626,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.hasValueDeserializerFor(JavaType type, AtomicReference cause): boolean"
            },
            {
                "start_line": 1039,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonNode readTree(JsonParser p) throws IOException {\n        JsonToken t = p.currentToken();\n        if (t == null) {\n            t = p.nextToken();\n            if (t == null) {\n                return getNodeFactory().missingNode();\n            }\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return getNodeFactory().nullNode();\n        }\n        return (JsonNode) findRootValueDeserializer(_config.constructType(JsonNode.class))\n                .deserialize(p, this);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "readTree",
                "documentation": "/**\n     * Convenience method for reading the value that passed {@link JsonParser}\n     * points to as a {@link JsonNode}.\n     *\n     * @param p Parser that points to the first token of the value to read\n     *\n     * @return Value read as {@link JsonNode}\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "readTree"
                    }
                ],
                "similarity": 0.06738131922714154,
                "end_line": 1052,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readTree(JsonParser p): JsonNode"
            },
            {
                "start_line": 940,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withFormatDetection",
                "documentation": "/**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified list of\n     * {@link JsonFactory} instances, and default {@link DataFormatReaders} settings\n     * (for customized {@link DataFormatReaders}, you can construct instance yourself).\n     * to construct appropriate {@link JsonParser} for actual parsing.\n     *<p>\n     * Note: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input cannot be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     *<p>\n     * Note: not all {@link JsonFactory} types can be passed: specifically, ones that\n     * require \"custom codec\" (like XML factory) will not work. Instead, use\n     * method that takes {@link ObjectReader} instances instead of factories.\n     *\n     * @param readers Data formats accepted, in decreasing order of priority (that is,\n     *   matches checked in listed order, first match wins)\n     *\n     * @return Newly configured writer instance\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withFormatDetection"
                    }
                ],
                "similarity": 0.06495947472332396,
                "end_line": 942,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.withFormatDetection(ObjectReader readers): ObjectReader"
            },
            {
                "start_line": 2027,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonMappingException instantiationException(Class<?> instClass, String msg0) {\n        // [databind#2162]: use specific exception type as we don't know if it's\n        // due to type definition, input, or neither\n        return ValueInstantiationException.from(_parser,\n                String.format(\"Cannot construct instance of %s: %s\",\n                        ClassUtil.nameOf(instClass), msg0),\n                constructType(instClass));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "instantiationException",
                "documentation": "/**\n     * Helper method for constructing instantiation exception for specified type,\n     * to indicate that instantiation failed due to missing instantiator\n     * (creator; constructor or factory method).\n     *<p>\n     * Note that most of the time this method should NOT be called; instead,\n     * {@link #handleMissingInstantiator} should be called which will call this method\n     * if necessary.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "instantiationException"
                    }
                ],
                "similarity": 0.06403246424528238,
                "end_line": 2034,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.instantiationException(Class instClass, String msg0): JsonMappingException"
            },
            {
                "start_line": 818,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated,",
                "distance": 1.5,
                "title": null,
                "name": "deserializerInstance",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "deserializerInstance"
                    }
                ],
                "similarity": 0.06369869337662011,
                "end_line": 818,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.deserializerInstance(Annotated annotated, Object deserDef): JsonDeserializer"
            },
            {
                "start_line": 978,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, Class<T> type) throws IOException {\n        return readValue(p, getTypeFactory().constructType(type));\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Convenience method that may be used by composite or container deserializers,\n     * for reading one-off values contained (for sequences, it is more efficient\n     * to actually fetch deserializer once for the whole collection).\n     *<p>\n     * NOTE: when deserializing values of properties contained in composite types,\n     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};\n     * this method does not allow use of contextual annotations.\n     *\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.0634002981672166,
                "end_line": 980,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.readValue(JsonParser p, Class type): T"
            },
            {
                "start_line": 512,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withFeatures",
                "documentation": "/**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     *\n     * @param features Features to enable\n     *\n     * @return Reader instance with specified features enabled\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withFeatures"
                    }
                ],
                "similarity": 0.06238239789236872,
                "end_line": 514,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.withFeatures(JsonParser features): ObjectReader"
            },
            {
                "start_line": 1312,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {\n        _assertNotNull(\"p\", p);\n        return (T) forType(valueType).readValue(p);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.06230636613994696,
                "end_line": 1315,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.readValue(JsonParser p, JavaType valueType): T"
            },
            {
                "start_line": 376,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected void _initForMultiRead(DeserializationContext ctxt, JsonParser p)",
                "distance": 1.5,
                "title": null,
                "name": "_initForMultiRead",
                "documentation": "/**\n     * Alternative to {@link #_initForReading} used in cases where reading\n     * of multiple values means that we may or may not want to advance the stream,\n     * but need to do other initialization.\n     *<p>\n     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n     *\n     * @since 2.8\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_initForMultiRead"
                    }
                ],
                "similarity": 0.06204306700145849,
                "end_line": 376,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._initForMultiRead(DeserializationContext ctxt, JsonParser p): void"
            },
            {
                "start_line": 2243,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected final void _verifyNoTrailingTokens(JsonParser p, DeserializationContext ctxt,",
                "distance": 1.5,
                "title": null,
                "name": "_verifyNoTrailingTokens",
                "documentation": "/**\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_verifyNoTrailingTokens"
                    }
                ],
                "similarity": 0.06188987133859011,
                "end_line": 2243,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._verifyNoTrailingTokens(JsonParser p, DeserializationContext ctxt, JavaType bindType): void"
            },
            {
                "start_line": 2060,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DateFormat _getDateFormat() {\n        if (_dateFormat != null) {\n            return _dateFormat;\n        }\n        /* 24-Feb-2012, tatu: At this point, all timezone configuration\n         *    should have occurred, with respect to default dateformat\n         *    and timezone configuration. But we still better clone\n         *    an instance as formatters may be stateful.\n         */\n        DateFormat df = _config.getDateFormat();\n        _dateFormat = df = (DateFormat) df.clone();\n        return df;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "_getDateFormat",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_getDateFormat"
                    }
                ],
                "similarity": 0.06174500963557698,
                "end_line": 2072,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext._getDateFormat(): DateFormat"
            },
            {
                "start_line": 1335,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst,",
                "distance": 1.5,
                "title": null,
                "name": "handleMissingInstantiator",
                "documentation": "/**\n     * Method that deserializers should call if they fail to instantiate value\n     * due to lack of viable instantiator (usually creator, that is, constructor\n     * or static factory method). Method should be called at point where value\n     * has not been decoded, so that handler has a chance to handle decoding\n     * using alternate mechanism, and handle underlying content (possibly by\n     * just skipping it) to keep input state valid\n     *\n     * @param instClass Type that was to be instantiated\n     * @param valueInst (optional) Value instantiator to be used, if any; null if type does not\n     *    use one for instantiation (custom deserialiers don't; standard POJO deserializer does)\n     * @param p Parser that points to the JSON value to decode\n     *\n     * @return Object that should be constructed, if any; has to be of type <code>instClass</code>\n     *\n     * @since 2.9 (2.8 had alternate that did not take <code>ValueInstantiator</code>)\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handleMissingInstantiator"
                    }
                ],
                "similarity": 0.060780934024364346,
                "end_line": 1335,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(Class instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object msgArgs): Object"
            },
            {
                "start_line": 1134,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser,",
                "distance": 1.5,
                "title": null,
                "name": "handleUnknownProperty",
                "documentation": "/**\n     * Method that deserializers should call if they encounter an unrecognized\n     * property (and once that is not explicitly designed as ignorable), to\n     * inform possibly configured {@link DeserializationProblemHandler}s and\n     * let it handle the problem.\n     *\n     * @return True if there was a configured problem handler that was able to handle the\n     *   problem\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handleUnknownProperty"
                    }
                ],
                "similarity": 0.060631953822663634,
                "end_line": 1134,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.handleUnknownProperty(JsonParser p, JsonDeserializer deser, Object instanceOrClass, String propName): boolean"
            },
            {
                "start_line": 637,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader at(final JsonPointer pointer) {\n        _assertNotNull(\"pointer\", pointer);\n        return new ObjectReader(this, new JsonPointerBasedFilter(pointer));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "at",
                "documentation": "/**\n     * Convenience method to bind from {@link JsonPointer}\n      * {@link JsonPointerBasedFilter} is registered and will be used for parsing later.\n     * @since 2.6\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "at"
                    }
                ],
                "similarity": 0.06017206519958546,
                "end_line": 640,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.at(JsonPointer pointer): ObjectReader"
            },
            {
                "start_line": 1300,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException {\n        _assertNotNull(\"p\", p);\n        return (T) forType((JavaType)valueType).readValue(p);\n    }",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.05983560848726989,
                "end_line": 1303,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.readValue(JsonParser p, ResolvedType valueType): T"
            },
            {
                "start_line": 2354,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n        return _context.createInstance(_config, p, _injectableValues);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "createDeserializationContext",
                "documentation": "/**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "createDeserializationContext"
                    }
                ],
                "similarity": 0.05964450940842037,
                "end_line": 2356,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.createDeserializationContext(JsonParser p): DefaultDeserializationContext"
            },
            {
                "start_line": 2070,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public void writeValue(JsonGenerator gen, Object value) throws IOException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }",
                "distance": 1.5,
                "title": null,
                "name": "writeValue",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "writeValue"
                    }
                ],
                "similarity": 0.059623068237710374,
                "end_line": 2072,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.writeValue(JsonGenerator gen, Object value): void"
            },
            {
                "start_line": 346,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected JsonToken _initForReading(DeserializationContext ctxt, JsonParser p)",
                "distance": 1.5,
                "title": null,
                "name": "_initForReading",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_initForReading"
                    }
                ],
                "similarity": 0.0595455343709135,
                "end_line": 346,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._initForReading(DeserializationContext ctxt, JsonParser p): JsonToken"
            },
            {
                "start_line": 865,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings;\n        if (contextType == null) {\n            bindings = EMPTY_BINDINGS;\n        } else {\n            bindings = contextType.getBindings();\n            // 16-Nov-2016, tatu: Unfortunately as per [databind#1456] this can't\n            //   be made to work for some cases used to work (even if accidentally);\n            //   however, we can try a simple heuristic to increase chances of\n            //   compatibility from 2.6 code\n            if (type.getClass() != Class.class) {\n                // Ok: so, ideally we would test super-interfaces if necessary;\n                // but let's assume most if not all cases are for classes.\n                while (bindings.isEmpty()) {\n                    contextType = contextType.getSuperClass();\n                    if (contextType == null) {\n                        break;\n                    }\n                    bindings = contextType.getBindings();\n                }\n            }\n        }\n        return _fromAny(null, type, bindings);\n    }",
                "distance": 2.0,
                "title": null,
                "name": "constructType",
                "documentation": "/**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "constructType"
                    }
                ],
                "similarity": 0.0595167695741926,
                "end_line": 888,
                "signature": "com.fasterxml.jackson.databind.type.TypeFactory.constructType(Type type, JavaType contextType): JavaType"
            },
            {
                "start_line": 500,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "with",
                "documentation": "/**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     *\n     * @param feature Feature to enable\n     *\n     * @return Reader instance with specified feature enabled\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "with"
                    }
                ],
                "similarity": 0.05927353615265282,
                "end_line": 502,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.with(JsonParser feature): ObjectReader"
            },
            {
                "start_line": 844,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser,",
                "distance": 1.5,
                "title": null,
                "name": "handlePrimaryContextualization",
                "documentation": "/**\n     * Method called for primary property deserializers (ones\n     * directly created to deserialize values of a POJO property),\n     * to handle details of resolving\n     * {@link ContextualDeserializer} with given property context.\n     *\n     * @param prop Property for which the given primary deserializer is used; never null.\n     *\n     * @since 2.5\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handlePrimaryContextualization"
                    }
                ],
                "similarity": 0.05922310270649676,
                "end_line": 844,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.handlePrimaryContextualization(JsonDeserializer deser, BeanProperty prop, JavaType type): JsonDeserializer"
            },
            {
                "start_line": 1876,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop,",
                "distance": 1.5,
                "title": null,
                "name": "reportBadPropertyDefinition",
                "documentation": "/**\n     * Helper method called to indicate problem in POJO (serialization) definitions or settings\n     * regarding specific property (of a type), unrelated to actual JSON content to map.\n     * Default behavior is to construct and throw a {@link JsonMappingException}.\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "reportBadPropertyDefinition"
                    }
                ],
                "similarity": 0.058960345741811526,
                "end_line": 1876,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object msgArgs): T"
            },
            {
                "start_line": 959,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withFormatDetection",
                "documentation": "/**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified\n     * {@link DataFormatReaders}.\n     *<p>\n     * NOTE: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input cannot be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     *\n     * @param readers DataFormatReaders to use for detecting underlying format.\n     *\n     * @return Newly configured writer instance\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withFormatDetection"
                    }
                ],
                "similarity": 0.05831496364747224,
                "end_line": 962,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.withFormatDetection(DataFormatReaders readers): ObjectReader"
            },
            {
                "start_line": 1246,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(JsonParser p) throws IOException",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.05821836238620662,
                "end_line": 1246,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.readValue(JsonParser p): T"
            },
            {
                "start_line": 172,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "ObjectReader",
                "documentation": "/**\n     * Constructor used by {@link ObjectMapper} for initial instantiation\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    }
                ],
                "similarity": 0.05791090166124046,
                "end_line": 174,
                "signature": "com.fasterxml.jackson.databind.ObjectReader(ObjectMapper mapper, DeserializationConfig config)"
            },
            {
                "start_line": 676,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private SerializationConfig _withJsonWriteFeatures(FormatFeature... features) {\n        int parserSet = _generatorFeatures;\n        int parserMask = _generatorFeaturesToChange;\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            final int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n\n            if (f instanceof JsonWriteFeature) {\n                JsonGenerator.Feature oldF = ((JsonWriteFeature) f).mappedFeature();\n                if (oldF != null) {\n                    final int pmask = oldF.getMask();\n                    parserSet |= pmask;\n                    parserMask |= pmask;\n                }\n            }\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)\n                && (_generatorFeatures == parserSet) && (_generatorFeaturesToChange == parserMask)\n                ) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    parserSet, parserMask, newSet, newMask);\n    }",
                "distance": 3.0,
                "title": null,
                "name": "_withJsonWriteFeatures",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handleInstantiationProblem"
                    },
                    {
                        "start_node": "handleInstantiationProblem",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "isEnabled"
                    },
                    {
                        "start_node": "isEnabled",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "SerializationConfig"
                    },
                    {
                        "start_node": "SerializationConfig",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_withJsonWriteFeatures"
                    }
                ],
                "similarity": 0.05676599886735682,
                "end_line": 700,
                "signature": "com.fasterxml.jackson.databind.SerializationConfig._withJsonWriteFeatures(FormatFeature features): SerializationConfig"
            },
            {
                "start_line": 407,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public final boolean isEnabled(DeserializationFeature feat) {\n        /* 03-Dec-2010, tatu: minor shortcut; since this is called quite often,\n         *   let's use a local copy of feature settings:\n         */\n        return (_featureFlags & feat.getMask()) != 0;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "isEnabled",
                "documentation": "/**\n     * Convenience method for checking whether specified on/off\n     * feature is enabled\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "isEnabled"
                    }
                ],
                "similarity": 0.0565917507924905,
                "end_line": 412,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.isEnabled(DeserializationFeature feat): boolean"
            },
            {
                "start_line": 1636,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public void handleBadMerge(JsonDeserializer<?> deser) throws JsonMappingException",
                "distance": 1.5,
                "title": null,
                "name": "handleBadMerge",
                "documentation": "/**\n     * Method that deserializer may call if it is called to do an update (\"merge\")\n     * but deserializer operates on a non-mergeable type. Although this should\n     * usually be caught earlier, sometimes it may only be caught during operation\n     * and if so this is the method to call.\n     * Note that if {@link MapperFeature#IGNORE_MERGE_FOR_UNMERGEABLE} is enabled,\n     * this method will simply return null; otherwise {@link InvalidDefinitionException}\n     * will be thrown.\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handleBadMerge"
                    }
                ],
                "similarity": 0.05645019285244517,
                "end_line": 1636,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.handleBadMerge(JsonDeserializer deser): void"
            },
            {
                "start_line": 536,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withoutFeatures",
                "documentation": "/**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     *\n     * @param features Features to disable\n     *\n     * @return Reader instance with specified features disabled\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withoutFeatures"
                    }
                ],
                "similarity": 0.05637728391605102,
                "end_line": 538,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.withoutFeatures(JsonParser features): ObjectReader"
            },
            {
                "start_line": 2222,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException",
                "distance": 1.5,
                "title": null,
                "name": "_bindAndReadValues",
                "documentation": "/**\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_bindAndReadValues"
                    }
                ],
                "similarity": 0.0563597971862099,
                "end_line": 2222,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._bindAndReadValues(JsonParser p): MappingIterator"
            },
            {
                "start_line": 2465,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected final JavaType _jsonNodeType() {\n        JavaType t = _jsonNodeType;\n        if (t == null) {\n            t = getTypeFactory().constructType(JsonNode.class);\n            _jsonNodeType = t;\n        }\n        return t;\n    }",
                "distance": 1.5,
                "title": null,
                "name": "_jsonNodeType",
                "documentation": "/**\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_jsonNodeType"
                    }
                ],
                "similarity": 0.05629102958676824,
                "end_line": 2472,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._jsonNodeType(): JavaType"
            },
            {
                "start_line": 703,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    private SerializationConfig _withoutJsonWriteFeatures(FormatFeature... features) {\n        int parserSet = _generatorFeatures;\n        int parserMask = _generatorFeaturesToChange;\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            final int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n\n            if (f instanceof JsonWriteFeature) {\n                JsonGenerator.Feature oldF = ((JsonWriteFeature) f).mappedFeature();\n                if (oldF != null) {\n                    final int pmask = oldF.getMask();\n                    parserSet &= ~pmask;\n                    parserMask |= pmask;\n                }\n            }\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)\n                && (_generatorFeatures == parserSet) && (_generatorFeaturesToChange == parserMask)\n                ) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    parserSet, parserMask, newSet, newMask);\n    }",
                "distance": 3.0,
                "title": null,
                "name": "_withoutJsonWriteFeatures",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "handleInstantiationProblem"
                    },
                    {
                        "start_node": "handleInstantiationProblem",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "isEnabled"
                    },
                    {
                        "start_node": "isEnabled",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "SerializationConfig"
                    },
                    {
                        "start_node": "SerializationConfig",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_withoutJsonWriteFeatures"
                    }
                ],
                "similarity": 0.05574771098351804,
                "end_line": 727,
                "signature": "com.fasterxml.jackson.databind.SerializationConfig._withoutJsonWriteFeatures(FormatFeature features): SerializationConfig"
            },
            {
                "start_line": 2083,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException",
                "distance": 1.5,
                "title": null,
                "name": "_bind",
                "documentation": "/**\n     * Actual implementation of value reading+binding operation.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_bind"
                    }
                ],
                "similarity": 0.05535385543223682,
                "end_line": 2083,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._bind(JsonParser p, Object valueToUpdate): Object"
            },
            {
                "start_line": 627,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader at(final String pointerExpr) {\n        _assertNotNull(\"pointerExpr\", pointerExpr);\n        return new ObjectReader(this, new JsonPointerBasedFilter(pointerExpr));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "at",
                "documentation": "/**\n     * Convenience method to bind from {@link JsonPointer}.\n     * {@link JsonPointerBasedFilter} is registered and will be used for parsing later.\n     * @since 2.6\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "at"
                    }
                ],
                "similarity": 0.05521926492319527,
                "end_line": 630,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.at(String pointerExpr): ObjectReader"
            },
            {
                "start_line": 1560,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T readValue(String src) throws JsonProcessingException, JsonMappingException",
                "distance": 1.0,
                "title": null,
                "name": "readValue",
                "documentation": "/**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *\n     * @param src String that contains content to read\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    }
                ],
                "similarity": 0.055112092803402235,
                "end_line": 1560,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.readValue(String src): T"
            },
            {
                "start_line": 1861,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T> T reportBadTypeDefinition(BeanDescription bean,",
                "distance": 1.5,
                "title": null,
                "name": "reportBadTypeDefinition",
                "documentation": "/**\n     * Helper method called to indicate problem in POJO (serialization) definitions or settings\n     * regarding specific Java type, unrelated to actual JSON content to map.\n     * Default behavior is to construct and throw a {@link JsonMappingException}.\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "DeserializationContext"
                    },
                    {
                        "start_node": "DeserializationContext",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "reportBadTypeDefinition"
                    }
                ],
                "similarity": 0.05491661243950229,
                "end_line": 1861,
                "signature": "com.fasterxml.jackson.databind.DeserializationContext.reportBadTypeDefinition(BeanDescription bean, String msg, Object msgArgs): T"
            },
            {
                "start_line": 2305,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectMapper setConstructorDetector(ConstructorDetector cd) {\n        _deserializationConfig = _deserializationConfig.with(cd);\n        // since 2.18\n        _serializationConfig = _serializationConfig.with(cd);\n        return this;\n    }",
                "distance": 2.5,
                "title": null,
                "name": "setConstructorDetector",
                "documentation": "/**\n     * Method for specifying {@link ConstructorDetector} to use for\n     * determining some aspects of creator auto-detection (specifically\n     * auto-detection of constructor, and in particular behavior with\n     * single-argument constructors).\n     *\n     * @since 2.12\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "called by method",
                        "type": "RELATED",
                        "end_node": "treeToValue"
                    },
                    {
                        "start_node": "treeToValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectMapper"
                    },
                    {
                        "start_node": "ObjectMapper",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "setConstructorDetector"
                    }
                ],
                "similarity": 0.05487699830456355,
                "end_line": 2310,
                "signature": "com.fasterxml.jackson.databind.ObjectMapper.setConstructorDetector(ConstructorDetector cd): ObjectMapper"
            },
            {
                "start_line": 410,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withFeatures",
                "documentation": "/**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withFeatures"
                    }
                ],
                "similarity": 0.0548283513703951,
                "end_line": 412,
                "signature": "com.fasterxml.jackson.databind.ObjectReader.withFeatures(DeserializationFeature features): ObjectReader"
            },
            {
                "start_line": 333,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt,",
                "distance": 1.5,
                "title": null,
                "name": "_newIterator",
                "documentation": "/**\n     * Factory method used to create {@link MappingIterator} instances;\n     * either default, or custom subtype.\n     *\n     * @since 2.5\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_newIterator"
                    }
                ],
                "similarity": 0.054786877433744795,
                "end_line": 333,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer deser, boolean parserManaged): MappingIterator"
            },
            {
                "start_line": 1002,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        TypeBindings bindings = TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType });\n        MapType result = (MapType) _fromClass(null, mapClass, bindings);\n        // 17-May-2017, tatu: As per [databind#1415], we better verify bound values if (but only if)\n        //    type being resolved was non-generic (i.e.element type was ignored)\n        if (bindings.isEmpty()) {\n            JavaType t = result.findSuperType(Map.class);\n            JavaType realKT = t.getKeyType();\n            if (!realKT.equals(keyType)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Non-generic Map class %s did not resolve to something with key type %s but %s \",\n                        ClassUtil.nameOf(mapClass), keyType, realKT));\n            }\n            JavaType realVT = t.getContentType();\n            if (!realVT.equals(valueType)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Non-generic Map class %s did not resolve to something with value type %s but %s \",\n                        ClassUtil.nameOf(mapClass), valueType, realVT));\n            }\n        }\n        return result;\n    }",
                "distance": 2.5,
                "title": null,
                "name": "constructMapType",
                "documentation": "/**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "constructType"
                    },
                    {
                        "start_node": "constructType",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "TypeFactory"
                    },
                    {
                        "start_node": "TypeFactory",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "constructMapType"
                    }
                ],
                "similarity": 0.05449984878241279,
                "end_line": 1023,
                "signature": "com.fasterxml.jackson.databind.type.TypeFactory.constructMapType(Class mapClass, JavaType keyType, JavaType valueType): MapType"
            },
            {
                "start_line": 172,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n            // 01-Mar-2017, tatu: Alas, not all paths lead to `_coerceNull()`, as `SettableBeanProperty`\n            //    short-circuits `null` handling. Hence need this check as well.\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                ctxt.reportInputMismatch(this,\n                        \"Cannot map `null` into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        ClassUtil.classNameOf(handledType()));\n            }\n            return _nullValue;\n        }",
                "distance": 2.5,
                "title": null,
                "name": "getNullValue",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_bindAndClose"
                    },
                    {
                        "start_node": "_bindAndClose",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "getNullValue"
                    }
                ],
                "similarity": 0.05433064095570052,
                "end_line": 181,
                "signature": "com.fasterxml.jackson.databind.deser.std.NumberDeserializers.PrimitiveOrWrapperDeserializer.getNullValue(DeserializationContext ctxt): T"
            },
            {
                "start_line": 301,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }",
                "distance": 1.5,
                "title": null,
                "name": "_new",
                "documentation": "/**\n     * Overridable factory method called by various \"withXxx()\" methods\n     *\n     * @since 2.5\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "readValue"
                    },
                    {
                        "start_node": "readValue",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "ObjectReader"
                    },
                    {
                        "start_node": "ObjectReader",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_new"
                    }
                ],
                "similarity": 0.05406669384362327,
                "end_line": 303,
                "signature": "com.fasterxml.jackson.databind.ObjectReader._new(ObjectReader base, JsonFactory f): ObjectReader"
            }
        ],
        "classes": [],
        "issues": [
            {
                "content": "### Search before asking\n\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nWhen both a field & constructor parameter has `@JsonAnySetter`, I'm getting `null` value.\r\n\r\nI changed the constructor parameter to be assigned to another field to see if maybe the injecting for field vs constructor parameter are overwriting each other e.g.:\r\n```\r\n@JsonAnySetter\r\nMap<String,Object> stuffFromField;\r\nMap<String,Object> stuffFromConstructor;\r\n\r\n@JsonCreator\r\npublic TheConstructor(@JsonProperty(\"a\") String a, @JsonAnySetter Map<String, Object> leftovers) {\r\n    this.a = a;\r\n    stuffFromConstructor = leftovers;\r\n}\r\n```\r\n...but both `stuffFromField` & `stuffFromConstructor` have `null` value.\n\n### Version Information\n\n2.18.0\n\n### Reproduction\n\n```java\r\nstatic class POJO562WithAnnotationOnBothCtorParamAndField\r\n{\r\n    String a;\r\n    @JsonAnySetter\r\n    Map<String,Object> stuff;\r\n\r\n    @JsonCreator\r\n    public POJO562WithAnnotationOnBothCtorParamAndField(@JsonProperty(\"a\") String a,\r\n                                                        @JsonAnySetter Map<String, Object> leftovers\r\n    ) {\r\n        this.a = a;\r\n        stuff = leftovers;\r\n    }\r\n}\r\n\r\nMap<String, Object> expected = new HashMap<>();\r\nexpected.put(\"b\", Integer.valueOf(42));\r\nexpected.put(\"c\", Integer.valueOf(111));\r\n\r\nPOJO562WithAnnotationOnBothCtorParamAndField pojo = MAPPER.readValue(a2q(\r\n        \"{'a':'value', 'b':42, 'c': 111}\"\r\n        ),\r\n        POJO562WithAnnotationOnBothCtorParamAndField.class);\r\n\r\nassertEquals(\"value\", pojo.a);\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError: \r\n// Expected :{b=42, c=111}\r\n// Actual   :null\r\nassertEquals(expected, pojo.stuff);\r\n```\n\n### Expected behavior\n\n_No response_\n\n### Additional context\n\nWhile this won't normally happen, it is possible with Records:\r\n1. `@JsonAnySetter`'s `@Target` allows for `ElementType.FIELD` & `ElementType.PARAMETER`.\r\n2. Which means when `@JsonAnySetter` is annotated on a Record component, the annotation will be propagated to both field & constructor parameter.\r\n3. Record fields was previously removed by #3737, so Jackson only sees `@JsonAnySetter` on the constructor parameter.\r\n4. But when I tried to revert #3737 via #4627 to fix some bugs, Jackson now sees `@JsonAnySetter` in both field & constructor parameter, hence this issue.\n",
                "distance": 0,
                "title": "`@JsonAnySetter` not working when annotated on both constructor parameter & field",
                "name": "root",
                "path": [],
                "issue_id": "root",
                "similarity": 2.0,
                "type": "issue"
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4634",
                "type": "issue",
                "content": "### Search before asking\n\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nWhen both a field & constructor parameter has `@JsonAnySetter`, I'm getting `null` value.\r\n\r\nI changed the constructor parameter to be assigned to another field to see if maybe the injecting for field vs constructor parameter are overwriting each other e.g.:\r\n```\r\n@JsonAnySetter\r\nMap<String,Object> stuffFromField;\r\nMap<String,Object> stuffFromConstructor;\r\n\r\n@JsonCreator\r\npublic TheConstructor(@JsonProperty(\"a\") String a, @JsonAnySetter Map<String, Object> leftovers) {\r\n    this.a = a;\r\n    stuffFromConstructor = leftovers;\r\n}\r\n```\r\n...but both `stuffFromField` & `stuffFromConstructor` have `null` value.\n\n### Version Information\n\n2.18.0\n\n### Reproduction\n\n```java\r\nstatic class POJO562WithAnnotationOnBothCtorParamAndField\r\n{\r\n    String a;\r\n    @JsonAnySetter\r\n    Map<String,Object> stuff;\r\n\r\n    @JsonCreator\r\n    public POJO562WithAnnotationOnBothCtorParamAndField(@JsonProperty(\"a\") String a,\r\n                                                        @JsonAnySetter Map<String, Object> leftovers\r\n    ) {\r\n        this.a = a;\r\n        stuff = leftovers;\r\n    }\r\n}\r\n\r\nMap<String, Object> expected = new HashMap<>();\r\nexpected.put(\"b\", Integer.valueOf(42));\r\nexpected.put(\"c\", Integer.valueOf(111));\r\n\r\nPOJO562WithAnnotationOnBothCtorParamAndField pojo = MAPPER.readValue(a2q(\r\n        \"{'a':'value', 'b':42, 'c': 111}\"\r\n        ),\r\n        POJO562WithAnnotationOnBothCtorParamAndField.class);\r\n\r\nassertEquals(\"value\", pojo.a);\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError: \r\n// Expected :{b=42, c=111}\r\n// Actual   :null\r\nassertEquals(expected, pojo.stuff);\r\n```\n\n### Expected behavior\n\n_No response_\n\n### Additional context\n\nWhile this won't normally happen, it is possible with Records:\r\n1. `@JsonAnySetter`'s `@Target` allows for `ElementType.FIELD` & `ElementType.PARAMETER`.\r\n2. Which means when `@JsonAnySetter` is annotated on a Record component, the annotation will be propagated to both field & constructor parameter.\r\n3. Record fields was previously removed by #3737, so Jackson only sees `@JsonAnySetter` on the constructor parameter.\r\n4. But when I tried to revert #3737 via #4627 to fix some bugs, Jackson now sees `@JsonAnySetter` in both field & constructor parameter, hence this issue.\n\n\nComment by yihtserns:\nRight now, if `@JsonAnySetter` is annotated on both a field & a constructor parameter, the former will \"win\": https://github.com/FasterXML/jackson-databind/blob/f3c84db3a31c584a75d20d636088c54644671c74/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java#L669-L682\r\n\r\nThe weird thing is it will then proceed to inject unrecognized properties into NEITHER the field NOR the constructor argument.\r\n\r\nIt works when I reverse the priority/precedence (i.e. allowing constructor parameter to \"win\"), but I've yet to create a PR to propose for that change because I want to understand what's causing the current bizarre behaviour.\n\nComment by cowtowncoder:\nOk; with regular accessors there is clearly define precedence so Constructor parameter has precedence over Setter which has precedence over Field. Something similar maybe should probably be done for any-setter (and as necessary any-getter but that's separate), which I think you are suggesting.\r\n\r\nBut as to how injection may fail altogether... I don't know. Does sound weird.\r\n\n\nComment by cowtowncoder:\nActually, now that I bump into the same issue trying to work on #4626, looking at `POJOPropertiesCollector`, I think the real problem is that `@JsonAnySetter` is not really detected for Constructor (creator) parameters at all! So everything relies on there being a Field and that Field being used, then. Instead of making things work the proper way (which is much more difficult TBH).\r\n\r\nThis is why my initial thinking wrt detecting Record Fields in `POJOPropertiesCollector` for a bit, until dropping at the end (after merging annotations) didn't quite work.\r\nAlthough looking at code, I actually don't see how dropping fields of `POJOPropertyBuilder` manages to remove Any-setter field from `POJOPropertiesCollector`. :-(\n\nComment by cowtowncoder:\nHmmh. Actually, `Field` linkage is not added for `@JsonAnySetter` annotated constructor parameters. But if so, why does dropping other Fields of record have any effect.\r\nVery confusing.\n\nComment by yihtserns:\nApparently the path for processing `@JsonAnySetter` on field vs constructor parameter split off in `BeanDeserializer._deserializeUsingPropertyBased`:\r\n\r\n<table>\r\n  <tbody>\r\n    <tr>\r\n      <th><code>@JsonAnySetter</code> on field</th>\r\n<td>\r\n<pre>\r\n<code>\r\n            /---\u27a4---\u27a4---\u27a4 SettableAnyProperty.MapFieldAnyProperty\r\n--\u27a4---\u27a4---\r\n            \\--------------\r\n</code></pre>\r\n</td>\r\n    </tr>\r\n    <tr>\r\n      <th><code>@JsonAnySetter</code> on constructor parameter</th>\r\n<td>\r\n<pre>\r\n<code>\r\n            /--------------\r\n--\u27a4---\u27a4---\r\n            \\---\u27a4---\u27a4---\u27a4 SettableAnyProperty.MapParameterAnyProperty\r\n</code></pre>\r\n</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\nFor the case of `@JsonAnySetter` on BOTH field & constructor parameter:\r\n1. It creates a `SettableAnyProperty.MapFieldAnyProperty` for the field...\r\n2. ...but goes down the path for constructor parameter (not due to any special handling for `@JsonAnySetter`, but just an accident due to the existing design of dealing with constructor parameters).\r\n```\r\n            /-------------- SettableAnyProperty.MapFieldAnyProperty\r\n--\u27a4---\u27a4---\r\n            \\---\u27a4---\u27a4---\u27a4\r\n```",
                "source_code": null,
                "distance": 0.25,
                "title": "`@JsonAnySetter` not working when annotated on both constructor parameter & field",
                "name": "issue#4634",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    }
                ],
                "similarity": 0.8554325469953371,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4641",
                "type": "issue",
                "content": "Switching the priority not just because doing so happens to fix #4634, but also because it feels weird to prioritise field if both are annotated with `@JsonAnySetter`.\n\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Prioritize constructor parameter over field if both are annotated with `@JsonAnySetter`, to fix #4634",
                "name": "pr#4641",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4641"
                    }
                ],
                "similarity": 0.5954582090815296,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3439",
                "type": "issue",
                "content": "**Describe the bug**\r\nWhen deserializing a Java Record with `@JsonAnySetter` annotated field the field is left as null and the unmapped values are ignored. Given the nature of Java records, there is no other way to get the unmapped fields values (like in case of annotating a setter method).\r\n\r\n**Version information**\r\n2.13.2.2\r\n\r\n**To Reproduce**\r\n```java\r\nimport com.fasterxml.jackson.annotation.JsonAnySetter;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.util.Map;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\n\r\npublic class JsonAnySetterRecordTest {\r\n\r\n    record TestRecord(\r\n        @JsonProperty String field,\r\n        @JsonAnySetter Map<String, Object> anySetter\r\n    ) {}\r\n\r\n    @Test\r\n    void testJsonAnySetterOnRecord() throws JsonProcessingException {\r\n        var json = \"\"\"\r\n            {\r\n                \"field\": \"value\",\r\n                \"unmapped1\": \"value1\",\r\n                \"unmapped2\": \"value2\"\r\n            }\r\n            \"\"\";\r\n\r\n        var objectMapper = new ObjectMapper();\r\n\r\n        var deserialized = objectMapper.readValue(json, TestRecord.class);\r\n\r\n        assertEquals(\"value\", deserialized.field());\r\n        assertEquals(Map.of(\"unmapped1\", \"value1\", \"unmapped2\", \"value2\"), deserialized.anySetter());\r\n    }\r\n\r\n}\r\n```\r\n\r\nRunning this test the result will be:\r\n\r\n```\r\nExpected :{unmapped1=value1, unmapped2=value2}\r\nActual   :null\r\n```\r\n\r\n**Expected behavior**\r\nThe `@JsonAnySetter` annotated field should contain a Map instance with all unmapped fields and their values.\r\n\r\n**Additional context**\r\nThe problem happens in `com.fasterxml.jackson.databind.deser.SettableAnyProperty` class in method `set(...)`. The value of the  `@JsonAnySetter` annotated field is null and therefore setting the property value is skipped. \r\n\r\nThe suggested solution would be for Java Record to provide a new empty Map instance for the annotated field to gather the unmapped properties and this would then be provided to Record's constructor when the deserialization is concluded. Given the immutable nature of Java Records, this should ideally be some kind of immutable Map implementation (i.e. `Map.copyOf(...)` ?)\r\n\r\nThere might be a workaround (which however won't be probably feasible in all cases) by supplying an additional `@JsonCreator` constructor or factory method, where the `@JsonAnySetter` field is initialized to an empty map and then to ensure the immutability, the getter for this map needs to be overridden and the value returned wrapped as immutable.\r\n\r\n```java\r\nrecord TestRecord(\r\n        String field,\r\n        @JsonAnySetter Map<String, Object> anySetter\r\n    ) {\r\n\r\n        @JsonCreator\r\n        TestRecord(@JsonProperty(\"field\") String field) {\r\n            this(field, new HashMap<>());\r\n        }\r\n\r\n        public Map<String, Object> anySetter() {\r\n            return Collections.unmodifiableMap(anySetter);\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\n\n\nComment by cowtowncoder:\nCurrently `@JsonAnySetter` is not supported for Creator arguments (#562), unfortunately, which is probably why this does not work.\n\nComment by fprochazka:\nThans for the hint @oujesky, I've managed to make it work: \r\n\r\n\r\n<details>\r\n  <summary><code>AnySetterOnCreatorJacksonModule</code></summary>\r\n  \r\n```java\r\n@AutoService(Module.class)\r\npublic class AnySetterOnCreatorJacksonModule extends SimpleModule\r\n{\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    public AnySetterOnCreatorJacksonModule()\r\n    {\r\n        super(AnySetterOnCreatorJacksonModule.class.getSimpleName());\r\n\r\n        setDeserializerModifier(new BeanDeserializerModifier()\r\n        {\r\n            @Override\r\n            public BeanDeserializerBuilder updateBuilder(final DeserializationConfig config, final BeanDescription beanDesc, final BeanDeserializerBuilder builder)\r\n            {\r\n                if (!beanDesc.getBeanClass().isRecord()) {\r\n                    return builder;\r\n                }\r\n\r\n                @Nullable AnnotatedMember anySetterAccessor = beanDesc.findAnySetterAccessor();\r\n                if (anySetterAccessor == null) {\r\n                    return builder;\r\n                }\r\n\r\n                JavaType parameterType = anySetterAccessor.getType();\r\n                if (!parameterType.isMapLikeType() && !Map.class.isAssignableFrom(parameterType.getRawClass())) {\r\n                    return builder;\r\n                }\r\n\r\n                builder.setValueInstantiator(new FixedAnySetterCreatorValueInstantiator(builder.getValueInstantiator(), anySetterAccessor));\r\n\r\n                return builder;\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    private static final class FixedAnySetterCreatorValueInstantiator extends ValueInstantiator.Delegating\r\n    {\r\n\r\n        private final AnnotatedMember anySetterAccessor;\r\n\r\n        FixedAnySetterCreatorValueInstantiator(final ValueInstantiator delegate, final AnnotatedMember anySetterAccessor)\r\n        {\r\n            super(delegate);\r\n            this.anySetterAccessor = anySetterAccessor;\r\n        }\r\n\r\n        @Override\r\n        public Object createFromObjectWith(final DeserializationContext context, final SettableBeanProperty[] props, final PropertyValueBuffer buffer) throws IOException\r\n        {\r\n            if (buffer.isComplete()) {\r\n                return super.createFromObjectWith(context, props, buffer);\r\n            }\r\n\r\n            SettableBeanProperty anySetterProperty = getAnySetterCreatorProperty(props);\r\n\r\n            buffer.assignParameter(anySetterProperty, new LinkedHashMap<>());\r\n\r\n            return super.createFromObjectWith(context, props, buffer);\r\n        }\r\n\r\n        private SettableBeanProperty getAnySetterCreatorProperty(final SettableBeanProperty[] props)\r\n        {\r\n            for (SettableBeanProperty prop : props) {\r\n                if (Objects.equals(anySetterAccessor.getName(), prop.getName())) {\r\n                    return prop;\r\n                }\r\n            }\r\n\r\n            throw new IllegalStateException(String.format(\"Cannot find %s in %s\", anySetterAccessor, List.of(props)));\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n</details>\r\n\r\nNow I can write just\r\n\r\n```java\r\nrecord Data(\r\n    @JsonProperty(\"Status\") String status,\r\n    @JsonAnyGetter @JsonAnySetter Map<String, Object> otherFields\r\n)\r\n{\r\n\r\n}\r\n```\r\n\r\nand it does what I wanted :rocket:  I have yet to fix the immutability problem, but that shouldn't be much hard to hack :) \n\nComment by cowtowncoder:\nI think this is basically duplicate of #562.\n\nComment by mwisnicki:\n> Thans for the hint @oujesky, I've managed to make it work:\r\n> \r\n> `AnySetterOnCreatorJacksonModule`\r\n> \r\n> and it does what I wanted \ud83d\ude80 I have yet to fix the immutability problem, but that shouldn't be much hard to hack :)\r\n\r\nUnfortunately it returns entries in reverse order :(\n\nComment by kleino:\nSo far, I've used the workaround with `@JsonCreator` provided by [oujesky](https://github.com/oujesky). Unfortunately starting with Jackon 2.15.1 this doesn\u00b4t work anymore and the `@JsonAnySetter` annotated field is null again :(\n\nComment by yihtserns:\n@kleino [JsonAnySetter](https://fasterxml.github.io/jackson-annotations/javadoc/2.9/com/fasterxml/jackson/annotation/JsonAnySetter.html) documents two ways:\r\n1. Using field (of type Map or POJO)\r\n2. Using non-static two-argument method (first argument name of property, second value to set)\r\n\r\nYou've been using #&#8203;1, which is no longer usable because #3737 ignores Record fields for deserialization (so Jackson cannot \"see\" the `@JsonAnySetter` on the now-gone field).\r\n\r\nYou can still use #&#8203;2:\r\n```\r\nrecord TestRecord(String field, Map<String, Object> anySetter) {\r\n\r\n    @JsonCreator\r\n    TestRecord(@JsonProperty(\"field\") String field) {\r\n        this(field, new HashMap<>());\r\n    }\r\n\r\n    public Map<String, Object> anySetter() {\r\n        return Collections.unmodifiableMap(anySetter);\r\n    }\r\n\r\n    @JsonAnySetter \r\n    private void updateProperty(String name, Object value) {\r\n        anySetter.put(name, value);\r\n    }\r\n}\r\n```\n\nComment by cowtowncoder:\nHmmh. Ideally we'd support `@JsonAnySetter` the way intended.  But thank you @yihtserns for showing a work-around until then.\n\nComment by lordvlad:\nIs there any intent to tackle this issue? It's blocking us from using records in many places, unfortunately.\n\nComment by cowtowncoder:\n@lordvlad If someone was working on this, they'd likely add a note. So I doubt anyone is working on it. I do not have bandwidth myself, but perhaps @JooHyukKim might have?\n\nComment by JooHyukKim:\n~~FYI, 2.15 or later throws `UnrecognizedPropertyException` instead of returning `null` (see #4346 for reproduction).~~\r\n\r\nEDIT: Crossed out in favor of #562 \n\nComment by cowtowncoder:\nNote: #562 is the main issue wrt inability to use `@JsonAnySetter` on Creator properties.\n\nComment by tayloj:\nJust came across this issue, because I ran into it as well, but I wanted to share my workaround, which is similar to the [one provided][1] but uses a compact constructor to avoid the need for a \"full constuctor\" annotated with JsonCreator that replicates the entire arglist.  This doesn't remove the fact that we're adding a _mutable_ map to the record instance, which might be undesirable in some cases.\r\n\r\n```java\r\n  record Person(String name, Map<String, Object> attributes) {\r\n\r\n    /**\r\n     * Creates a new instance. If {@code attributes} is null, a new <em>mutable</em> map is created\r\n     * and used instead.\r\n     *\r\n     * @param name the name\r\n     * @param attributes the attributes map, or null\r\n     */\r\n    Person {\r\n      attributes = attributes == null\r\n          ? new HashMap<>()\r\n          : attributes;\r\n    }\r\n\r\n    @JsonAnySetter\r\n    public void addAttribute(final String key, final Object value) {\r\n      attributes.put(key, value);\r\n    }\r\n  }\r\n```\r\n\r\n[1]: https://github.com/FasterXML/jackson-databind/issues/3439#issue-1190261041\n\nComment by yihtserns:\n@tayloj\r\n\r\n- **Bad news**: [your workaround](https://github.com/FasterXML/jackson-databind/issues/3439#issuecomment-2075469872) will no longer work in the upcoming `2.18.0`.\r\n- **Good news**: workarounds are no longer necessary as #562 has been implemented.\r\n\r\n@cowtowncoder I think this can be closed?\n\nComment by cowtowncoder:\nYes, will mark as fixed as of 2.18.0; close.\n\nComment by cowtowncoder:\nAdded a new test (similar to one for #562 but still); passes, closing as implemented",
                "source_code": null,
                "distance": 0.5,
                "title": "Java Record `@JsonAnySetter` value is null after deserialization",
                "name": "issue#3439",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3439"
                    }
                ],
                "similarity": 0.5933176535405016,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "562",
                "type": "issue",
                "content": "I could speed up some code if I could write:\n\n```\n@JsonCreator\npublic MyClass(@JsonProperty(\"a\") String a, @JsonAnySetter Map<String, Object> leftovers) {}\n```\n\n\n\nComment by whiskeysierra:\n:+1: Is this something that you already considered putting in?\n\n\nComment by cowtowncoder:\nConsidered, yes, had time to try to tackle, no. Would definitely be nice thing to support.\n\n\nComment by huhlig:\nAny likelihood this will land in 3.x?\n\nComment by davide-imbriaco:\nHi,\r\nI would also really like this (allows for immutable beans, and validation of data in constructor method).\n\nComment by cowtowncoder:\n@huhlig It would be nice to get it there, but I can not predict whether it will or not. I do think it would be great to get it to work but there are so many things to work on...\r\n\r\nI will keep this in mind as one of \"more/most wanted\" issues.\r\n\n\nComment by davidmoten:\nI'd also like to see this feature. As a workaround for the immutability enthusiasts, here's an example of using JsonAnySetter in an immutable class (swap out the Map/HashMap for an immutable equivalent as you like). The trick is that the JsonAnySetter method can be made private.\r\n\r\n```java\r\n@JsonAutoDetect(fieldVisibility = Visibility.ANY, creatorVisibility = Visibility.ANY, setterVisibility = Visibility.ANY)\r\npublic static final class WithMap {\r\n\r\n    @JsonProperty(\"name\")\r\n    private String name;\r\n\r\n    @JsonAnyGetter\r\n    private Map<String, String> map;\r\n\r\n    @JsonCreator\r\n    public WithMap(@JsonProperty(\"name\") String name) {\r\n        this.name = name;\r\n        this.map = new HashMap<>();\r\n    }\r\n    \r\n    public WithMap(String name, Map<String, String> map) {\r\n        this.name = name;\r\n        this.map = map;\r\n    }\r\n    \r\n    @JsonAnySetter\r\n    private void put(String key, String value) {\r\n        map.put(key, value);\r\n    }\r\n    \r\n    public String name() {\r\n        return name;\r\n    }\r\n\r\n    public Map<String, String> map() {\r\n        return Collections.unmodifiableMap(map);\r\n    }\r\n}\r\n```\n\nComment by cowtowncoder:\n@JooHyukKim I think we could use a \"failing\" test case for this, as pre-cursor to #3439.\r\n\r\nNote, too, that this is definitely one of Most-Wanted issues open.\r\n\n\nComment by cowtowncoder:\nAdded a failing test, as a minor help for anyone considering to try to implement.\r\n\r\nAlso, made `@JsonAnySetter` applicable to (constructor) parameters in `jackson-annotations` 2.17 (was not previously).\n\nComment by JooHyukKim:\n> Also, made `@JsonAnySetter` applicable to (constructor) parameters in `jackson-annotations` 2.17 (was not previously).\n\nThis is great. Thank you for taking care of things in advance.\n\nComment by cowtowncoder:\nNp. Needed that already for reproduction :)\r\n\n\nComment by cowtowncoder:\nQuick note: really hoping to get this resolved for 2.18 -- and I think there's a good chance this can happen.\r\n\n\nComment by cowtowncoder:\nThanks to PR by @JooHyukKim this is now FINALLY implemented, merged for inclusion in 2.18.0!!!",
                "source_code": null,
                "distance": 0.5,
                "title": "Allow `@JsonAnySetter` to flow through Creators",
                "name": "issue#562",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    }
                ],
                "similarity": 0.5627361113703709,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4508",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nI have kotlin data class\r\n```@JsonTypeName(\"perform\")\r\ndata class Request(\r\n    @JsonProperty(\"header\")\r\n    override val header: String? = null,\r\n    @JsonIgnore\r\n    @JsonAnySetter\r\n    @JsonAnyGetter\r\n    val additionProperties: Map<String, Any?>? = null,\r\n) : Parent(header)\r\n```\r\nand json \r\n```\r\n      {\r\n            \"payloadType\": \"perform\",\r\n            \"data\":{\r\n              \"header\": \"lol\",\r\n              \"type\": \"sometype\",\r\n              \"any_other_data\": {\r\n                  \"field1\": \"1\",\r\n                  \"field2\": \"\",\r\n                  \"field3\": \"\",\r\n                  \"field4\": {\r\n                      \"field5\": \"\",\r\n                      \"field6\": \"\",\r\n                      \"field7\": \"anytext\"\r\n                  }\r\n              }\r\n            }\r\n        }\r\n```\r\n\r\nBefore jackson 2.17.0 the json deserialized into class correctly. any_other_data put to additionalProperties map.\r\nOn 2.17.0 version i have additionalProperties == null after the deserialization.\r\n\r\n### Version Information\r\n\r\n2.17.0\r\n\r\n\r\n### Expected behavior\r\n\r\ni expected that field annotated with @JsonAnySetter will be filled with all the undeclared fields \n\n\nComment by JooHyukKim:\nSince `additionalProperties` has default value of `null`, we can say either...\r\n\r\n- field is deserialized to null\r\n- field is not deserialized, so deafult to null\r\n\r\nCould you provide Java-only reproduction to make sure it is `jackson-databind` issue, @MaximValeev ?\r\nThere is separate [kotlin repo](https://github.com/FasterXML/jackson-module-kotlin) FYI.\n\nComment by cowtowncoder:\nRight; either this needs to move to `jackson-module-kotlin` (I can transfer if so), or reproduction should be in Java.\r\n\r\nBut I think there is probably already an issue wrt `@JsonAnySetter` not working with Creator properties -- and even PR to potentially fix that.\r\n\n\nComment by kotcrab:\nI also ran into this issue, it can be fixed by writing `@field:JsonAnySetter`. In 2.17.0 `ElementType.PARAMETER` was added to the `@Target` list of `JsonAnySetter`, this causes Kotlin to add this annotation to the constructor parameter instead of the field as [described here](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets) if you don't specify explicit use-site target.\n\nComment by JooHyukKim:\nAh, thank u for sharing @kotcrab !\n\nComment by JooHyukKim:\nSome background.\r\n\r\nAs @kotcrab described above, this is regression caused by [annotations module change](https://github.com/FasterXML/jackson-annotations/issues/242), the annotation change was meant to be pre-requisite for the databind-module's  [Allow 'JsonAnySetter' to flow through JsonCreator #562](https://github.com/FasterXML/jackson-databind/issues/562) issue.\r\n\r\nI started writing PR #4366 to support the databind-module change, but stopped to allow room for Property Introspection Rewrite in #4515.\r\n\r\nAs per solution, either....\r\n\r\n- revert adding `ElementType.PARAMETER` to `JsonAnySetter` or... \r\n- ask @k163377 if it's possible to make changes so that Kotlin module can discover `@JsonAnySetter` without `@field:` declaration. Or maybe @cowtowncoder knows the proper extension point for `JsonAnySetter` discovery?\n\nComment by cowtowncoder:\nWait, what is that `@JsonIgnore` doing here??!\r\n\r\n```\r\n    @JsonIgnore\r\n    @JsonAnySetter\r\n    @JsonAnyGetter\r\n    val additionProperties: Map<String, Any?>? = null,\r\n```\r\n\r\nwouldn't that mean \"ignore this any setter/getter\"? That should not be added there.\r\n\r\n\n\nComment by m-valeev:\n@cowtowncoder  No, it wouldn\u2019t. It means ignoring additionalProperties itself in serialization and deserialization. However, the other two annotations, @JsonAnySetter and @JsonAnyGetter, will be used for all unrecognized properties. All unrecognized properties will be added to the map for serialization and obtained from the map for deserialization.\n\nComment by yawkat:\nJsonAnyGetter/Setter will already not appear in the serialization/deserialization as its own property. The JsonIgnore is not necessary and should not be there\n\nComment by cowtowncoder:\n@MaximValeev it is possible `@JsonIgnore` does no harm, but in general it is to remove accessor (getter, setter, field, ctor parameter) from consideration (or if no inclusion, whole property).\r\nAnd as @yawkat pointed out, it should not be necessary as JsonAnyGetter/Setter has priority over regular property detection.\r\n\r\nBut as to proper fix: I think #562 would be that (maybe via #4558) -- to may `@JsonAnySetter` work via Constructor parameter (not just Field or Method).\r\n\r\nAlternatively, yes, Kotlin side should annotate Field to use.\r\n\r\n\n\nComment by k163377:\nI understood that there is nothing to do in `KotlinModule` as it is handled by #4558 .\n\nComment by cowtowncoder:\n@k163377 Yes, I think it's matter of getting #562 resolved (via #4558) and then Kotlin side probably wants to have a test to verify things work there as expected. But hopefully no other work needed (but you never know before testing :) ).\n\nComment by JooHyukKim:\nCaution : this is not about what has caused the change in behavior in 2.17. Instead, this is about making it work in 2.18.\r\n\r\nSo I found out that `StdValueInstantiator.createFromObjectWith(DeserializationContext, SettableBeanProperty[], PropertyValueBuffer)` method is overridden by `KotlinValueInstantiator`. I think we need some modification either on `kotlin-module` or `databind` to support this.\r\n\r\nMy intuition is that, below implementation in `PropertyValueBuffer.getParameters(SettableBeanProperty[])` method...\r\n\r\n```java\r\n        // [databind#562] since 2.18 : Respect @JsonAnySetter in @JsonCreator\r\n        if (_anyParamSetter != null) {\r\n            Object anySetterParameterObject = _anyParamSetter.createParameterObject();\r\n            for (PropertyValue pv = _anyParamBuffered; pv != null; pv = pv.next) {\r\n                pv.setValue(anySetterParameterObject);\r\n            }\r\n            _creatorParameters[_anyParamSetter.getParameterIndex()] = anySetterParameterObject;\r\n        }\r\n```\r\n... should be moved somewhere to make it work? \n\nComment by cowtowncoder:\nIdeally we should remove the need for KotlinValueInstantiator overrides. But on short term, yes, may need to update override in question.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "deserialized JsonAnySetter field is null ",
                "name": "issue#4508",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    },
                    {
                        "start_node": "issue#562",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4508"
                    }
                ],
                "similarity": 0.5290001606313943,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4627",
                "type": "issue",
                "content": "Proposal for #4626.\r\n\r\nTurns out Record fields (or rather the annotations on them) are needed for both serialization (https://github.com/FasterXML/jackson-databind/issues/3628, https://github.com/FasterXML/jackson-databind/issues/3895, https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532842582) & deserialization (#4626).\r\n\r\nSo we need to either keep them or change the way/order we harvest annotation info in `POJOPropertiesCollector` (for someone who knows every little about the codebase, I only dared to propose the former).\n\n\nComment by cowtowncoder:\n@yihtserns Overall I think that makes sense, given it addresses problems you demonstrated.\r\nJust want to change the checking of if an `AnnotatedField` is part of Record a bit, to do it at caller, not within `AnnotatedField` itself (since caller has all the information about declaring type).\n\nComment by yihtserns:\nAlthough there's no test, I just found out that this change broke #562 implementation for Records...\r\n\r\nCould've closed #3439, but now it's blocked again...  \ud83d\ude22 \n\nComment by cowtowncoder:\n@yihtserns Ugh. Could you file a separate new issue (referencing #562 and this PR)?\r\nToo bad we have many tests for POJOs wrt 562, but not any Record one.\r\n\r\nBtw, big THANK YOU for finding all these issues as well as obviously fixing.\n\nComment by cowtowncoder:\n@yihtserns Not only that, but looks like `jackson-module-kotlin` (2.18 and master) tests started failing :-(\r\n\r\nhttps://github.com/FasterXML/jackson-module-kotlin/actions/runs/10031852459\r\n\r\n(on plus side, cascading rebuilds expose these failures sooner)\r\n\r\n/cc @k163377 \n\nComment by yihtserns:\n@cowtowncoder Seems like this is a bad PR, can you please revert it and I'll see if I can rework it?\r\n\r\nSorry for the trouble.\n\nComment by cowtowncoder:\n@yihtserns was about to suggest the same. Will do.\r\n\r\nOne thing that'd be good would be to take unit tests from here, add under `.../failing`.\n\nComment by cowtowncoder:\n@yihtserns  Hmmmh. This is odd... Kotlin failures remain after revert. So it seems some other commit broke it, not this PR. But I don't see previous cascading build failures so I am bit confused as to what might have caused breakage.\r\nPerhaps this could be re-applied, if #562 problem could be resolved.\r\n\r\ncc @k163377 Looks like there are 3 test failures for `jackson-module-kotlin`; unclear what changed to cause that.\r\n\n\nComment by yihtserns:\nCreated PR #4633 to add test cases for Records+JsonAnySetter including all the workarounds shared in #3439.\n\nComment by yihtserns:\n@cowtowncoder I suspect the Kotlin failure is caused by Kotlin refusing to play nice with https://github.com/FasterXML/jackson-annotations/issues/258 (it generated a dodgy looking `.class`).\r\n\r\nI downgraded `jackson-annotations` to `2.17.2` locally and the tests are passing again.",
                "source_code": null,
                "distance": 0.25,
                "title": "Ignore Records' immutable fields in BeanDeserializerFactory instead of ignoring it in POJOPropertiesCollector, to preserve any annotation info the fields may be carrying.",
                "name": "pr#4627",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    }
                ],
                "similarity": 0.5164295669668137,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4366",
                "type": "issue",
                "content": "resolves #562 \n\n\nComment by cowtowncoder:\nImpressive. I am bit hesitant to consider this as one more thing before work on Property Introspection rewrite, but no harm in figuring out how this could work. Added some notes.\n\nComment by JooHyukKim:\n> Impressive. I am bit hesitant to consider this as one more thing before work on Property Introspection rewrite, \n\nI concur. And also in the issue #562, this feature is to get included in 3.x.\n\nSo I think we can safely consider this feature only after Property Introspection rewrite.\n\n> but no harm in figuring out how this could work. Added some notes.\n\nThankssss! I will keep them updated\n\nComment by cowtowncoder:\nCool, this is much improved. I'll make tiny changes, wrt suggestions I added.\n\nComment by cowtowncoder:\n@JooHyukKim Ok, I made a few changes that I think help, including validation that only one \"any-setter\" is specified.\r\n\r\nI was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into `PropertyValueBuffer` (make it take `SettableAnyProperty`).\r\nAlso I think validation wrt `DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES` need to be able to skip check for placeholder there.\r\n\r\n\n\nComment by JooHyukKim:\n> I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n\r\nDo you mean do the `PropertyValueBuffer` construction with anySetter in it in the first place, in earlier part of `_deserializeUsingPropertyBased`? If so, sounds like an idea.\r\n\r\n> Also I think validation wrt DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES need to be able to skip check for placeholder there.\r\n\r\nPlaceholder? \ud83e\udd14 Could u elaborate a bit more? \r\n\n\nComment by cowtowncoder:\n> > I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n> \r\n> Do you mean do the `PropertyValueBuffer` construction with anySetter in it in the first place, in earlier part of `_deserializeUsingPropertyBased`? If so, sounds like an idea.\r\n\r\nRight.\r\n \r\n> > Also I think validation wrt DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES need to be able to skip check for placeholder there.\r\n> \r\n> Placeholder? \ud83e\udd14 Could u elaborate a bit more?\r\n\r\nWhat I mean is to test to see that if this setting is enabled, it will not cause failure since property that represents \"any-setter\" has no associated value.\r\nSo by placeholder I meant constructor parameter that is not a \"real\" parameter, similar to how injectable value isn't required to come from input.\r\n\n\nComment by JooHyukKim:\n> I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n\r\ncc/ @cowtowncoder Implemented as suggested in commit https://github.com/FasterXML/jackson-databind/pull/4366/commits/8612433174444c364f704fa6a82c802baba3f959. Apologies in advance for formatter taking up large portion.\r\n\r\nIMO, this new version seems more appropriate in that we don't handle values twice --first buffering in PropertyValueBuffer then transfer to map for AnySetter parameter.\n\nComment by cowtowncoder:\n@JooHyukKim We could revisit this, now that #4515 is complete. Would need to be re-based to 2.18, and I suspect it won't merge cleanly due to overlapping changes. But at least not blocked by concerns of property introspection complications.\n\nComment by JooHyukKim:\nWill rebase now \ud83d\udc4d\ud83c\udffc\ud83d\udc4d\ud83c\udffc\n\nComment by JooHyukKim:\nWDYT, @cowtowncoder ?\r\nWe can visit #4396 after this.\n\nComment by cowtowncoder:\n> WDYT, @cowtowncoder ? We can visit #4396 after this.\r\n\r\nOk. I am still struggling with this; reading again. It is improving, but I am still worried about added complexity. But at the same time this IS a VERY highly voted feature (that is, #562 is)\r\n\r\nSo it'd be great to be able to somehow simplify handling. Not sure how to, tho, so I need to keep on re-reading code.\r\n\r\nAside from that, some missing things:\r\n\r\n1. No tests yet for Record case? (should work fine I assume, but just noting)\r\n2. Only supports `Map`-backed any-setter, but not `JsonNode`-backed one (unlike Field-based one) -- adding support is probably not hard but does add to code, special casing\r\n\n\nComment by JooHyukKim:\n> So it'd be great to be able to somehow simplify handling. Not sure how to, tho, so I need to keep on re-reading code.\r\n\r\nI totally agree. Current implementation is both complex and scattered around places. \r\nI sort of focused on making work, not so much around maintainability.\r\n\r\nI will probably start isolating the any-setter logics first, maybe to a class, then will read through your comments and add suggested missing parts.\r\n\r\nthnx @cowtowncoder \r\n\r\nPS: Reviews applied first.\n\nComment by JooHyukKim:\nTemporarily closing this in favor of #4558 where I added `record` and `JsonNode` tests\r\n/cc @cowtowncoder ",
                "source_code": null,
                "distance": 0.75,
                "title": "Allow @JsonAnySetter on Creator constructors",
                "name": "pr#4366",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    },
                    {
                        "start_node": "issue#562",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4366"
                    }
                ],
                "similarity": 0.48876246533329587,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4558",
                "type": "issue",
                "content": "resolves #562 \r\n\r\nThis version is more adherent to existing call flow and simply extends existing implementations, such as....\r\n\r\n- Introduction of `SettableAnyProperty` subclasses `JsonNodeParameterAnyProperty` and `MapParameterAnyProperty`\r\n- Introduction of `SettableAnyProperty` methods `getParameterIndex()` `createParameterObject()` to streamline deserialization by `PropertyValueBuffer`\r\n\r\nAlso suggestions from PR #4366 have been followed \r\n\r\n- Added support for `JsonNode` and `ObjectNode`\r\n- Added tests for record also\r\n\n\n\nComment by cowtowncoder:\nExcellent progress! Hoping to review this in detail (had a quick look, much improved from what I already saw -- and not just wrt addressing things I mentioned but overall)\n\nComment by cowtowncoder:\nFWTW, this is part of one of two listed \"major design/implementation issues\" page:\r\n\r\nhttps://github.com/FasterXML/jackson-future-ideas/wiki/Major-Design---Implementation-Issues\r\n\r\nso not \"just\" one of top-voted Mostly Wanted features but also considered a significant design/implementation concern.\r\n\n\nComment by JooHyukKim:\nPhew, that was alot of work \ud83d\ude06 Hopefully, it won't be too hard merging into master.\r\nThank you for your help! @cowtowncoder\r\n\r\n\n\nComment by cowtowncoder:\n@JooHyukKim thank you for actually implementing it & going through all tiny things I wanted changed :)\r\n\r\nSurprisingly merge to master was quite straight-forward this time around.\r\n\r\nAnd with this, we are getting somewhat close to 2.18.0 minimum feature set, as far as I care.\r\nI do want this performance optimization: https://github.com/FasterXML/jackson-core/issues/1284 for streaming but otherwise not many must-haves.\r\n\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Allow `@JsonAnySetter` on Creators",
                "name": "pr#4558",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    },
                    {
                        "start_node": "issue#562",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4558"
                    }
                ],
                "similarity": 0.4714872098893145,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4633",
                "type": "issue",
                "content": "~~2 out of 3 workarounds no longer work, but I still added them anyway for awareness.~~ **UPDATE**: Removed them.\n\n\nComment by cowtowncoder:\nOk, as per my note, I don't like the idea of test that verifies incorrect behavior.\r\nTests should only test correct, expected behavior: but to avoid CI failure blocking builds, such failing tests should be in test class(es) under `src/test/.../failing`.\r\n\n\nComment by yihtserns:\nShould I just remove the test cases for workarounds that are no longer working?  Putting them in `src/test/.../failing` seems inappropriate since I wouldn't expect them to pass in the future, ever.\n\nComment by cowtowncoder:\n> Should I just remove the test cases for workarounds that are no longer working? Putting them in `src/test/.../failing` seems inappropriate since I wouldn't expect them to pass in the future, ever.\r\n\r\nAh. Yes, if that's the case, let's just remove them. I was assuming they were to be resolved in future.\r\n\n\nComment by yihtserns:\nTurns out there WAS test created for Records+JsonAnySetter, but the scenario is only when `@JsonAnySetter` is on a constructor parameter directly, not on a Record component: https://github.com/FasterXML/jackson-databind/blob/2.18/src/test-jdk17/java/com/fasterxml/jackson/databind/records/RecordCreatorWithAnySetter562Test.java\r\n\r\nThat explains why it didn't catch the regression caused by #4627.\n\nComment by yihtserns:\nNow that I know [RecordCreatorWithAnySetter562Test.java](https://github.com/FasterXML/jackson-databind/blob/2.18/src/test-jdk17/java/com/fasterxml/jackson/databind/records/RecordCreatorWithAnySetter562Test.java) exists, I'll rewrite-move my tests into that class.\n\nComment by yihtserns:\nSeems like this has become a duplicate of https://github.com/FasterXML/jackson-databind/commit/fb82b5b889d44253bd137c5bdbdcfd12821cdc21.\r\n\r\nClosing.",
                "source_code": null,
                "distance": 0.75,
                "title": "Add Records+JsonAnySetter workarounds shared in #3439, as test cases.",
                "name": "pr#4633",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4633"
                    }
                ],
                "similarity": 0.4609379590071666,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3974",
                "type": "issue",
                "content": "Sorry if it's duplicate but i did not find anything like that\r\n\r\n**Describe the bug**\r\nWhen using custom annotation, Annotated.getAnnotation() method does not return annotation for a field marked with this annotation.\r\n\r\n**Version information**\r\n2.15.0\r\n\r\n**To Reproduce**\r\nThis simple test can help:\r\n\r\n```\r\nclass AnnotationIssueApplicationTests {\r\n\r\n    @Test\r\n    void mask() {\r\n        var entity = new TestEntity(\"Secret\", \"Doe\");\r\n\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        mapper.setAnnotationIntrospector(\r\n                AnnotationIntrospectorPair.pair(\r\n                        mapper.getSerializationConfig().getAnnotationIntrospector(),\r\n                        new MaskSensitiveDataAnnotationIntrospector()));\r\n        try {\r\n            assertNotNull(\"Should be not null\", mapper.writeValueAsString(entity));\r\n        } catch (JsonProcessingException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @Target(ElementType.FIELD)\r\n    @Retention(RetentionPolicy.RUNTIME)\r\n    public @interface SensitiveField {}\r\n\r\n    private record TestEntity(\r\n            @SensitiveField String mySecretFieldPassword,\r\n            String name) {}\r\n\r\n\r\n    private static class MaskSensitiveDataAnnotationIntrospector extends NopAnnotationIntrospector {\r\n\r\n        @Override\r\n        public Object findSerializer(Annotated am) {\r\n            SensitiveField annotation = am.getAnnotation(SensitiveField.class);\r\n            //When i use jackson-core:2.14.1 the test below passes successfully\r\n           //When i use jackson-core:2.15.0 the test fails\r\n            if (am.getName().equals(\"mySecretFieldPassword\") && annotation == null){\r\n                throw new RuntimeException(\"This should not happen\");\r\n            };\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n**Expected behavior**\r\nWhen i use jackson-core:2.14.1 the test below passes successfully\r\nWhen i use jackson-core:2.15.0 the test fails\r\n\r\n**Additional context**\r\nThis happened when i updated Spring Boot from 3.0.2 to 3.1.0\r\nThis is my graddle build\r\n\r\n```\r\nplugins {\r\n    id 'java'\r\n    id 'org.springframework.boot' version '3.1.0'\r\n    id 'io.spring.dependency-management' version '1.1.0'\r\n}\r\n\r\ngroup = 'com.example'\r\nversion = '0.0.1-SNAPSHOT'\r\nsourceCompatibility = '17'\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\nimplementation 'com.fasterxml.jackson.core:jackson-annotations'\r\nimplementation 'com.fasterxml.jackson.core:jackson-core'\r\n//this fixes the issue    implementation 'com.fasterxml.jackson.core:jackson-databind:2.14.1'\r\n\r\n    implementation 'org.springframework.boot:spring-boot-starter'\r\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\r\n}\r\n\r\ntasks.named('test') {\r\n    useJUnitPlatform()\r\n}\r\n```\r\n\r\n\n\n\nComment by yihtserns:\n## Fix/workaround\r\nInclude `ElementType.METHOD` in your annotation:\r\n```\r\n@Target({ElementType.FIELD, ElementType.METHOD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface SensitiveField {}\r\n```\r\n...so that the accessor method will get the annotation directly, instead of getting it from the field during \"annotation merging\" process.\r\n\r\n-----\r\n\r\nCaused by #3737, specifically:\r\nhttps://github.com/FasterXML/jackson-databind/blob/2cea7c9ce9cbdcb14e22838ea07937c376b7ab78/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java#L1012-L1013\r\n\r\n...leading to the fields being removed by:\r\nhttps://github.com/FasterXML/jackson-databind/blob/2cea7c9ce9cbdcb14e22838ea07937c376b7ab78/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java#L954-L955\r\n\r\nWhen I created #3894 to refine/partially revert #3737, I did not also propagate the changes to `_removeUnwantedAccessor` because I don't understand what it is doing.\n\nComment by cowtowncoder:\nOne more suggestion: while it may not make a difference, it's probably worth checking if this still occurs with 2.15.2, given there are a few changes related to Record annotation handling.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "`com.fasterxml.jackson.databind.introspect.Annotated.getAnnotation()` method does not return annotation for a Record field",
                "name": "issue#3974",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3974"
                    }
                ],
                "similarity": 0.45984168748854676,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4346",
                "type": "issue",
                "content": "reproduces #3439 \r\n\r\nOnly the reproduction is intended to be against 2.15 for tracking purpose. E.g. ...\r\n\r\n> \"Did it work in 2.15? Okay it doesn't. let's try later version.\"\r\n\r\nFix will be made against later versions, probably 2.17\r\n\r\n\n\n\nComment by JooHyukKim:\nCI Failing on jdk 8 build only... lemme try again.\r\n\r\n<img width=\"904\" alt=\"image\" src=\"https://github.com/FasterXML/jackson-databind/assets/61615301/3bbb33f6-71ec-4eaa-8876-64249f7d4d46\">\r\n\n\nComment by cowtowncoder:\nActually, I was wondering if it'd make sense to instead file a new issue for `@JsonAnySetter` on regular, non-record Creator property? I first thought #1401 is that, but it is actually bit different.\r\nI think solving more general problem would make record special case work too.\r\n\r\n**EDIT**: It's actually #562...\r\n\r\n\n\nComment by JooHyukKim:\nAddressing #562 makes more sense.",
                "source_code": null,
                "distance": 0.75,
                "title": "Add failing test for #3439",
                "name": "pr#4346",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    },
                    {
                        "start_node": "issue#562",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4346"
                    }
                ],
                "similarity": 0.4580318241173991,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3063",
                "type": "issue",
                "content": "**Version information**\r\n2.12.1\r\nOpenJDK 15.0.1\r\n\r\n**To Reproduce**\r\n\r\nGiven:\r\n\r\n```\r\npublic final record GetLocations(@JsonValue Map<String, URI> nameToLocation)\r\n{\r\n\t@JsonCreator\r\n\tpublic GetLocations(Map<String, URI> nameToLocation)\r\n\t{\r\n\t\tassertThat(nameToLocation, \"nameToLocation\").isNotNull();\r\n\t\tthis.nameToLocation = new HashMap<>(nameToLocation);\r\n\t}\r\n}\r\n```\r\n\r\nI am expecting Jackson to serialize the `Map` to JSON but instead I get the following exception:\r\n\r\n`Problem with definition of [AnnotedClass GetLocations]: Multiple 'as-value' properties defined ([field GetLocations#nameToLocation] vs [method GetLocations#nameToLocation()])`\n\n\nComment by cowwoc:\nAdding the following code works around the problem (though ideologically, I'd prefer to serialize the return value of the getter than the field):\r\n\r\n```\r\n@JsonValue(false)\r\n@Override\r\npublic Map<String, URI> nameToLocation()\r\n{\r\n\treturn nameToLocation;\r\n}\r\n```\n\nComment by cowtowncoder:\nVery likely related to the general issue (hoped to be tackled in 2.13) of matching `@JsonCreator` (constructor) parameters to fields, so that effectively `@JsonValue` would be invisible to property handling logic.\r\n\r\nOn plus side, if so, would get solved along with quite a few other problems.\r\n\n\nComment by pjfanning:\n@cowtowncoder if I read this issue correctly, then this appears to be similar to an issue in Scala. Java Records are similar to Scala Case Classes. In a Case Class, the constructor params are automatically accessible publicly - essentially Scala compiler creates a scala class with a field and a method with the name of the field. Annotations are added to the field unless you use a special form of the annotation (`@(JsonValue @getter)` is an annotation that is added to the derived getter method instead of the field). Scala 3 has a bug where the `@getter` is ignored so the annotation is not treated correctly.\r\n\r\nSo the ask on my part, is would it be possible to have jackson-databind PojoPropertiesCollector look for `@JsonValue` annotations on methods and fields? \n\nComment by cowtowncoder:\n@pjfanning I think this would be part of the big rewrite of Creator-vs-Properties introspection that I was hoping to do for 2.13 but did not have time for. So got pushed forward.\r\n\r\nHandling of `@JsonValue` should be synchronized in a way that avoids any issues with property detection, in case of serialization, yes. Where exactly that should be rectified I am not sure.\r\n\r\nOne thing that might be help would be reproducing this with regular `@JsonCreator`-using POJO instead of `Record` (assuming this is possible). Records have some special handling but this might not be due to that but more general issue.\r\n\n\nComment by pjfanning:\n@cowtowncoder thanks for the update.\r\n\r\nMy comment above was really an enhancement request so that `@JsonValue` annotations could be supported on fields - would this be feasible?\n\nComment by cowtowncoder:\nThey are already, since Jackson 2.9 (see #1428).\r\n\n\nComment by pjfanning:\nthanks @cowtowncoder - must be something else going on that is causing the scala 3 stuff not to work\n\nComment by yihtserns:\n> ...though ideologically, I'd prefer to serialize the return value of the getter than the field...\r\n\r\n@cowwoc you can remove the `@JsonValue` annotation from the Record header, and annotate the accessor instead:\r\n```\r\npublic final record GetLocations(Map<String, URI> nameToLocation)\r\n{\r\n\t@JsonCreator\r\n\tpublic GetLocations(Map<String, URI> nameToLocation)\r\n\t{\r\n\t\tassertThat(nameToLocation, \"nameToLocation\").isNotNull();\r\n\t\tthis.nameToLocation = new HashMap<>(nameToLocation);\r\n\t}\r\n\r\n\t@JsonValue\r\n\t@Override\r\n\tpublic Map<String, URI> nameToLocation()\r\n\t{\r\n\t\treturn nameToLocation;\r\n        }\r\n}\r\n```\r\n\r\n## A Trick\r\nSince this issue is caused by [(auto-)propagation of annotation on Records components](https://openjdk.org/jeps/395#Annotations-on-record-components), we learn that the decision to propagate the annotation to either field and/or accessor method is decided by the `@Target` supported by the annotation itself.\r\n\r\nSince `@JsonValue` can be annotated on `ElementType.FIELD` & `ElementType.METHOD`, it gets propagated to both.  Knowing this, you can create a custom meta-annotation for `@JsonValue` that targets only `ElementType.METHOD`:\r\n```\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.METHOD)\r\n@JacksonAnnotationsInside\r\n@JsonValue\r\npublic @interface JsonValueAccessor {\r\n}\r\n```\r\n\r\nThen this will then work:\r\n```\r\npublic final record GetLocations(@JsonValueAccessor Map<String, URI> nameToLocation) // Your custom annotation\r\n{\r\n\t@JsonCreator\r\n\tpublic GetLocations(Map<String, URI> nameToLocation)\r\n\t{\r\n\t\tassertThat(nameToLocation, \"nameToLocation\").isNotNull();\r\n\t\tthis.nameToLocation = new HashMap<>(nameToLocation);\r\n\t}\r\n}\r\n```\n\nComment by cowtowncoder:\nOk I think I know how this can be fixed quite easily: `Method` should have precedence over `Field`so let's use that as tie-breaker.\n\nComment by cowtowncoder:\nFixed in 2.14 for 2.14.2.\r\n\n\nComment by yihtserns:\n@cowwoc please take note of the following gotcha for the workaround you used i.e.:\r\n```\r\n@JsonValue(false)\r\n@Override\r\npublic Map<String, URI> nameToLocation()\r\n{\r\n\treturn nameToLocation;\r\n}\r\n```\r\n\r\nThe fix https://github.com/FasterXML/jackson-databind/commit/c23f772cfee3d3bb370b9880b81a8d428322f5ef for `2.14.2` can cope with that workaround, so you'll still get the same resulting JSON of `{\"first\":\"http://example.com\",\"second\":\"http://google.com\"}` even if you don't remove it.\r\n\r\n\u26a0\ufe0f BUT if and when you upgrade to `2.15.0`, that workaround + the fix for #3352 (specifically https://github.com/FasterXML/jackson-databind/pull/3737) will result in JSON of `{\"nameToLocation\":{\"first\":\"http://example.com\",\"second\":\"http://google.com\"}}`, so you must remove it.\n\nComment by cowwoc:\n@yihtserns Got it. Thanks for the head's up.\n\nComment by cowtowncoder:\nHmmh. Ok that is bit unfortunate wrt compatibility, although not sure if anything can be done about it.\r\n`@JsonValue(false)` means \"do NOT use this method as 'JSON value' accessor.\r\nBut I guess had I realized there was a work-around that gets invalidated, I'd probably not have added this fix in 2.14 but only 2.15\r\n\n\nComment by yihtserns:\n>  But I guess had I realized there was a work-around that gets invalidated, I'd probably not have added this fix in 2.14 but only 2.15\r\n\r\n@cowtowncoder Eh your fix for `2.14.2` won't cause any problem with the workaround.  Let me rephrase:\r\n1. [The fix committed](https://github.com/FasterXML/jackson-databind/commit/c23f772cfee3d3bb370b9880b81a8d428322f5ef) for this issue in `2.14.2` will NOT break the workaround.\r\n   - Keeping/removing the workaround won't cause any problem.\r\n3. [The fix committed](https://github.com/FasterXML/jackson-databind/pull/3737) for #3352 in `2.15` WILL break the workaround.\r\n   - Keeping the workaround will result in incorrect JSON so it must be removed.\r\n\r\nSorry for any confusion.\n\nComment by cowtowncoder:\n@yihtserns ah yes. My bad; I did realize it after writing. Thank you for confirming.\r\nThat's a bit better, at least patch would not cause behavioral change.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "`@JsonValue` fails for Java Record",
                "name": "issue#3063",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3063"
                    }
                ],
                "similarity": 0.4451344446142036,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3897",
                "type": "issue",
                "content": "**Describe the bug**\r\n\r\nTrying to deserialize the following Java Record throws `MismatchedInputException`\r\n\r\n```java\r\n\r\npublic record Example(@JsonProperty(access = JsonProperty.Access.WRITE_ONLY) String value) {\r\n}\r\n\r\n```\r\n\r\nSame issue happens with at least a regular class and `@JsonCreator` constructor\r\n\r\nAdding any other fields fixes the issue, even if those fields are also WRITE_ONLY fields.\r\n\r\nStacktrace:\r\n\r\n```\r\nCannot construct instance of `foo.bar.baz.Example` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{\"value\": \"aaa\"}\"; line: 1, column: 2]\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `foo.bar.baz.Example` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{\"value\": \"aaa\"}\"; line: 1, column: 2]\r\n\tat app//com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\r\n\tat app//com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1739)\r\n\tat app//com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1364)\r\n\tat app//com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1424)\r\n\tat app//com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat app//com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat app//com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat app//com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat app//com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)\r\n\tat app//com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)\r\n```\r\n\r\n**Version information**\r\n2.15.0\r\n\r\n**To Reproduce**\r\nUsing the above record definition with plain ObjectMapper throws the above exception\r\n\r\n```java\r\nnew ObjectMapper().readValue(\"{\\\"value\\\": \\\"aaa\\\"}\", Example.class);\r\n```\r\n\r\n**Expected behavior**\r\nWith 2.14.2 value was successfully deserialized.\r\n\n\n\nComment by JooHyukKim:\nThis one seems to be  introduced in issue #3736 by PR #3737.\r\n\r\nhttps://github.com/FasterXML/jackson-databind/blob/8040e2a09cc515619ca0f8b1a24a545ab75ad3a9/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java#L441-L445\n\nComment by yihtserns:\nTo be fair, this is caused by the combination of #3724 + #3737 (this won't happen if either one is not done, but when together they cause this).\r\n\r\nSince I'm partially responsible (for #3724), I'll provide a fix as soon as I can.  In the meantime, you can use this workaround if you can/want to:\r\n```\r\npublic record Example(@JsonProperty(access = JsonProperty.Access.WRITE_ONLY) String value) {\r\n\r\n    // Force the incorrectly generated intCreator into propsCreator\r\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\r\n    Example {\r\n    }\r\n}\r\n```\n\nComment by yihtserns:\n@arlampin out of curiosity, what's the reason for allow a Record (essentially a data/DTO object) field for deserialization but not for serialization? \n\nComment by arlampin:\n> @arlampin out of curiosity, what's the reason for allow a Record (essentially a data/DTO object) field for deserialization but not for serialization?\r\n\r\nTo prevent accidentally logging sensitive data. We could skip storing/logging the whole object in this case, but it's written this way to be consistent with other input classes.\n\nComment by JooHyukKim:\nIn case anyone's willing to look into it, I submitted a test case https://github.com/FasterXML/jackson-databind/pull/3899 which might help jump-start digging into it.\n\nComment by yihtserns:\nCreated PR #3910 for this.\n\nComment by yihtserns:\n### How this scenario ended up in mode=DELEGATING?\r\nHow a 1-arg constructor parameter is evaluated (priority according to the listed order):\r\n\r\n| | What | Properties-based | Delegating |\r\n|---|---|---|---|\r\n|1| Constructor parameter has `@JsonProperty(\"<some name>\")` | \u2705 | |\r\n|2| Any field has `@JsonValue` | | \u2705 |\r\n|3| Any getter method has `@JsonValue` | | \u2705 |\r\n|4| Constructor parameter has `@JacksonInject` | \u2705 | |\r\n|5| Constructor parameter name matched a getter method name | \u2705 | |\r\n|6| Constructor parameter name matched a field name | \u2705 | |\r\n|7| Default | | \u2705 |\r\n\r\nFor deserialization, when a property is annotated with `JsonProperty(access = WRITE_ONLY)`:\r\n- Getter is removed\r\n- Field is not removed\r\n\r\nSo while it will not hit number 5, it should hit number 6.  But because Record fields were removed by #3737, it didn't hit number 6 and ended up with the number 7.\n\nComment by cowtowncoder:\nShould be fixed now for 2.15.1.",
                "source_code": null,
                "distance": 0.5,
                "title": "2.15.0 breaks deserialization when POJO/Record only has a single field and is marked `Access.WRITE_ONLY`",
                "name": "issue#3897",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3897"
                    }
                ],
                "similarity": 0.4391703005062132,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3906",
                "type": "issue",
                "content": "**Describe the bug**\r\nThis code used to work with 2.14.2, but not with 2.15.0\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nRecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n```\r\n\r\n**Version information**\r\n2.15.0\r\n\r\n**To Reproduce**\r\n```java\r\n/**\r\n * This works fine with Jackson 2.14.2, but not with 2.15.0.\r\n */\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    record RecordTest(String string, int integer) {\r\n    }\r\n\r\n    @Test\r\n    public void emptyJsonToRecord() throws JsonProcessingException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n\r\n        mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n        // mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n        RecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n\r\n\r\n        System.out.println(\"RecordTest deserialized: \" + recordTest_deserialized);\r\n        Assert.assertEquals(new RecordTest(null, 0), recordTest_deserialized);\r\n    }\r\n}\r\n```\r\nComment out the `mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)` and it works.\r\n\r\nNote that the commented-out `mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nException is:\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `io.mats3.examples.jbang.Jackson_2_15_0_Regression$RecordTest` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{}\"; line: 1, column: 2]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1915)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:414)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1360)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1424)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)\r\n\tat io.mats3.examples.jbang.Jackson_2_15_0_Regression.emptyJsonToRecord(Jackson_2_15_0_Regression.java:25)\r\n```\n\n\nComment by pjfanning:\nSeems to work if you don't change the mapper visibility setting - see #3907. Would it be possible for you to not set this value?\r\n\r\nThis issue will still be investigated. I'm just making the suggestion above as a workaround. I'm no expert on the benefits of setting the visibility to non-default values.\n\nComment by yihtserns:\n## Fix/workaround\r\nAllow visibility for `PropertyAccessor.CREATOR`:\r\n```\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.ANY);\r\n```\r\n\r\n## Explanation\r\nPreviously, Records deserialization is specially handled, resulting in some behavioural differences (mostly missing behaviours) compared to POJO deserialization.\r\n\r\n#3724 was done to address those differences, to close the gap between Records vs POJO de/serialization:\r\n1. This means now, Jackson looks for deserialization \"creators\" for Records the same way it looks for POJO's.\r\n2. `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` \"hides\" those \"creators\", because `PropertyAccessor.ALL` includes `PropertyAccessor.CREATOR`.\n\nComment by yihtserns:\n(Interesting to see the different config used to utilise Jackson as only a deserializer not serializer: here & #3897 \ud83e\udd14.)\n\nComment by stolsvik:\nThanks.\r\n\r\nThis is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records.\r\n\r\nI need this config to work both for 2.14.2 and 2.15. Will that new suggested configuration do that just the same? That is: I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the _data_ transferred. I guess I found that config somewhere sometime, and it have done exactly what I wanted for at least 6 years (used to be just classes, and then it also worked just as expected with records. Nice.)\r\n\r\n(PS: I cannot really \"test if it works\" with an alternate config, as this is a \"foundation lib\", there are at least 50 different random services that depend on this just working as it always has. I just wanted to upgrade to keep with the times! :-) That bit pretty hard, both this, and the 5M char limit for String: https://github.com/FasterXML/jackson-core/issues/863#issuecomment-1531090338 )\r\n\r\n(PPS: The bullet 2 where _\"setVisibility(PropertyAccessor.ALL, Visibility.NONE) \"hides\" those \"creators\", because PropertyAccessor.ALL includes PropertyAccessor.CREATOR\"_ on the face of it sounds like a clear bug to me. For a record, there is no other proper way to get this thing made, so they should probably not be included? At least not the canonical constructor?)\n\nComment by cowtowncoder:\nOne thing worth noting: Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side. Especially regarding access to Record Fields; something that will start failing on newer JDKs. It is not certain handling can be fully unified.\r\n\r\nI agree that it is important to be able to have value types, handling that works for both 2.14 and 2.15. But we really did not realize that there was Record usage that relied on explicit Visibility settings -- there's no testing so one can view at as unsupported use case, technically.\r\nAssumption rather was that usage wrt Records would use default visibility settings.\r\n\n\nComment by stolsvik:\n@cowtowncoder Thanks!\r\n\r\n> Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n\r\nyes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\n> Assumption rather was that usage wrt Records would use default visibility settings.\r\n\r\nThis is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\n\nComment by cowtowncoder:\n> > Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n> \r\n> yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\nRight... and which is why code originally was separate.\r\n\r\nI had plans to rewrite Introspection of POJOs, Records, but didn't have time so others had a chance to try out alternatives here.\r\n\r\n> > Assumption rather was that usage wrt Records would use default visibility settings.\r\n> \r\n> This is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\nSorry, I did not mean that as a justification for breaking things: but rather explanation of why this use case was not covered by tests. I understand it was used as a way to unify handling with 2.14 when there was no other way.\r\nI agree in that the same `ObjectMapper` should be usable.\r\n\r\nI'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?) and I think there's a way to change them separately as well. I just do not remember details.\r\n\r\n**EDIT**: I think I got confused with above: visibility checker defaults had to do with different defaults for JDK types, where we do NOT want to detect fields. Records (outside of JDK packages) not affected by that.\r\n\r\n\n\nComment by yihtserns:\n> This is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records...\r\n> ...I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the data transferred.\r\n\r\nTest result for `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` with `2.14.2`:\r\n\r\n| Mechanism (without annotations) | Serialization | Deserialization with non-empty JSON object | Deserialization with empty JSON object |\r\n|---|---|---|---|\r\n| No-arg constructor with getters & setters | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"0 known properties\" | \u2714 Successful: created empty instance |\r\n| Constructor creator | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"no Creators exist\" | \u274c Failed: \"no Creators exist\"\r\n| Record class | \u274c Empty JSON Object | \u2714 Successful: created instance using the JSON fields | \u2714 Successful: created instance using default values |\r\n\r\nThe only way the failing tests above can work is when `@JsonCreator`/`@ConstructorProperties` & `@JsonProperty` annotations are used on the constructor & fields, respectively.  @stolsvik is that what was done in your codebase?\n\nComment by yihtserns:\n> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n> I think there's a way to change them separately as well...\r\n\r\nThe only way I know is this:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n### Alternatives\r\n1. Annotate the override directly on the Records:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n2. Annotate `@JsonCreator` on the canonical compact constructor:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n> I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. **I feel it makes little sense to have to handle this differently**? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\n...which was the whole point of #3724's \"jamming records and POJOs into the same regime\", so that using Records is no (or not much) different from using POJO - the issue you're facing now is because Records & POJOs are handled similarly...\n\nComment by yihtserns:\n>> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n>[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n@cowtowncoder Do you think we should copy that to `2.15`?  E.g.:\r\n```\r\npublic abstract class MapperConfigBase ... {\r\n    ...\r\n    public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n        ...\r\n        if (ClassUtil.isJDKClass(baseType)) {\r\n            vc = VisibilityChecker.Std.allPublicInstance();\r\n        } else if (baseType.isRecord()) {\r\n            // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n            // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n\r\n            vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n        } else {\r\n            vc = getDefaultVisibilityChecker();\r\n        }\r\n        ...\r\n    }\r\n}\r\n```\n\nComment by stolsvik:\n@yihtserns:\r\n> is that what was done in your codebase?\r\n\r\nNo, as I said at top, I have both of:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\nThe full init is:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\n\r\n// Read and write any access modifier fields (e.g. private)\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n// Drop nulls\r\nmapper.setSerializationInclusion(Include.NON_NULL);\r\n\r\n// If props are in JSON that aren't in Java DTO, do not fail.\r\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n\r\n// Write e.g. Dates as \"1975-03-11\" instead of timestamp, and instead of array-of-ints [1975, 3, 11].\r\n// Uses ISO8601 with milliseconds and timezone (if present).\r\nmapper.registerModule(new JavaTimeModule());\r\nmapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\r\n\r\n// Handle Optional, OptionalLong, OptionalDouble\r\nmapper.registerModule(new Jdk8Module());\r\n```\r\nIt is here: https://github.com/centiservice/mats3/blob/main/mats-serial-json/src/main/java/io/mats3/serial/json/MatsSerializerJson.java#L120-L152 - now also with the attempt at handling the 5M chars-in-String limit.\r\n\r\n**Note: I had accepted that I always need a no-args constructor** (as opposed to GSON). (Note: If it is possible to support missing no-args constructor for a class, even with Java 17+, that would be *excellent*!)\r\n\r\n> the issue you're facing now is because Records & POJOs are handled similarly...\r\n\r\nExactly. Which is why I said: _\"yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\"_\r\n\r\nMy point is that the construction of a Record and of a Class, and their population of fields, are rather different, so it sounds .. ambitious .. to do it with the same codebase/flow? Note, I do not try to dictate anything here, it is just an observation. But it would be nice if this - as seen from my side - _regression_ - was not present!\n\nComment by yihtserns:\n> No, as I said at top, I had both of:\r\n> ```\r\n> ObjectMapper mapper = new ObjectMapper();\r\n> mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n> mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n> ```\r\n\r\nOK, was confused because it was commented out in the sample code.\r\n\r\nThat means you might actually have 2 problems:\r\n1. This issue for Records deserialization.\r\n2. #3895 for Records serialization.\n\nComment by stolsvik:\nYes, but I tried to mention:\r\n> Note that the commented-out mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY) is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nIt was an attempt to reduce the problem to the bare minimum.\n\nComment by yihtserns:\nTo summarize, there are 2 things broken when using this config:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\n## 1. For Records deserialization\r\nCaused by #3724 to make Records de/serialization behaves just like POJO de/serialization - it sees:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n...similarly to:\r\n```\r\npublic class RecordTest {\r\n    private String string;\r\n    private int integer;\r\n\r\n    @ConstructorProperties({\"string\", \"integer\"})\r\n    public RecordTest(String string, int integer) {\r\n        this.string = string;\r\n        this.integer = integer\r\n    }\r\n\r\n    public String getString() {\r\n        return this.string;\r\n    }\r\n\r\n    public String getInteger() {\r\n        return this.integer;\r\n    }\r\n}\r\n```\r\n### Fixes/workarounds\r\n1. Make all classes' constructor/factory method Creators visible:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NON_PRIVATE);\r\n```\r\n2. Make only Records' constructor/factory method Creators visible:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n3. Override visibility directly on the Record class:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n4. Override visibility of constructor Creator directly in the Record class:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n## 2. For Records serialization\r\nBroken by #3737 - Records serialization will always result in empty JSON hash (i.e. `{}`).\r\n\r\n#3894 to fix that is pending review.\n\nComment by yihtserns:\nAs for [changing Jackson to make Records' creators always visibility regardless of config](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532803630), I can/will create a PR if the core maintainers think that's the way to go.\n\nComment by stolsvik:\n=1. Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\n1.: Will this work identical for 2.14 and 2.15?  Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a _creator_, if this is what we're talking about?)\r\n2.: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which _might_ have a bunch of constructors that I do not want the serialization to touch?\r\n3. and 3. is utterly out of the question. _(I .. well .. despise ... implementation-specific annotations for serialization. The serialization used for this Mats3 library should be completely opaque to the user, the use of Jackson is literally an implementation detail which should never be thought about. Provide the Request and Reply DTOs, and I will make them \"magically\" transported. I would rather put in code that refused to start if there was any sign of such annotations present)_\r\n\r\nHowever, I can't shake the feeling that this is a pretty clear regression.\r\n\r\n=2:\r\nGood, thanks!\n\nComment by pjfanning:\n@yihtserns thanks for looking at this this. Let's not rush things. We will need to tackle one problem at a time. Maybe getting #3894 progressed is the first priority. @stolsvik will just have to be patient while we resolve the issues. Please stick with Jackson 2.14 in the interim - or try another library, if you prefer.\n\nComment by stolsvik:\nWell, I pretty obviously prefer Jackson, as otherwise I would probably not try to report this.\n\nComment by yihtserns:\n> Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\nNeed to wait for the [core maintainers to make the final decision](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532869817).\r\n\r\n> 1: Will this work identical for 2.14 and 2.15? Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a creator, if this is what we're talking about?)\r\n\r\nCreators are constructors or factory methods (with name `valueOf`) that have parameters, that will be used for deserialization - they are typically either annotated with `@JsonCreator` or \"magically\" chosen.\r\n\r\nThey are not related to, and nor will that config affects no-arg constructor.\r\n\r\n> 2: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which might have a bunch of constructors that I do not want the serialization to touch?\r\n\r\nYou can use this with both `2.14` & `2.15`, but it basically does nothing for `2.14` (because again, deserialization was implemented differently).  This is basically like number 1, except it only targets Record classes:\r\n```\r\nreturn ac.getType().isRecordType()                          // if we're deserializing Record class...\r\n    ? checker.withCreatorVisibility(Visibility.NON_PRIVATE) // ...make the Creators visible\r\n    : checker;                                              // ...leave the visibility as NONE for POJO types\r\n```\n\nComment by cowtowncoder:\n> > > I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n> \r\n> > [3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n> \r\n> @cowtowncoder Do you think we should copy that to `2.15`? E.g.:\r\n> \r\n> ```\r\n> public abstract class MapperConfigBase ... {\r\n>     ...\r\n>     public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n>         ...\r\n>         if (ClassUtil.isJDKClass(baseType)) {\r\n>             vc = VisibilityChecker.Std.allPublicInstance();\r\n>         } else if (baseType.isRecord()) {\r\n>             // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n>             // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n> \r\n>             vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n>         } else {\r\n>             vc = getDefaultVisibilityChecker();\r\n>         }\r\n>         ...\r\n>     }\r\n> }\r\n> ```\r\n\r\nHmmmh. I am bit hesitant wrt overriding users' explicit settings but it does make some sense -- esp. since that's in 3.0.\r\nThe main question would be whether to do that in 2.15.1 or 2.16(.0).\r\nIf (and only if) this would resolve issues we face wrt 2.14->2.15 changes, I'd say let's do it for 2.15(.1).\r\nAlso requires making sure we have good test coverage.\n\nComment by cowtowncoder:\nI merged #3894 fwtw; shouldn't (I think) affect this issue but just in case.\n\nComment by stolsvik:\nJust a comment from the side:\r\n\r\n>  I am bit hesitant wrt overriding users' explicit settings but it does make some sense\r\n\r\nI agree to the general idea that this seems just wrong, but somehow you need to get to those constructors to actually be able to make records! Another way could be a special-case \"if\" when about to create a record, that _effectively_ ignored the setting by just finding the canonical constructor in spite of the setting. However, you would at least not just \"overwrite\" the user-set setting?!\n\nComment by cowtowncoder:\n@stolsvik Yeah this is the challenge in using same logic, handling as with POJOs, when rules are bit different (Records having clear, well-defined rules of what constitutes canonical Constructor, what properties exist).\r\nI'll get #3910 merged and we'll see how far we might get.\r\n\r\n@yihtserns I think we should go with the patch you suggest to unblock remaining issues.\r\n\n\nComment by stolsvik:\nNote: I had to adjust the suggestion a bit to get the \"only adjust visibility for records\" to work: The `ac.getType()` could apparently return null.\r\n\r\n```java\r\npublic VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n    if (ac.getType() == null) {\r\n        return checker;\r\n    }\r\n    if (!ac.getType().isRecordType()) {\r\n        return checker;\r\n    }\r\n    // If this is a Record, then increase the \"creator\" visibility again\r\n    return checker.withCreatorVisibility(Visibility.ANY);\r\n}\r\n```\n\nComment by stolsvik:\nAnother comment from the side: I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the NON_PRIVATE part. If I understand this correctly, it would then not find a private record with private constructor? (Visibility of a record's canonical constructor cannot be less than visibility of the record itself - but a record can be private?)\n\nComment by yihtserns:\n> ...a record can be private?\r\n\r\nYes:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private record RecordTest(String string, int integer) {\r\n    }\r\n}\r\n```\r\n...will be compiled into:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private static record RecordTest(String string, int integer) {\r\n        private RecordTest(String string, int integer) {\r\n            this.string = string;\r\n            this.integer = integer;    \r\n        }\r\n\r\n        public String string() {\r\n            return this.string;\r\n        }\r\n\r\n        public String integer() {\r\n            return this.integer;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> ...I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the `NON_PRIVATE` part...\r\n\r\nI just copied that directly from 3.x codebase.  In hindsight, I should've changed that to `Visibility.ANY` to make it simple (and practical).  \ud83d\ude1e\n\nComment by cowtowncoder:\nI do not remember details here, but it is possible the idea was to avoid exposing `private` constructors, thinking that they are private for reason (but that there are other non-private constructors). For regular POJOs only public constructors are auto-detected; although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?) and other constructors (use configured visibility) would make most sense.\r\nBut once that runs counter to trying to make Records work just like POJOs.\r\n\n\nComment by stolsvik:\n> .. although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?)\r\n\r\nTotally agree. You need to create an instance. That I have chosen to make this DTO-record an inner private entity of whatever service class it resides in, shouldn't make any difference.\n\nComment by cowtowncoder:\n@yihtserns I think fix you suggested would be doable (just need to change check to use `ClassUtil.isRecordType(baseType)` since `Class.isRecord()` is not available on JDK 8).\r\nI think I'll create a PR.\n\nComment by cowtowncoder:\nNote: need to figure out what (if anything) to do with 3.0 (master); 2 failing tests left.\r\nThis due to `MapperFeature.AUTO_DETECT_CREATORS` being removed so specific workaround cannot be used.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Regression: 2.15.0 breaks deserialization for records when mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);",
                "name": "issue#3906",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    }
                ],
                "similarity": 0.41756457667451097,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4105",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nIn 2.14.x a record could be deserialized without any annotations and dummy default constructor with permissive Field visibility.\r\nRelease 2.15.x changed this behavior with I assume https://github.com/FasterXML/jackson-databind/issues/3736\r\n\r\nIt was very handy to be able to deserialize records without any further ceremony.\r\n\r\nAs it stands we cannot upgrade to 2.15.x without introducing a lot of boilerplate to our records - or is there a configuration option I have missed?\r\n\r\n\r\n### Version Information\r\n\r\n2.15.x\r\n\r\n### Reproduction\r\n\r\n```\r\nObjectMapper mapper = new ObjectMapper().setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\r\nrecord Qwop(String q) {}\r\nfinal Qwop qwop = new Qwop(\"\");\r\nfinal String s = mapper.writer().writeValueAsString(qwop);\r\nfinal Qwop o = mapper.reader().forType(Qwop.class).readValue(s);\r\n```\r\n\r\n### Expected behavior\r\n\r\nExpected record deserialization to work with field visibility as in 2.14.x\r\n\n\n\nComment by yihtserns:\nTested with:\r\n```java\r\npublic class JacksonDatabind4105Test {\r\n\r\n    @Test\r\n    public void test() throws Exception {\r\n        ObjectMapper mapper = new ObjectMapper().setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\r\n        System.out.println(\"Jackson: \" + mapper.version());\r\n\r\n        record Qwop(String q) {}\r\n        final Qwop qwop = new Qwop(\"\");\r\n\r\n        final String s = mapper.writer().writeValueAsString(qwop);\r\n        System.out.println(\"JSON: \" + s);\r\n\r\n        final Qwop o = mapper.reader().forType(Qwop.class).readValue(s);\r\n        System.out.println(\"Record: \" + o);\r\n    }\r\n}\r\n```\r\n\r\nSystem.out for `jackson-databind:2.14.2`:\r\n```\r\nJackson: 2.14.2\r\nJSON: {\"q\":\"\"}\r\nRecord: Qwop[q=]\r\n```\r\nSystem.out for `jackson-databind:2.15.0`:\r\n```\r\nJackson: 2.15.0\r\nJSON: {\"q\":\"\"}\r\nRecord: Qwop[q=]\r\n```\r\n\r\nCan you provide a more detailed example to demonstrate the issue, please?\n\nComment by aelgn:\nI'm sorry, when I simplified my code for the github issue I inadvertently removed an ObjectMapper configuration that seems to be the culprit:\r\n```\r\nfinal ObjectMapper mapper = new ObjectMapper()\r\n                .setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)\r\n                .setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\r\n```\r\nSetting ALL visibility to NONE and then overriding FIELD to ANY the classic InvalidDefinitionException is thrown:\r\n`com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of a.b.c$1Qwop (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)`\r\n\r\nI have now tested the various visibilities and can conclude that in 2.15.x non-annotated records without a default constructor can be deserialized with the configuration:\r\n```\r\nfinal ObjectMapper mapper = new ObjectMapper()\r\n                .setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)\r\n                .setVisibility(PropertyAccessor.GETTER, JsonAutoDetect.Visibility.ANY)\r\n                .setVisibility(PropertyAccessor.CREATOR, JsonAutoDetect.Visibility.ANY);\r\n```\r\n\r\nSo it seems like the \"breaking\" change in 2.15.x is that records are not deserialized with FIELD but with CREATOR + GETTER instead. This is great news, since this is easily configured - but might need documentation to avoid pesky runtime surprises.\r\n\r\nLeaving this issue open for someone to evaluate if this is the preferred behavior and/or needs documentation.\n\nComment by aelgn:\nI am a bit confounded over the need to make GETTERs visible to be able to deserialize records. This change breaks our class based dto:s.\r\n\r\nTo minimize ceremony we are using the ParameterNamesModule for class deserialization, with a `@JsonCreator` constructor matching the fields. Turning on GETTER visibility introduces a lot of unserializable json given DTO:s with computed properties.\r\n```\r\nstatic class Plopp {\r\n    final String p;\r\n    @JsonCreator\r\n    Plopp(final String p) {\r\n        this.p = p;\r\n    }\r\n    int getL() {\r\n        return p.length();\r\n    }\r\n}\r\npublic static void main(final String[] args) {\r\n    try {\r\n        final ObjectMapper mapper = new ObjectMapper()\r\n            .setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)\r\n            .setVisibility(PropertyAccessor.GETTER, JsonAutoDetect.Visibility.ANY)\r\n            .setVisibility(PropertyAccessor.CREATOR, JsonAutoDetect.Visibility.ANY)\r\n            .setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY)\r\n            .registerModule(new ParameterNamesModule());\r\n        System.out.println(\"Jackson: \" + mapper.version());\r\n        record Qwop(String q) {}\r\n        final Qwop qwop = new Qwop(\"q\");\r\n        final Plopp plopp = new Plopp(\"p\");\r\n\r\n        {\r\n            final String s = mapper.writer().writeValueAsString(qwop);\r\n            System.out.println(\"ser: \" + s);\r\n            final Object o = mapper.reader().forType(Qwop.class).readValue(s);\r\n            System.out.println(\"des: \" + o);\r\n        }\r\n        {\r\n            final String s = mapper.writer().writeValueAsString(plopp);\r\n            System.out.println(\"ser: \" + s);\r\n            final Object o = mapper.reader().forType(Plopp.class).readValue(s);\r\n            System.out.println(\"des: \" + o);\r\n        }\r\n    } catch (final JsonProcessingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}\r\n```\r\n\r\nIt seems like the types `Qwop` and `Plopp` cannot be deserialized with the same ObjectMapper anymore (since 2.15.x).\r\nQwop deserialization now requires GETTER visibility, but this visibility breaks Plopp deserialization.\r\n\r\n`.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)`\r\nOne workaround to get the above code to run is to ignore all unknown properties - but this is not preferable. And since the GETTER is still visible in serialization the produced json will in best case include properties that are not meant for serialization and in worst case throw exception when the returned type is unserializable.\n\nComment by yihtserns:\nAbout the visibility config problem above, there are 2 issues here:\r\n1. Serialization produces empty JSON (i.e. `{}`):\r\n    - Caused by #3737 (in `2.15.0`)\r\n    - Fixed by #3894 (in `2.15.1`).\r\n3. Deserialization failed because \"no creator\" found:\r\n    - Caused by #3724 (in `2.15.0`)\r\n    - Previously reported by #3906.\r\n    - Workaround: `.setVisibility(PropertyAccessor.CREATOR, JsonAutoDetect.Visibility.ANY)`\n\nComment by aelgn:\nThank you, that is great.\r\nI can confirm that from 2.15.1 GETTER visibility is no longer needed for deserializing \"simple\" records. CREATOR visibility is however still needed - which is absolutely fine by me since it does not alter our other serialization (that I know of).\n\nComment by cowtowncoder:\nThank you @aelgn, @yihtserns for trouble-shooting this. I know Record-handling changes have been frustrating wrt 2.15, but I hope we are in net-positive situation wrt improvements and resolving some (if not all) regressions.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Record deserialization bug/breaking change in 2.15",
                "name": "issue#4105",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4105"
                    }
                ],
                "similarity": 0.41707056416114024,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "171",
                "type": "issue",
                "content": "According to the documentation,\n\n> Annotation used to indicate that a property should be serialized \"unwrapped\"; that is, if it would be serialized as JSON Object, its properties are instead included as properties of its containing Object.\n\nUnfortunately, this seems to work only with bean types, and does not work with `Map<String, Object>`.  Given that bean types are generally completely interchangeable with Maps, it would be very nice if this worked correctly.\n\n\n\nComment by cowtowncoder:\nHmmh. Unfortunately Maps and POJOs are internally handled rather differently. But I am all for unification if it is technically possible, so limitation is not philosophical, just practical. I suspect that serialization part should be easy enough to make work; deserialization might get trickier?\n\n\nComment by stevenschlansker:\nIt would be very cool if this worked :smile: \n\n\nComment by cowtowncoder:\n:-)\n\nOne quick question: I assume most users would expect it to work both ways. But I suspect serialization is much easier to make work. Would you find any value in serialization-only impl? (especially initial one)\n\nOne more thing: as per this:\n\nhttp://www.cowtowncoder.com/blog/archives/2011/07/entry_458.html\n\none can use @JsonAnyGetter/setter to do something possibly similar. One missing pieces is that currently one must have getter (can't use it on Map filed), but that should be easy enough to address.\n\n\nComment by stevenschlansker:\nYes, a serialization-only implementation would solve my immediate use case, although I can see the deserialization as being extremely useful as well.\n\nIt does seem that this could potentially be done with serialization-only JsonUnwrapped usage and then JsonAnySetter to handle the deserialization case, although that feels more than a little bit janky to me.\n\n\nComment by cowtowncoder:\nYes my concern is really with unexpected one-way street: unwrapping on way out, but not \"wrapping it back\" as Map on way back in.\n\n\nComment by cowtowncoder:\nOk, I think supporting this would be very useful for CSV, f.ex see https://github.com/FasterXML/jackson-dataformat-csv/issues/25\nso maybe I should go back, try to tackle this.\n\nAlthough, with CSV there are other open questions due to name/index mapping. But still, solving this on databind side could help.\n\n\nComment by mmadson:\n+1\n\n\nComment by igorcadelima:\n+1\n\n\nComment by cowtowncoder:\nA related note for anyone who happens upon this issue: one alternative is use of `@JsonAnyGetter`, which does allow functionality for a single `Map`.\n\n\nComment by igorcadelima:\nGreat! `@JsonAnyGetter` is exactly what I was looking for. Thanks!\n\n\nComment by ghost:\nI find this behavior surprising at a conceptual level, since it seems to be contrary to how Jackson behaves in general.\r\n\r\nWould I be correct in assuming that this is one of the features that will likely not be in the next Jackson 2.9 release, per the [Changes likely to be postponed](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9#changes-likely-to-be-postponed) section?\n\nComment by cowtowncoder:\n@matthew-pwnieexpress You are correct in that no work is planned for this feature.\r\nI can see how this is unexpected from users perspective: difference is due to technical evolution of backend implementation where Maps and POJOs have very different handling. But conceptually this should not surface quite this strongly, or, if it does, would need to be explained and documented much better.\r\n\n\nComment by henryptung:\n@cowtowncoder Given that `@JsonAnyGetter` and `@JsonAnySetter` exist, how correct/incorrect would an implementation be to have `@JsonUnwrapped` imply the other two annotations when used with `MapSerializer`?\n\nComment by cowtowncoder:\n@henryptung Interesting thought... hmmh. There is also then the possible question of what if more than one such \"any property\" is declared.\r\nI guess this is not problematic with POJOs as their properties are somewhat defined and multiples unwrapped POJOs may co-exist; whereas any-x is fallback.\r\n\n\nComment by marceloverdijk:\nUnfortunately the @JsonAnyGetter does not work (easily) with Kotlin:\r\n\r\n```\r\nclass Links(\r\n        @JsonAnyGetter\r\n        val links: Map<String, Link>\r\n) : Serializable\r\n\r\n```\r\n\r\nas the annotation needs to put on a method.\r\n\r\n**!! UPDATE !!**\r\n\r\nIt does work (easily):\r\n\r\n```\r\nclass Links(\r\n        @get:JsonAnyGetter\r\n        val links: Map<String, Link>\r\n) : Serializable\r\n\r\n```\r\n\r\n\n\nComment by cowtowncoder:\nTrue; as of now (2.9), `@JsonAnyGetter` must be on method. In theory it could be extended to fields, to allow construction of `Map` instance. One challenge would be the fact that semantics would be slightly different -- in one case method gets fed key/value pair: that could lead to confusion (unless logic further added to perhaps also allow single Map-argument... but that can lead to another can of worms).\r\n\r\n**EDIT** (2023-05-15): `@JsonAnyGetter` is available on Fields too (see #1458) since 2.12.\r\n\n\nComment by odrotbohm:\nWe face the challenge that we provide a wrapper type for some content object that could either be a custom object *or* a `Map`:\r\n\r\n```java\r\nclass SomeWrapper<T> {\r\n\r\n  T content;\r\n\r\n  @JsonUnwrapped\r\n  public getContent() {\r\n    return content;\r\n  }\r\n}\r\n```\r\n\r\nIs there something we could do using a custom serializer to not have to add the extra method or extra class?\n\nComment by cowtowncoder:\n@odrotbohm I can't think of anything: `@JsonUnwrapped` is quite tied to way BeanSerializer and -Deserializer works and although one can override handlers I am not sure custom (de)serializer route would lead to anything but fragile solution.\n\nComment by odrotbohm:\nI have a POC with the following steps:\r\n\r\n- register a custom `StdSerializer<SomeWrapper>`\r\n- in that, inspect the content. If it's a `Map` take the content and wrap it into a type using `@JsonAnyGetter`, default serialize that. If no, wrap into an almost copy of `SomeWrapper` using a plain `@JsonUnwrapped`\r\n\r\nThat way, `SomeWrapper` stays the only user facing API but does the right thing\u2122 during serialization.\n\nComment by mjustin:\nIncidentally, [the Stack Overflow question for this issue](https://stackoverflow.com/questions/18043587) has 46 upvotes, and its top answer has 101 upvotes, so this is definitely an issue users have been encountering.\n\nComment by cowtowncoder:\nOk, marking this as \"most-wanted\" as there are a few thumbs-ups here too.\r\n\r\nAbout the only question I have is whether there are some specific differences between just using `@JsonAnyGetter`/`@JsonAnySetter` combo, and potential `@JsonUnwrapped`.\r\nUsing one less annotation seems like nice-but-not-essential; consistency a minor plus too.\r\nOr put another way: if `@JsonUnwrapped` was essentially implemented as sort of alias for \"any-getter\", would that work?\r\n(another potential concern: can only have one \"any getter/setter\" per class -- but multiple `@JsonUnwrapped`s)\r\n\r\n\n\nComment by Vroo:\nIt's also very surprising it doesn't work for ObjectNodes, e.g., the trivial case `JsonNodeFactory.instance.objectNode().put(\"sample\", 1)`. I would guess that's because under the covers, ObjectNode is a map, but to someone writing that code, it's just a json object. And the `@JsonAnyGetter` trick doesn't work for this.\n\nComment by cowtowncoder:\n@Vroo Conceptually, `JsonNode` types are not POJOs, so most annotations do not have any effect by design. It would be good to document this better as I can see why it might be surprising... there isn't much documentation on concept, intended differences. In fact, POJOs, \"untyped\" (Object / List / Map), Trees (JsonNode) are all somewhat different models within Jackson, and while they interoperate fine, they are not treated the same way.\r\n\r\n\n\nComment by cowtowncoder:\n@Vroo that said, I can see why specific cases of `@JsonAnyGetter`/`@JsonAnySetter` would make sense for `JsonNode`/`ObjectNode` values -- if so, feel free to file an issue to add support for that usage.\r\n\r\n`@JsonUnwrapped` is a bit trickier just because the whole machinery for it to work is... rather complicated and fragile: you could file an issue for that, too (since adding support for `Map`s would be technically different from `JsonNode`; there isn't much synergy in getting both implemented)\r\n\n\nComment by Druckles:\n> About the only question I have is whether there are some specific differences between just using `@JsonAnyGetter`/`@JsonAnySetter` combo, and potential `@JsonUnwrapped`.\r\n> ...\r\n> Or put another way: if `@JsonUnwrapped` was essentially implemented as sort of alias for \"any-getter\", would that work?\r\n\r\nI have the same problem as @odrotbohm: `@JsonUnwrapped` sits on top of a generic. To get it to work, I've needed to create subclass that overrides the getter so I can add `@JsonAnyGetter`. The any-getter doesn't work because it's of type `T`, not a `Map` and it throws an error during runtime otherwise.\r\n\r\nThis creates other problems because I've subclassed it. Being able to use `@JsonUnwrapped` would be much easier, cleaner and safer.\n\nComment by Akaame:\nI had a go about this and could get Unwrapping aspect working. The `JsonSerializer<T>` has a `unwrappingSerializer`  method that is called within `UnwrappingBeanPropertyWriter` that sort of lifts the serializer into a unwrapping serializer. When we try to serialize a Map instance a `MapSerializer` is responsible for the serialization step. Overriding `unwrappingSerializer` for `MapSerializer` to create a `UnwrappingMapSerializer` should give us what we want.\r\n\r\n\r\n```java\r\n@Override\r\npublic JsonSerializer<Map<?, ?>> unwrappingSerializer(NameTransformer transformer) {\r\n    return new UnwrappingMapSerializer(this, transformer);\r\n}\r\n```\r\n\r\nThe sole responsibility of an `UnwrappingMapSerializer` is making MapSerializer's `keySerializer` an unwrapping serializer.\r\n\r\n```java\r\nthis._keySerializer = this._keySerializer.unwrappingSerializer(transformer);\r\n```\r\n\r\nThis changes the result of `TestUnwrappedMap171.testMapUnwrapSerialize`\r\n\r\n```\r\njunit.framework.ComparisonFailure: \r\nExpected :{\"map.test\": 6}\r\nActual   :{\"test\":6}\r\n```\r\n\r\nAs you can see unwrapping worked but the name transformer did not have any effect as `StdKeySerializers` do not have a `rename` concept as `BeanPropertyWriter`s do. \n\nComment by fprochazka:\nHi, I'd like to add here my use-case:\r\n\r\n<details>\r\n  <summary>ugly <code>Data</code></summary>\r\n  \r\n```java\r\n@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)\r\npublic static final class Data\r\n{\r\n\r\n    @JsonProperty(\"Status\")\r\n    private String status;\r\n\r\n    @JsonAnyGetter\r\n    private Map<String, Object> otherFields = new LinkedHashMap<>();\r\n\r\n    public Data(\r\n        final String status,\r\n        final Map<String, Object> otherFields\r\n    )\r\n    {\r\n        this.status = status;\r\n        this.otherFields = otherFields;\r\n    }\r\n\r\n    public Data()\r\n    {\r\n    }\r\n\r\n    @JsonAnySetter\r\n    public void anySetter(final String key, final Object value)\r\n    {\r\n        otherFields.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object o)\r\n    {\r\n        if (this == o) {\r\n            return true;\r\n        }\r\n        if (!(o instanceof Data data)) {\r\n            return false;\r\n        }\r\n        return status.equals(data.status) && otherFields.equals(data.otherFields);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode()\r\n    {\r\n        return Objects.hash(status, otherFields);\r\n    }\r\n\r\n    @Override\r\n    public String toString()\r\n    {\r\n        return \"{status='\" + status + '\\'' + \", otherFields=\" + otherFields + '}';\r\n    }\r\n\r\n}\r\n```\r\n</details>\r\n\r\n\r\n<details>\r\n  <summary>pretty <code>Data</code></summary>\r\n  \r\n```java\r\npublic record Data(\r\n    @JsonProperty(\"Status\") String status,\r\n    @JsonUnwrapped Map<String, Object> otherFields\r\n)\r\n{\r\n\r\n}\r\n```\r\n</details>\r\n\r\n\r\n\r\n<details>\r\n  <summary><code>OtherFieldsJacksonTest</code></summary>\r\n  \r\n```java\r\nclass OtherFieldsJacksonTest\r\n{\r\n\r\n    private final ObjectMapper jsonObjectMapper = Jackson2ObjectMapperBuilder.json()\r\n        .featuresToEnable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\r\n        .build();\r\n\r\n    @Test\r\n    public void serialize() throws Exception\r\n    {\r\n        var other = new LinkedHashMap<String, Object>();\r\n        other.put(\"list\", List.of(1, 2, 3));\r\n        other.put(\"Id\", \"1234\");\r\n        other.put(\"object\", Map.of(\"foo\", \"1234\"));\r\n        Data input = new Data(\"Ok\", other);\r\n\r\n        String result = jsonObjectMapper.writeValueAsString(input);\r\n\r\n        String expected = \"{\\\"Status\\\":\\\"Ok\\\",\\\"list\\\":[1,2,3],\\\"Id\\\":\\\"1234\\\",\\\"object\\\":{\\\"foo\\\":\\\"1234\\\"}}\";\r\n\r\n        Assertions.assertEquals(expected, result);\r\n    }\r\n\r\n    @Test\r\n    public void deserialize() throws Exception\r\n    {\r\n        String json = \"{\\\"Status\\\":\\\"Ok\\\",\\\"object\\\":{\\\"foo\\\":\\\"1234\\\"},\\\"Id\\\":\\\"1234\\\",\\\"list\\\":[1,2,3]}\";\r\n\r\n        Data result = jsonObjectMapper.readValue(json, Data.class);\r\n\r\n        var other = new LinkedHashMap<String, Object>();\r\n        other.put(\"list\", List.of(1, 2, 3));\r\n        other.put(\"Id\", \"1234\");\r\n        other.put(\"object\", Map.of(\"foo\", \"1234\"));\r\n        Data expected = new Data(\"Ok\", other);\r\n\r\n        Assertions.assertEquals(expected, result);\r\n    }\r\n\r\n}\r\n```\r\n</details>\r\n\r\nThe test passes with \"ugly Data\", but obviously not with \"pretty Data\". \r\n\r\nI'd like to collect the extra fields into a separate Map, then do some work with the data object, then serialize it back to json string. I don't need them for anything, but I want to preserve them if I later decide I do need them.\r\n\r\n-----\r\n\r\nWhen I define the record like this, the serialization works as expected and deserialization doesn't throw errors, but it puts `null` into the `otherFields` field.\r\n\r\n<details>\r\n  <summary>pretty <code>Data</code></summary>\r\n  \r\n```java\r\npublic record Data(\r\n    @JsonProperty(\"Status\") String status,\r\n    @JsonUnwrapped @JsonAnyGetter @JsonAnySetter Map<String, Object> otherFields\r\n)\r\n{\r\n\r\n}\r\n```\r\n</details>\r\n\r\n----\r\n\r\nI've done some more googling and this is basically the same https://github.com/FasterXML/jackson-databind/issues/3439#issue-1190261041, sorry for a duplicate post \n\nComment by cowtowncoder:\n@fprochazka Please don't add things that are not relevant for the specific issues. For usage questions, mailing list:\r\n\r\n   https://groups.google.com/g/jackson-user\r\n\r\nworks wonders. For issues to report, file a new one UNLESS you have something specific to add into existing one.\r\n\n\nComment by fprochazka:\n@cowtowncoder sorry, I thought it is relevant to this issue, since I didn't find the sample anywhere previously \n\nComment by cowtowncoder:\nHmmh. Well, looking at it, it's a more complicated case where `Record` is also problematic, as well as any setter -- I guess my point was that it does not help solve the basic problem wrt `Map` valued properties.\r\nBut I understand you wanted to help with additional information so I guess that is ok.\r\n\n\nComment by cowtowncoder:\nThinking about this more I think that as things are, it really SHOULD be possible to just use `@JsonAnyGetter` and `@JsonAnySetter` combo to achieve the same result as non-prefixed `@JsonUnwrapped`, wrt `Map`s.\r\n`@JsonAnySetter` also works for `JsonNode` (although `@JsonAnyGetter not yet, see #3604).\r\nBoth annotations can be used on fields and methods and you only need to annotate one of the accessors (setter OR getter, not both).\r\n\r\nBecause of this, I am leaning towards closing this as \"will-not-fix\". But will not do that quite as yet.\r\n\r\nNote, too, that it is perfectly possible to add features (like use of \"prefix\") to `@JsonAnyGetter`/`@JsonAnySetter`.\r\n\r\n\n\nComment by agorbachenko:\n> Hi, I'd like to add here my use-case:\r\n> \r\n> ugly `Data`\r\n> pretty `Data`\r\n> `OtherFieldsJacksonTest`\r\n> The test passes with \"ugly Data\", but obviously not with \"pretty Data\".\r\n> \r\n> I'd like to collect the extra fields into a separate Map, then do some work with the data object, then serialize it back to json string. I don't need them for anything, but I want to preserve them if I later decide I do need them.\r\n> \r\n> When I define the record like this, the serialization works as expected and deserialization doesn't throw errors, but it puts `null` into the `otherFields` field.\r\n> \r\n> pretty `Data`\r\n> I've done some more googling and this is basically the same [#3439 (comment)](https://github.com/FasterXML/jackson-databind/issues/3439#issue-1190261041), sorry for a duplicate post\r\n\r\nHi! @fprochazka, you can try to solve this for your \"pretty Data\" with a static method annotated with @JsonCreator:\r\n\r\n```\r\npublic record Data(\r\n    @JsonProperty(\"Status\") String status,\r\n    @JsonAnyGetter Map<String, Object> otherFields\r\n) {\r\n        @JsonCreator\r\n        public static Data create(Map<String, Object> attributes) {\r\n            Object status = attributes.remove(\"Status\");\r\n            assert status instanceof String;\r\n            return new Data((String) status, attributes);\r\n        }\r\n}\r\n```\n\nComment by fprochazka:\n@agorbachenko thanks for the alternative, it's much nicer than my first example, but I don't like it either; I've already solved it, see: https://github.com/FasterXML/jackson-databind/issues/3439#issuecomment-1204394289, until jackson has native support for this, I'm content using my hack.\n\nComment by cowtowncoder:\nAlthough there may be some aspects where `@JsonAnyGetter` won't work -- f.ex, inability to use more than 1 per POJO -- I think it has big enough overlap that I will close this issue as \"wont-fix\" (allowing multiple `@JsonAnyGetter`s is a possibility if someone has time to work on doing that).\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "@JsonUnwrapped not supported for Map-valued properties",
                "name": "issue#171",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3439"
                    },
                    {
                        "start_node": "issue#3439",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#171"
                    }
                ],
                "similarity": 0.4072683177866502,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4631",
                "type": "issue",
                "content": "Reverts FasterXML/jackson-databind#4627\n\n\nComment by cowtowncoder:\ncc @yihtserns @k163377 ",
                "source_code": null,
                "distance": 0.5,
                "title": "Revert \"Ignore Records' immutable fields in BeanDeserializerFactory instead of ignoring it in POJOPropertiesCollector, to preserve any annotation info the fields may be carrying.\"",
                "name": "pr#4631",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4631"
                    }
                ],
                "similarity": 0.40191742972855327,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4626",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\n`@JsonIgnore` on a Record component is ignored when the corresponding accessor method is overridden.\r\n\r\n### Version Information\r\n\r\nSince `2.15.0`.\r\n\r\n### Reproduction\r\n\r\n```java\r\nrecord RecordWithJsonIgnore(int id, @JsonIgnore String name) {\r\n    @Override\r\n    public String name() {\r\n        return name;\r\n    }\r\n}\r\n\r\nRecordWithJsonIgnore deser = new ObjectMapper().readValue(\"{\\\"id\\\":123,\\\"name\\\":\\\"Bob\\\"}\", RecordWithJsonIgnore.class);\r\n\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError: \r\n// Expected :RecordWithJsonIgnore[id=123, name=null]\r\n// Actual   :RecordWithJsonIgnore[id=123, name=Bob]\r\nassertEquals(new RecordWithJsonIgnore(123, null), deser);\r\n```\r\n\r\n### Expected behavior\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\nThere are typically 3 places to get an annotation info from:\r\n<table>\r\n<thead>\r\n<tr>\r\n  <th>Where</th>\r\n  <th>For this scenario</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>Constructor parameter</td>\r\n<td>Can't have <code>@JsonIgnore</code> info because <code>@JsonIgnore</code>'s <code>@Target</code> does not include <code>ElementType.PARAMETER</code> <strong>UPDATE</strong>: Forgot to mention that the hardcoded <code>prop.addCtor(..., false)</code> in <code>POJOPropertiesCollector</code> also needs to be changed for this to work.</td>\r\n</tr>\r\n<tr>\r\n<td>Accessor method</td>\r\n<td>When overridden, <code>@JsonIgnore</code> will not be \"inherited\" from original method</td>\r\n</tr>\r\n<tr>\r\n<td>Field</td>\r\n<td>#3737 removed field info for deserialization, so it can't contribute the <code>@JsonIgnore</code> info</td>\r\n</tr>\r\n</tbody>\r\n</table>\n\n\nComment by cowtowncoder:\nSidenote: created https://github.com/FasterXML/jackson-annotations/issues/258 to allow `@JsonIgnore` on constructor parameters (regardless of what happens here), implemented.",
                "source_code": null,
                "distance": 0.5,
                "title": "`@JsonIgnore` on Record property ignored for deserialization, if there is getter override",
                "name": "issue#4626",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4626"
                    }
                ],
                "similarity": 0.40111919678948255,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4452",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nSerialization of java records do not appear to be honoring `@JsonProperty` names in `@JsonCreator` constructors. \r\n\r\n\r\n### Version Information\r\n\r\n2.15.x+\r\n\r\n### Reproduction\r\n\r\nA test below fails for me and I expect it to pass.\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this.testFieldName = testFieldName;\r\n            this.testOtherField = testOtherField;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nThe field is renamed to what is specified in the `@JsonProperty` annotation in the record's `@JsonCreator`\r\n\r\n### Additional context\r\n\r\nWe encountered this upgrading from 2.14.x up to 2.16.x, so this functionality was working at that earlier version (perhaps before records were really addressed). \r\n\r\nPerhaps we have versions incorrect between jackson modules and libraries, but we haven't found the exact mismatch yet.\n\n\nComment by yihtserns:\nTested using `2.14.2` - not working.  But it's amazing that it ever worked at all because annotating on constructor arguments will only produce this compiled code:\r\n```java\r\npublic static record TestObject(String testFieldName, Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(@JsonProperty(\"strField\") String testFieldName, @JsonProperty(\"intField\") Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\r\n...the `@JsonProperty` annotation won't be propagated to the field & accessor method since Java doesn't know which constructor argument is associated with which field/accessor.\r\n\r\nOnly by annotating in the Record's header i.e.:\r\n```java\r\npublic static record TestObject(@JsonProperty(\"strField\") String testFieldName, @JsonProperty(\"intField\") Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(String testFieldName, Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\r\n...will a usable compiled code be produced:\r\n```java\r\npublic static record TestObject(String testFieldName, Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(String testFieldName, Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    @JsonProperty(\"strField\")\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    @JsonProperty(\"intField\")\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\n\nComment by Incara:\nYeah, I think we've figured out this test specifically doesn't work on any version. We're not sure why it works for us with our application's old dependency combination. I don't know if it's something about the parameter names module or properties on the spring `ObjectMapper` injected at runtime that allows it to be possible. \r\n\r\nIs this something that is intended to be supported or is it a requirement that `@JsonProperty` annotations must appear in the record declaration?\n\nComment by yihtserns:\nIf the `ObjectMapper` is created with:\r\n- `.registerModule(new ParameterNamesModule())`, or\r\n- `.findAndRegisterModules()` with `jackson-module-parameter-names` in the classpath\r\n\r\n...then it'll work but I think that's more of a happy coincidence that worked because the constructor argument names happen to match the property (field/accessor) names.  And that's now broken in `2.16.0` (works OK in `2.15.4`).\r\n\r\nI'm not entirely sure, but I vaguely remember seeing an issue talking about names...  But I'm not gonna dig further since I'm just here to make sure it wasn't my contribution from 1 year ago that caused this - imma leave this to the core maintainers.\r\n\r\n\ud83c\udfc3\u200d\u2640\ufe0f\ud83d\udca8\n\nComment by Incara:\nMuch appreciated, this helps with analysis for sure. I think that narrows this down to something changed between `2.15.4` and `2.16.0` and now it doesn't seem like `@JsonProperty` renames are honored on `@JsonCreator` in `record`s. The below works in `2.15.4` but fails in `2.16.0`:\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this.testFieldName = testFieldName;\r\n            this.testOtherField = testOtherField;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nFor now, our solution is to eliminate our `@JsonCreator`s on `record`s in favor using `@JsonProperty` directly on the record definition attributes since there is larger support in jackson for `record`s since we last updated.\r\n\r\nI don't know if there is supposed to be support for the above test case from the repo maintainers, but I will also stop and let them comment. \n\nComment by JooHyukKim:\nSo as per [release note](https://github.com/FasterXML/jackson-databind/blob/2.18/release-notes/CREDITS-2.x) there seem to be these three PRs --#3906, #3992, #4175 -- that are titled with the word `record` in it. Other than that, there is a long list of updates that got included in 2.16.0 release.\n\nComment by yihtserns:\n> ...titled with the word `record` in it.\r\n\r\nI don't think this thing is Record-specific.\n\nComment by JooHyukKim:\nBecause of project's current on-going milestone aka `Property Introspection Rewrite` (also mentioned in [2.17](https://groups.google.com/d/msgid/jackson-dev/CAL4a10gtvE9_X78DtEBpyA%3DV_0WjrxgpzJ9kUif_aBLKRu-noQ%40mail.gmail.com)), we neither can have have fix any time soon nor confidently specify how record should behave.\n\nComment by Incara:\n> Because of project's current on-going milestone aka `Property Introspection Rewrite` (also mentioned in [2.17](https://groups.google.com/d/msgid/jackson-dev/CAL4a10gtvE9_X78DtEBpyA%3DV_0WjrxgpzJ9kUif_aBLKRu-noQ%40mail.gmail.com)), we neither can have have fix any time soon nor confidently specify how record should behave.\r\n\r\nI think that's fine. The below test does work on 2.16.x and that suits our use cases for now.\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                             @JsonProperty (\"intField\") Integer testOtherField) {\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nIt's possible that this is the correct and only supported future usage, but there probably needs to be some consideration (an error, documentation, warning, etc) about the presence of a `@JsonCreator` in a `record` that modifies field names or changes the input of the `record`. Another example below:\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"someOtherIntField\") Integer testOtherIntField,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this(testFieldName, testOtherField + testOtherIntField);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 2, 1));\r\n        assertTrue(result.contains(\"intField\"));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nI'm not even sure how the above could work, so it's most likely not valid or going to be supported, but I don't know that as a consumer. \n\nComment by cowtowncoder:\nFWTW, if not Record-specific, reproduction without Record would be great (since it's likely in shared code b/w POJOs, Records).\n\nComment by cowtowncoder:\nLooking at the original case, it does seem like a flaw: `@JsonCreator`-annotated constructor should be used as the primary one, and any property name changes should be used from that.\r\n\r\nAnd while fix may or may not be easy, a PR for reproduction, would be great.\r\nIt seems to be this would be Record-specific thing, fwtw, as fully annotated case\r\n\r\n\r\n> > ...titled with the word `record` in it.\r\n> \r\n> I don't think this thing is Record-specific.\r\n\r\nLooking at the original reproduction, it would seem it is?\r\nOr why do you think it isn't?\r\n\n\nComment by cowtowncoder:\nOk, at any rate: a PR for failing test case (under `src/test-jdk17/java/..../failing`) would be great, either against 2.17 or 2.18 branch.\n\nComment by JooHyukKim:\n> Ok, at any rate: a PR for failing test case (under `src/test-jdk17/java/..../failing`) would be great, either against 2.17 or 2.18 branch.\r\n\r\nMost test cases here make use of `ParameterNamesModule`, so it seems not possible?\n\nComment by yihtserns:\n@JooHyukKim I think this can help: https://github.com/FasterXML/jackson-databind/blob/2.18/src/test-jdk17/java/com/fasterxml/jackson/databind/records/Jdk8ConstructorParameterNameAnnotationIntrospector.java\n\nComment by cowtowncoder:\nUgh. I missed `ParameterNamesModule` reference since that wasn't in the original description.\r\n\r\nCorrect, tests here cannot use it.\r\n\r\nThere are a few tests tho that implement replica, `AnnotationIntrospector` that provides bogus names for testing. So it is possible, if tedious, to do that (beside one that @yihtserns referenced).\r\n\n\nComment by JooHyukKim:\nFiled PR #4477. It does fail from 2.16 version and on.\n\nComment by cowtowncoder:\nOk, I know what is causing this: before #4515, Constructor properties are not resolved for Record serialization (for some reason). It is likely this can be fixed ones #4515 fix is complete enough.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`@JsonProperty` not serializing field names properly on `@JsonCreator` in Record",
                "name": "issue#4452",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4452"
                    }
                ],
                "similarity": 0.37386761714295474,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3988",
                "type": "issue",
                "content": "**Describe the bug**\r\n\r\nThe exception thrown for an incorrectly annotated record has changed.\r\n\r\n**Version information**\r\n2.15.2\r\n\r\n**To Reproduce**\r\n\r\nConsider these two examples:\r\n\r\n```\r\npublic record RecordWithSingleValueValue(@JsonValue String value) {}\r\n\r\npublic record RecordWithSingleValueCreatorDelegating(String value) {\r\n\r\n  @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n  public RecordWithSingleValueCreatorDelegating {}\r\n\r\n}\r\n\r\npublic class JacksonSerializationTest {\r\n\r\n  private static final ObjectMapper mapper = new ObjectMapper();\r\n\r\n  @Test\r\n  public void recordWithSingleValueValue() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueValue(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"\\\"foo\\\"\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, RecordWithSingleValue.class));\r\n  }\r\n\r\n  @Test\r\n  public void recordWithSingleValueCreatorDelegating() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueCreatorDelegating(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, RecordWithSingleValueCreatorDelegating.class));\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nIn 2.14.2 `InvalidDefinitionException` was thrown as shown above, with 2.15.3 this changed to `MismatchedInputException`.\r\nFrom my understanding `InvalidDefinitionException` was perhaps more \"correct\"?\r\n\r\n**Additional context**\r\nI tried to figure out whether this change was intentional or not, but couldn't find anything in the changelog or issues.\r\nI just wanted to let you know of this change \u2013 apologies if this was intentional and I missed it.\r\n\r\n(I also found some other behavioral changes in 2.15, but I assume they are intentional \u2013 things that weren't deserializing before are now deserializing.)\n\n\nComment by yihtserns:\nLooking at the javadoc:\r\n- `InvalidDefinitionException`: Something is wrong with the class to deserialize into.\r\n- `MismatchedInputException`: The wrong input has been provided.\r\n\r\nThe scenario is providing JSON String to a class that expects JSON Object, and providing JSON Object to a class that expects a JSON String.  Isn't that \"the wrong input has been provided\"? \n\nComment by yihtserns:\n>...things that weren't deserializing before are now deserializing.\r\n\r\nWhat's the scenarios for those? \n\nComment by soc:\n>  Isn't that \"the wrong input has been provided\"?\r\n\r\nGood point! Perhaps my confusion comes from things changing for `record`, but not for `class`. :thinking:\r\n(I basically have a small test suite that tests all possible combinations of Jackson annotations.)\n\nComment by soc:\nOoops, wait a minute, I copied the wrong record definitions above.\r\n\r\nEdit: Fixed, apologies. Both `records` in the original post were the wrong ones for the tests I showed.\n\nComment by soc:\n> What's the scenarios for those?\r\n\r\n```\r\npublic record RecordWithSingleValue(String value) {}\r\n\r\npublic record RecordWithSingleValueCreatorProperties(String value) {\r\n\r\n  @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\r\n  public RecordWithSingleValueCreatorProperties {}\r\n\r\n}\r\n```\r\n\r\nnow both round-trip, they failed with `InvalidDefinitionException` on 2.14.\r\n\r\n\n\nComment by yihtserns:\nI think you need to double check your scenarios, because when I tried using `2.14.0`:\r\n\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>recordWithSingleValueValue</th>\r\n<th>recordWithSingleValueCreatorDelegating</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>Failed with:\r\n<blockquote>\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Problem with definition of [AnnotedClass com.github.yihtserns.records.jackson.RecordWithSingleValueValue]: Multiple 'as-value' properties defined ([field com.github.yihtserns.records.jackson.RecordWithSingleValueValue#value] vs [method com.github.yihtserns.records.jackson.RecordWithSingleValueValue#value()])\r\n</blockquote>\r\nat:\r\n<pre>\r\n@Test\r\npublic void recordWithSingleValueValue() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueValue(\"foo\");\r\n    var result = mapper.writeValueAsString(instance); <---- failed here\r\n    ...\r\n}\r\n</pre>\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n---\r\n> ```\r\n> public record RecordWithSingleValue(String value) {}\r\n> \r\n> public record RecordWithSingleValueCreatorProperties(String value) {\r\n>   @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\r\n>   public RecordWithSingleValueCreatorProperties {}\r\n> }\r\n> ```\r\n> now both round-trip, they failed with InvalidDefinitionException on 2.14.\r\n\r\nSorry I don't understand what that means, you'd have to explain more than that...  \ud83d\ude1e \n\nComment by soc:\n> I think you need to double check your scenarios, because when I tried using 2.14.0\r\n\r\n@yihtserns Did you see my edit regarding the class definitions above?\r\nPreviously I ran on 2.14.2, so perhaps your 2.14.0 does things differently?\r\n\r\n> Sorry I don't understand what that means, you'd have to explain more than that... disappointed\r\n\r\nEach of the examples can deserialize the value it serialized.\r\n\r\n---\r\n\r\nI'm reverting the whole thing, just got another failure about\r\n\r\n> Invalid type definition for type `...Dto`: Argument #5 of constructor [constructor for `...Dto` (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\nfor a record that is not annotated with `@JsonCreator`, and also has no property name annotations for args #1-#4 or #6 either.\n\nComment by yihtserns:\n<table>\r\n<thead>\r\n<tr>\r\n<th>Version \u2b07\ufe0f</th>\r\n<th>recordWithSingleValueValue</th>\r\n<th>recordWithSingleValueCreatorDelegating</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<th>2.14.2</th>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n<tr></tr>\r\n<tr>\r\n<th>2.15.3-SNAPSHOT</th>\r\n<td>\r\nSuccessfully deserializes because of new feature #3654 (+#3724).\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\nI see there's no change for `recordWithSingleValueCreatorDelegating` between `2.14.2` & `2.15.3-SNAPSHOT` (**NOTE**: `2.15.3` is not released yet): they're both throwing `MismatchedInputException` in my machine.  \ud83e\udd14 \n\nComment by yihtserns:\n> I'm reverting the whole thing, just got another failure about\r\n>> Invalid type definition for type ...Dto: Argument https://github.com/FasterXML/jackson-databind/pull/5 of constructor [constructor for ...Dto (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n>\r\n> for a record that is not annotated with @JsonCreator, and also has no property name annotations for args https://github.com/FasterXML/jackson-databind/issues/1-https://github.com/FasterXML/jackson-databind/pull/4 or https://github.com/FasterXML/jackson-databind/pull/6 either.\r\n\r\nWithout direct access to your machine, it's basically impossible to know what you're talking about.  Maybe you can create a Github repository with all the (failing) test cases to describe the issue - that's the most effective way for us to be \"in-sync\" with each other.\n\nComment by cowtowncoder:\nI would suggest actually addressing a small number -- possibly just one -- fail at a time and not bundling together all cases.\r\n\r\nBut aside from that, the general idea would be that:\r\n\r\n1. Things that are wrong with definition -- regardless of input; that is, occurring during construction/initialization of deserializer -- should results in `InvalidDefinitionException`\r\n2. Things that could work (value/deserializer annotations valid) but do not work for encountered input should result in exceptions like `MismatchedInputException`\r\n\r\nWhether change in specific case is intentional, valid, or invalid depends on many things of course. Above is just the general guidance.\r\nWe try not to change exception types unless there was an incorrect one before; exceptions thrown are considered part of API definition. One exception to this (no pun intended) is that sometimes we may start using a more specific one (new subtype).\r\n\r\n\n\nComment by soc:\nIt appears as if Jackson behaves wildly different with and without a Java module-info file, even on 2.14.2.\r\nI believe this should not be the case.\r\n\r\n2.14.2 with module-info:\r\n![jackson-2 14 2-with-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/b254a44d-02b5-48ba-ba90-fa66da3c771b)\r\n\r\n\r\n2.14.2 without module-info:\r\n![jackson-2 14 2-without-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/38bb8b13-61ca-42a9-a021-b2acce2ef80f)\r\n\r\n\r\n2.15.2 with module-info:\r\n![jackson-2 15 2-with-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/575397e9-a1eb-4802-ad4f-e720b310cbce)\r\n\r\n2.15.2 without module-info:\r\n![jackson-2 15 2-without-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/d0e86164-ebbf-4de8-936b-8c3b261792da)\r\n\r\nI'm not sure it makes sense to look at the behavioral changes between 2.14 and 2.15, if using the Java module system makes the results diverge that much.\r\n\r\nReproduction: https://github.com/soc/jackson-repro\n\nComment by soc:\nI added the reproduction for\r\n\r\n> Invalid type definition for type ...Dto: Argument https://github.com/FasterXML/jackson-databind/pull/5 of constructor [constructor for ...Dto (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\nin a second commit in the same repo.\n\nComment by yihtserns:\n@soc can you also commit a [Maven wrapper](https://maven.apache.org/wrapper/) into your repo, please?  Just want to ensure our environmental settings are close enough:\r\n\r\n- Running `mvn test` ignores all the test methods, I had to specifically specify a newer `maven-surefire-plugin` - this is likely because my personal Maven installation uses an older `maven-surefire-plugin` by default.\r\n- When I run `JacksonSerializationTest` directly in Intellij, the result WITH `module-info` is the same as your result for WITHOUT `module-info`:\r\n![image](https://github.com/FasterXML/jackson-databind/assets/3615932/7cfcf8d2-9ead-4d33-a7bc-b2eae4bfec26)\n\nComment by yihtserns:\nFor these test cases in `JacksonSerializationTest`:\r\n- `recordWithSingleValueCreatorProperties`\r\n- `recordWithSingleValue`\r\n- `recordWithSingleValueValue`\r\n- `recordWithSingleValueCreatorDelegating`\r\n\r\n...in 2.14.2 they failed with:\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type \\`<...snip>\\`: Failed to call \\`setAccess()\\` on Field '<...snip>' (of class \\`<...snip>\\`) due to \\`java.lang.reflect.InaccessibleObjectException\\`, problem: Unable to make field private final java.lang.String <...snip> accessible: module repro does not \"opens repro\" to module com.fasterxml.jackson.databind\r\n\r\nThat `InvalidDefinitionException` was a bug that has been fixed by #3352.  Which is why:\r\n- `recordWithSingleValueCreatorProperties`: can now deserialize the valid JSON\r\n- `recordWithSingleValue`: can now deserialize the valid JSON\r\n- `recordWithSingleValueValue`: can now fail with \"mismatched input\" error for the invalid JSON\r\n- `recordWithSingleValueCreatorDelegating`: can now fail with \"mismatched input\" error for the invalid JSON\r\n\r\n---\r\nAs for `JacksonSerialization2Test` failing with:\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type \\`repro2.RecordWithMultipleValuesAndOnePropertyAccessAnnotationDto\\`: Argument \\#&#8203;1 of constructor [constructor for \\`repro2.RecordWithMultipleValuesAndOnePropertyAccessAnnotationDto\\` (2 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\n...that is caused by #3724 not covering the scenario where deserialization uses a Record with a constructor property with `access=READ_ONLY` .\n\nComment by soc:\nOk, thanks! Then I'll wait for 2.15.3 and report back!\n\nComment by cowtowncoder:\nThis is too convoluted an issue, discussion, to be of much value (IMO), so I'll close it. Relevant, remaining pieces may be re-filed (with possible ref to this one), with clear explanation of intended correct outcome, and not so much on what has changed -- some changes are fine (fixes), others not: but it's perfectly fine to suggest that specific change is wrong (bug/regression). There is no need to ask \"why was this changed\" if change seems wrong: but there is clear need to clearly indicate both type of exception and message being reported -- latter likely explains how change came about (new validation, regression).\r\n\r\n\n\nComment by Mochis:\nI have some doubts, is the problem related to constructor property with access=READ_ONLY resolved in 2.15.3 or 2.16?\r\n\r\n> ...that is caused by https://github.com/FasterXML/jackson-databind/pull/3724 not covering the scenario where deserialization uses a Record with a constructor property with access=READ_ONLY .\n\nComment by cowtowncoder:\n@Mochis Read my note above. If you have remaining problem case that is not covered by an open issue, please file a new, targeted issue for specific problem.\n\nComment by Mochis:\nThank you @cowtowncoder. Reported here https://github.com/FasterXML/jackson-databind/issues/4119\n\nComment by soc:\nShort update: After I reported this issue, I adapted the test to the behavior on 2.15.2.\r\n\r\nNow, with the same Jackson version (2.15.2), but updated Java version (to 21) I get similar failures for classes as previously for records:\r\n\r\n```\r\nFailures: \r\n  JacksonSerializationTest.classWithSingleValueCreatorDelegating:31 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueCreatorDelegatingProperty:41 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueCreatorPropertiesProperty:61 Expected com.fasterxml.jackson.databind.exc.InvalidDefinitionException to be thrown, but nothing was thrown.\r\n  JacksonSerializationTest.classWithSingleValueGetConstructor:71 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueProperty:90 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n```\r\n\n\nComment by soc:\nJust checked with 2.16.0 and Java 21:\r\n\r\nExample `JacksonSerializationTest.classWithSingleValueProperty`:\r\n\r\n```\r\n  @Test\r\n  public void classWithSingleValueProperty() throws JsonProcessingException {\r\n    var instance = new ClassWithSingleValueProperty(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, ClassWithSingleValueProperty.class));\r\n  }\r\n```\r\n\r\n- Test green when running the test from the IDE.\r\n- Error message when running `mvn` from the CLI:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `ClassWithSingleValueProperty` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\r\n```\r\n\r\nIf I adjust the example to\r\n\r\n```\r\n  @Test\r\n  public void classWithSingleValueProperty() throws JsonProcessingException {\r\n    var instance = new ClassWithSingleValueProperty(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(\"\\\"foo\\\"\", ClassWithSingleValueProperty.class));\r\n  }\r\n```\r\n\r\n- Test green when running the test from the IDE.\r\n- Error message when running `mvn` from the CLI (this is expected):\r\n```\r\nExpected com.fasterxml.jackson.databind.exc.InvalidDefinitionException to be thrown, but nothing was thrown\r\n```\n\nComment by JooHyukKim:\n> Test green when running the test from the IDE.\r\n> Error message when running mvn from the CLI:\r\n\r\nWhat is version IDE is configured with? @soc \r\nAlso, could you check mvn version? (stdout will have jdk version) \r\n\r\nAsking this because IDE, mvn usually not the problem but the JDK version they load. \n\nComment by cowtowncoder:\nThis is closed issue, fwtw.",
                "source_code": null,
                "distance": 0.75,
                "title": "Exception thrown for incorrectly annotated record changed from `InvalidDefinitionException` to `MismatchedInputException`",
                "name": "issue#3988",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3352"
                    },
                    {
                        "start_node": "issue#3352",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3988"
                    }
                ],
                "similarity": 0.37317738944463164,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3899",
                "type": "issue",
                "content": "relates to #3897 \n\n\nComment by yihtserns:\nI'm going to fix this bug, but how do I use this PR/branch?..\r\n\r\nDo I fork from your fork?\n\nComment by JooHyukKim:\n> I'm going to fix this bug, but how do I use this PR/branch?..\r\n> \r\n> Do I fork from your fork?\r\n\r\n~~@yihtserns Good \ud83d\udc4d\ud83c\udffb\ud83d\udc4d\ud83c\udffb You can just copy the test code and include it in the PR. No need to keep the test class here since you would include the test case anyway.~~\r\n\r\nYou can refer to below suggested git command\ud83d\ude46\ud83c\udffd\u200d\u2642\ufe0f\ud83d\ude46\ud83c\udffd\u200d\u2642\ufe0f\n\nComment by pjfanning:\nuse \r\n\r\n```\r\ngit remote add jhk https://github.com/JooHyukKim/jackson-databind\r\ngit fetch jhk\r\ngit switch -c  jhk/Add-failing-test-for-#3897\r\n```\n\nComment by yihtserns:\nCopied & modified into #3910.",
                "source_code": null,
                "distance": 0.75,
                "title": "Add failing test for `Record` class deserialization with single field annotated with `JsonProperty.Access.WRITE_ONLY`",
                "name": "pr#3899",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3897"
                    },
                    {
                        "start_node": "issue#3897",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3899"
                    }
                ],
                "similarity": 0.37206014617760724,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3628",
                "type": "issue",
                "content": "This may be by design, but I think it may be a bug...\r\n\r\n**Describe the bug**\r\nWhen serializing a record that implements an interface, Jackson also serializes any values resulting from getters in an implemented interface. Such additional \"getters\" should however always be perceived as transient, as they cannot influence the actual data stored in the record.\r\n\r\nFor example:\r\n\r\n    public sealed interface StreamMetaDataEvent extends AggregateEvent {\r\n      public record Updated(StreamMetaData streamMetaData) implements StreamMetaDataEvent {\r\n        @Override\r\n        public Type getType() {\r\n          return Type.FULL;\r\n        }\r\n    \r\n        @Override\r\n        public String getAggregateId() {\r\n          return \"\" + streamMetaData.contentId().asInt();\r\n        }\r\n      }\r\n    \r\n      public record Removed(ContentID id) implements StreamMetaDataEvent {\r\n        @Override\r\n        public Type getType() {\r\n          return Type.DELETE;\r\n        }\r\n    \r\n        @Override\r\n        public String getAggregateId() {\r\n          return \"\" + id.asInt();\r\n        }\r\n      }\r\n    }\r\n\r\nThe getters here are transient (they contain no new information) and are coming from the `AggregateEvent` interface:\r\n\r\n    public interface AggregateEvent {\r\n      enum Type { FULL, DELETE }\r\n\r\n      Type getType();\r\n      String getAggregateId();\r\n    }\r\n\r\n**Work around**\r\n\r\nConfiguring `setVisibility(PropertyAccessor.GETTER, Visibility.NONE)` will also ignore the records fields (not sure if they should be considered \"getters\", but I suppose they might).  Configuring in addition `setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` resolves the issue.\r\n\r\n**Version information**\r\nWhich Jackson version(s) was this for? 2.13.4\r\n\r\n**Expected behavior**\r\nI would expect Jackson to recognize records, and recognize that it is fully defined by the records fields; any additional methods, getters or otherwise, should be considered irrelevant for reconstructing the record.\r\n\n\n\nComment by cowtowncoder:\nMy first thought is that I would consider this a feature: a getter is a getter, even for Records. If they are not to be serialized, they should be marked to be ignored; either by annotations (`@JsonIgnore`, `@JsonIgnoreProperties`), or you may consider enabling `MapperFeature.REQUIRE_SETTERS_FOR_GETTERS` which would prevent serialization of any potential properties that cannot be deserialized (there is no matching \"setter\"; in case of Record meaning constructor parameter).\r\n\r\nIn theory I guess it would be possible to change default visibility level of `Record`s such that no getters would be auto-detected, if users feel this is the way to go. Right now you can change visibility levels (see `@JsonAutoDetect`), but there's no way to easily apply it to all Records.\r\n... actually, come to think of it, it is quite straight-forward to achieve that by user code: override method `findAutoDetectVisibility()` of `AnnotationIntrospector` (or implementation `JacksonAnnotationIntrospector`), and if class is a record type, return different settings: despite name, `AnnotationIntrospector` need not use annotations at all -- it is just the extension/API Jackson uses to make annotation-access modular. So one can use it to \"emulate\" existence of all Jackson annotations.\r\n\r\n\r\n\n\nComment by yihtserns:\nReading the last comment somehow reminds me of [50dd52f](https://github.com/FasterXML/jackson-databind/commit/50dd52f688c8d3af774fa2a9a57c7a5694a70996#diff-542cb14fa94cf6618aa34cc95eb237bf05bd561817e545e74b0a66f25fd98857), where you created a custom default `VisibilityChecker` for Records, for v3.\r\n\r\nIt is a possible option to change that `VisibilityChecker` (albeit for v3) to match the behaviour expected by this issue?  \ud83e\udd14  But that will cause the behaviour to drift further away again from POJO de/serialization behaviour...\n\nComment by yihtserns:\n@cowtowncoder  Eh while trying a different mecha than `AnnotationIntrospector` (i.e. via `ConfigOverride`), it suddenly made me wonder if #3737 specifically [0a4cfc4](https://github.com/FasterXML/jackson-databind/commit/0a4cfc46bc491aed9eab83e13dcd65d415b10c64#diff-8a89bf8f93c483493c778cda25b2e31e2e89bd4b0a8a131e71bfd2ed5a199fff) has broken the workaround used in his issue - specifically usage of `setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` - by avoiding to detect fields for Record types?\n\nComment by cowtowncoder:\nYeah I don't know. Perhaps. That's the challenge of missing test coverage -- functionality not covered by tests can easily break.\n\nComment by yihtserns:\n@hjohn can you help provide a code snippet so we can know exactly how your workaround looks like, so we can properly test whether it's broken in `2.15.0`?\n\nComment by hjohn:\nI just configured a custom `ObjectMapper` for serializing records:\r\n\r\n    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n      .setVisibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n      .setVisibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n      .registerModule(new JavaTimeModule())\r\n      .registerModule(new Jdk8Module())\r\n      .registerModule(new ParameterNamesModule(Mode.PROPERTIES));\r\n\r\nWith this setup it only detects the records fields, and since you can't add any fields to a record, that's all the data you would need to store.\n\nComment by cowtowncoder:\nOne thing to note is that `Record`s do NOT require use of `ParameterNamesModule` as name information is accessed (via Reflection) using record-specific accessors, and anything module provides is basically overridden.\r\nModule is needed for regular POJOs wrt Creators of course.\r\n\n\nComment by yihtserns:\nThat workaround + `2.15.0-rc2` = `{}`\r\n\r\n\ud83d\ude2c \n\nComment by hjohn:\n> That workaround + `2.15.0-rc2` = `{}`\r\n> \r\n> \ud83d\ude2c\r\n\r\nIs that a cryptic way of saying that limiting visibility to fields only for records breaks in 2.15.0-rc2 ?\n\nComment by yihtserns:\nYes.  Only an empty JSON hash/object will be generated when that workaround is used with `2.15.0-rc2`...\r\n\r\n**UPDATE**: The workaround used above is working again in `2.15.1` courtesy of #3894.",
                "source_code": null,
                "distance": 0.5,
                "title": "Serializing a Java 16 Record includes transient data from getters from implemented interfaces",
                "name": "issue#3628",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    }
                ],
                "similarity": 0.3684596138900962,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "2980",
                "type": "issue",
                "content": "**Describe the bug**\r\nI experience a potential regression since `2.12.0` when trying to deserialize a scalar value to a single-value `Record`. Consider this test case:\r\n\r\n```java\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nclass RecordStringDeserializationTest {\r\n\r\n  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\r\n\r\n  @Test\r\n  void deserializeMyValueRecordFromPrimitiveValue() throws Exception {\r\n    assertEquals(new MyValueRecord(\"foo\"), OBJECT_MAPPER.readValue(\"\\\"foo\\\"\", MyValueRecord.class));\r\n  }\r\n\r\n  final record MyValueRecord(@JsonProperty String value) {}\r\n}\r\n```\r\n\r\nThis works as expected in `2.11.3`, since `2.12.0` a `MismatchedInputException` is thrown:\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `us.byteb.jackson.RecordStringDeserializationTest$MyValueRecord` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('foo')\r\n at [Source: (String)\"\"foo\"\"; line: 1, column: 1]\r\n```\r\n\r\nThis still works as expected  if an explicit factory method annotated with `@JsonCreator` is provided for the Record or for an equivalent Class without explicit `@JsonCreator` (see additional [test cases](https://gist.github.com/bfncs/2626ff10830c29e674c6e485bcb7db67)). I would expect the behavior for Records to be the same as for Classes, it also seems contrary to the brevity of Records to have to define an additional factory method.\r\n\r\n**Version information**\r\n`2.12.0`\r\n\r\n**To Reproduce**\r\nSee test case above.\r\n\n\n\nComment by cowtowncoder:\nOk so this is a common stumbling block: you are assuming that constructors would be taken as \"delegating\" creator, for 1-argument case. Unfortunately:\r\n\r\n1. This is fundamentally ambiguous case and one that has never worked well for POJOs without annotations (but see #1498 added in 2.12 to help a bit) -- but heuristics can certainly result in \"delegating\" being the answer (if constructor parameter name is not available or if there is nothing indicating property with that name)\r\n2. Addition of `@JsonProperty` for parameter explicitly indicates that this should be properties-based case (even  with POJOs)\r\n3. For Records, explicit support was only added in 2.12, and it defines that the default mode is \"properties\" unless explicitly overridden by annotation.3. \r\n\r\nSo this is working as intended from my perspective.\r\n\r\nTo use delegating style you will need to add `@JsonCreator(mode = JsonCreator.Mode.DELEGATING)` annotation on constructor.\r\n\n\nComment by cowtowncoder:\nHowever... it does not look like there is a proper test for verifying ability to use delegation so I will add one to verify it actually works. :)\r\n\n\nComment by cowtowncoder:\nAnd what do I know: the test case fails. So somehow constructor annotation is not being found; possibly same as or related to #2974.\n\nComment by cowtowncoder:\n... except that my test was faulty; when fixed, works as expected. Should always double-check tests when they fail.\r\n\n\nComment by cowtowncoder:\nOk, so: I think this is working as expected: by default, Records will use \"properties\"-style construction.\r\nIt is unfortunate that behavior was different in 2.11, as auto-detection and heuristics determined that \"delegating\" style would be most appropriate (as Record handling was using default POJO logics), but this is the intended behavior with explicit `Record` support.\r\n\r\nTo use delegating-style with Records on 2.12 and later, necessary annotation will be:\r\n\r\n```\r\n    record MyValueRecord(String value) {\r\n        @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n        public MyValueRecord(String value) {\r\n           this.value = value;\r\n       }\r\n    }\r\n```\r\n\r\nsince there is no shorter way to annotate primary constructor (as far as I know).\r\n\r\n\n\nComment by bfncs:\nThanks very much for answering this in great depth :bouquet: \r\nThis makes sense and is still easy and consistent to use. I was only confused by the changed heuristic behavior between versions.\n\nComment by cowtowncoder:\n@bfncs Yeah, this wasn't something I had thought of until you reported it; I did not realize Records were already used, although it was mentioned as something that sort of works (when discussing initially addition of explicit support for 2.12).\r\n\r\nI will add a note on 2.12 release page: thank you for bringing this up.\r\n\r\n\n\nComment by bfncs:\nOne more thing just now came to my mind: this also works with a record's compact constructor and is a bit less boilerplate:\r\n\r\n```java\r\n    record MyValueRecord(String value) {\r\n        @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n        public MyValueRecord {}\r\n    }\r\n```\n\nComment by cowtowncoder:\nInteresting, did not know such shortcut was available. Thank you for sharing!\n\nComment by soc:\nI wanted to report that I came across this issue because a class \u2192 record migration lead to this (mysterious) failure. In my case it required backing out of the changes, because the type in question existed in a module that did not depend on Jackson, so adding the annotation was not an option.\r\n\r\nI think the current behavior is really unfortunate, and I hope the behavior can be fixed in Jackson 3.0. :-/\r\n\r\nThanks!\n\nComment by yawkat:\n@soc It is possible to add annotations to classes in other modules through the mixin feature. I'm not sure how it interacts with records, though.\n\nComment by soc:\n@yawkat\r\n\r\n> It is possible to add annotations to classes in other modules through the mixin feature.\r\n\r\nThanks, I didn't know about this feature! (Keeping the class and the mixin in sync may create more work than it is worth in my case though.)\r\n\r\n> I'm not sure how it interacts with records, though.\r\n\r\nWith records not even a custom deserializer worked. I reverted things back to a class and things are converting again.\n\nComment by cowtowncoder:\nQuick note: use of custom deserializer for Record types should absolutely work. Although I suspect it depends on how you are registering custom deserializer (there are some general issues wrt annotation unification across Constructor parameters vs fields/getters/setters).\r\nSo worth filing a separate issue if that does not work.\r\n\r\nMix-in handling is general so it should work, but could have similar issues with annotation merging between Constructor parameters, other accessors.\r\n\r\nAs to changing behavior: unfortunately I think that the way Records work is the \"Right\" way -- default without annotation should probably be Properties-based. Explicit annotation would be needed for delegating case.\r\nBut I also agree that configurability, including that for Records, would be good.\r\n\r\n\n\nComment by soc:\n@cowtowncoder \r\n\r\n>  So worth filing a separate issue if that does not work.\r\n\r\nI will investigate further. I have cases where it works and cases where it doesn't.\r\n\r\n> As to changing behavior: unfortunately I think that the way Records work is the \"Right\" way -- default without annotation should probably be Properties-based.\r\n\r\nAgree in that. I hope it can be changed for classes in Jackson 3 to work the same for classes as it currently does for records.\r\n\r\n---\r\n\r\nIs there any documentation on property-based vs. delegation-based serialization? I searched the documentation, but couldn't find more information on it.\r\n\r\nSame for \"creators\" \u2013 I know that there are some \"special\" method names like `of` and `from`, but only because I read the implementation.\r\n\r\nPlease let me know, if there isn't any, I'd be happy to write it, because I keep forgetting the details.\r\n\n\nComment by soc:\nFurther debugging:\r\n\r\n- not related to modules\r\n- not related to having both a `of` and a `new`\r\n- does not work with `@JsonCreator`\r\n- does not work with an explicit Deserializer\r\n- **works** with `@JsonCreator(mode = JsonCreator.Mode.DELEGATING)`\r\n\r\nSurprisingly, it fails with a complaint on a type that doesn't even have the offending record:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException:\r\n  Cannot construct instance of `FooRecord` (although at least one Creator\r\n  exists): no String-argument constructor/factory method to deserialize\r\n  from String value ('850886fc-c23d-4567-8714-a6e4b1a445dd')\r\n    at [Source: UNKNOWN; byte offset: #UNKNOWN]\r\n    (through reference chain: SomeUnrelatedClass[\"fooRecord\"])\r\n```\r\n\r\n`SomeUnrelatedClass` has neither a member called `\"fooRecord\"` nor any member of type `FooRecord`.\n\nComment by cowtowncoder:\n@soc Alas, no documentation exists that I know of. Would be happy to add under `jackson-docs` (probably under wiki, although separate `xxxx.md` would be fine too. Or even `jackson/` -- there's FAQ which has not been updated in years.\r\n\r\nEvery now and then we have discussions on mailing lists, ideas, but it all really needs (at least) one person to kind of define structure, skeleton, over which content can be added. To me at least it is much easier to incrementally add bits and pieces when scaffolding is there.\r\n\r\n\n\nComment by cowtowncoder:\n@soc That unrelated reference case is pretty odd, agreed. I would still be particularly interested in explicit deserializer case, if you can show how you are adding it. That might be an easy fix.\r\n\r\nI really, really hope I can find time to tackle Record handling: my first goal was actually to tackle #3352 for future compatibility. But beyond that there is the big need to resolve introspection which affects POJOs as well -- it just happens to be that for `Record`s there are fewer non-affected parts.\r\nBut what I lack right now is contiguous time to dig deep, remember pieces I had to work on for Jackson 2.12 when introducing explicit Record support. Work then was minimalistic, for better or worse. More intrusive changes would have made future improvements easier, in hindsight. But at the time there were so many things to work on... (lol -- that hasn't changed).\r\n\r\nI really appreciate your help here & wish I could devote more time here. But let's keep things going at whatever rate we can.\r\n\r\n\r\n\r\n\r\n\r\n\n\nComment by soc:\nHey @cowtowncoder, no worries! Nobody has unlimited time, power or focus.\r\n\r\nThanks for all the work you do, and if people think more should be done ... they need to step up themselves!",
                "source_code": null,
                "distance": 0.75,
                "title": "Deserializing to single-value Record from scalar values",
                "name": "issue#2980",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3352"
                    },
                    {
                        "start_node": "issue#3352",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#2980"
                    }
                ],
                "similarity": 0.35511664351520256,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4630",
                "type": "issue",
                "content": "### Search before asking\n\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nA Record component whose accessor method is overridden and:\r\n- Not included in @JsonIncludeProperties, or\r\n- Included in @JsonIgnoreProperties\r\n\r\n...will still get serialized into the generated JSON.\n\n### Version Information\n\nSince `2.15.0`.\n\n### Reproduction\n\n#### For @JsonIncludeProperties\r\n```java\r\nrecord Id2Name(int id, String name) {\r\n}\r\nrecord RecordWithJsonIncludeProperties(@JsonIncludeProperties(\"id\") Id2Name child) {\r\n    @Override\r\n    public Id2Name child() {\r\n        return child;\r\n    }\r\n}\r\n\r\nString json = new ObjectMapper().writeValueAsString(new RecordWithJsonIncludeProperties(new Id2Name(123, \"Bob\")));\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError:\r\n// Expected :{\"child\":{\"id\":123}}\r\n// Actual   :{\"child\":{\"id\":123,\"name\":\"Bob\"}}\r\nassertEquals(\"{\\\"child\\\":{\\\"id\\\":123}}\", json);\r\n```\r\n\r\n#### For @JsonIgnoreProperties\r\n```java\r\nrecord Id2Name(int id, String name) {\r\n}\r\nrecord RecordWithJsonIgnoreProperties(@JsonIgnoreProperties(\"name\") Id2Name child) {\r\n    @Override\r\n    public Id2Name child() {\r\n        return child;\r\n    }\r\n}\r\n\r\nString json = new ObjectMapper().writeValueAsString(new RecordWithJsonIgnoreProperties(new Id2Name(123, \"Bob\")));\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError:\r\n// Expected :{\"child\":{\"id\":123}}\r\n// Actual   :{\"child\":{\"id\":123,\"name\":\"Bob\"}}\r\nassertEquals(\"{\\\"child\\\":{\\\"id\\\":123}}\", json);\r\n```\n\n### Expected behavior\n\n_No response_\n\n### Additional context\n\n**NOTE**: I'm not personally affected by this, just something I found when testing for #4626.\n\n\nComment by yihtserns:\nApparently #4627 will also fix this.",
                "source_code": null,
                "distance": 0.5,
                "title": "`@JsonIncludeProperties`, `@JsonIgnoreProperties` ignored when serializing Records, if there is getter override",
                "name": "issue#4630",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4630"
                    }
                ],
                "similarity": 0.3533637245800134,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3944",
                "type": "issue",
                "content": "Fixes #3906 as per title.\n\n\nComment by cowtowncoder:\n@yihtserns WDYT?\n\nComment by yihtserns:\nAs noted by [this comment](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1540978987), private canonical constructor (i.e. for `private record XXX(...) { }`) is visible for deserialization before #3724 (tested & confirmed using `2.14.2`).\r\n\r\nDo we want to change `NON_PRIVATE` to `ANY` to preserve that behaviour?\n\nComment by yihtserns:\n(Sorry for going MIA with regards to #3906 - besides day job, I was under the impression that it wasn't urgent so I've been researching for a different way to fix that)\n\nComment by cowtowncoder:\n@yihtserns Hmmh. Good question. I don't know to be sure; perhaps?\r\n\r\nBut I also noticed that there's one regression here, for `RecordImplicitCreatorsTest`: doing this will now expose implicit factory methods (`valueOf()`).\r\n\r\nAnd NP for no follow up: I agree that this is not the most important thing to tackle. And with the issues there are maybe another approach would be useful.\r\n\r\n\r\n\n\nComment by CatarinaRibas:\nHi,\r\n\r\nCan you please fix this problem? I think this is the reason for some troubles that we have been having.\n\nComment by cowtowncoder:\nUnfortunately this breaks some tests. So someone with time should figure out what the problem is, and whether this fix is actually safe to apply or not. I can't (and shouldn't) fix in PR that breaks existing tests.\r\n\r\n@CatarinaRibas perhaps you have time to dig into this to help?\r\n\r\nDiscussion on #3906 side may be a good place to continue discussions on people involved; I created PR but am not most knowledgeable here (nor have time right now)\r\n\n\nComment by yuzawa-san:\n@cowtowncoder looks the failures are related to [this](https://github.com/FasterXML/jackson-databind/blob/018372e14fa499dfc3be0cfe35f5861fa9dab0d0/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java#L816C18-L816C63). the expected result for that is causing a single test (based around that specific disabled AUTO_DETECT_CREATORS case) to fail.\r\n\r\ni got the tests to pass when i changed the condition in the new code to\r\n```java\r\nClassUtil.isRecordType(baseType) && isEnabled(MapperFeature.AUTO_DETECT_CREATORS)\r\n```\n\nComment by cowtowncoder:\nSuperceded by #4057 (targeting 2.16, too risky for patch release)",
                "source_code": null,
                "distance": 0.75,
                "title": "Fix #3906 by forcing Record constructors to be visible regardless of visibility overrides",
                "name": "pr#3944",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3944"
                    }
                ],
                "similarity": 0.34891835886288564,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3894",
                "type": "issue",
                "content": "Refines #3737 - the reason why the fields are needed is because this kind of config needs it:\r\n```java\r\nnew ObjectMapper()\r\n  .setVisibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n  .setVisibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n```\r\n\r\nAnd currently, we have 3 use cases that uses that config:\r\n| | Who | Why |\r\n|--|--|--|\r\n| 1 | #3628 | Easy way to ignore methods (that looks like a property) that comes from interface(s), and only serializing Record components. |\r\n| 2 | https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404 | Easy way (albeit overkill) way to exclude a method (that looks like a property) from being serialized, to avoid making test assertion complicated.\r\n| 3 | #3895, https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532842582 | A way to ignore non-accessor `getXXX` methods. |\r\n\r\nFor the 2nd use case, [there's an alternative solution](https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404).  Not so lucky for 1st & 3rd use cases.\n\n\nComment by cowtowncoder:\nAs per my comment I feel uneasy about exposing fields for Records.\r\n\r\nIt seems to me that the issue here wrt usage is that Records DO NOT use Bean getter/setter notion, and users should follow that naming notation.\r\nBut then again I don't think added accesors would be found.\r\n\r\nSo... I don't know. It's a confusion situation. I really wish JDK team hadn't switched from Bean convention since this is a major hassle -- and has been for years, actually. I understand it's bit more typing and all but for compatibility leaving getters as accessors would have been so much  better for everyone involved.\r\n\r\n\r\n\n\nComment by yihtserns:\nUpdated the PR 1st comment with the 3 currently known use cases.\r\n- The 2nd has alternative solution, so it can be ignored.\r\n- The 1st can be achieved via custom VisibilityChecker via custom AnnotationIntrospector - albeit quite a lot of code to write.\r\n- The 3rd has no alternative solution, and it seems to be a legit need.\n\nComment by fleiber:\nI think I have the problem with a slightly different use case, in case that helps.\r\nThe code is in Kotlin, where we have classes looking like:\r\n```kt\r\nclass Foo(val bar: Int) {\r\n      val isZero get() = bar == 0\r\n}\r\n```\r\nWe serialize these classes with `setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE)` to ignore the isXXX methods, and please note that we cannot use `@JsonIgnore` (\"This annotation is not applicable to target 'member property without backing field or delegate'\").\r\nStarting with Jackson 2.15.0, the `isZero` property is serialized, then the deserialization fails.\r\nThe way we use the visibility feature looks fine to me, so I would say the 2.15 change does look like a regression.\n\nComment by yihtserns:\n@fleiber unless that Kotlin class actually produces Record classes, then they're unrelated - you'd need to open a new issue for that use case.\n\nComment by fleiber:\n> @fleiber unless that Kotlin class actually produces Record classes, then they're unrelated - you'd need to open a new issue for that use case.\r\n\r\nIndeed, I missed the \"record\" part in the title... Sorry, let me create a new issue.\r\nEdit: #3904 \n\nComment by cowtowncoder:\nOk let's do this: we can still re-consider if necessary before 2.15.1 release, but for now this seems sensible.\r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Only avoid Records fields detection for deserialization",
                "name": "pr#3894",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#3894"
                    }
                ],
                "similarity": 0.34378327451263724,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3910",
                "type": "issue",
                "content": "Currently, this is how a 1-arg constructor parameter is evaluated (priority according to the listed order):\r\n\r\n| | What | Properties-based | Delegating |\r\n|---|---|---|---|\r\n|1| Constructor parameter has `@JsonProperty(\"<some name>\")` | \u2705 | |\r\n|2| Any field has `@JsonValue` | | \u2705 |\r\n|3| Any getter method has `@JsonValue` | | \u2705 |\r\n|4| Constructor parameter has `@JacksonInject` | \u2705 | |\r\n|5| Constructor parameter name matched a getter method name | \u2705 | |\r\n|6| Constructor parameter name matched a field name | \u2705 | |\r\n|7| Default | | \u2705 |\r\n\r\nThis PR changes that to:\r\n| | What | Properties-based | Delegating |\r\n|---|---|---|---|\r\n|1| Constructor parameter has `@JsonProperty(\"<some name>\")` | \u2705 | |\r\n|2| Any field has `@JsonValue` | | \u2705 |\r\n|3| Any getter method has `@JsonValue` | | \u2705 |\r\n|4| Constructor parameter has `@JacksonInject` | \u2705 | |\r\n|5| Constructor parameter name matched a getter method name | \u2705 | |\r\n|6| Constructor parameter name matched a field name | \u2705 | |\r\n|6| Is Record canonical constructor parameter `\u2b50 NEW` | \u2705 | |\r\n|8| Default | | \u2705 |\n\n\nComment by cowtowncoder:\n@yihtserns Do you think this would be safe enough to go in 2.15(.1)? I think I'd merge it if you are comfortable.\r\n\r\nIf you are ok with that, would it be possible to re-based/re-create against 2.15 branch?\n\nComment by yihtserns:\n> If you are ok with that, would it be possible to re-based/re-create against 2.15 branch?\r\n\r\nActually the branch was created from `2.15`, I didn't notice the PR is against `2.16`.  Let me change that.",
                "source_code": null,
                "distance": 1.0,
                "title": "Record constructor with single write-only parameter should result in properties-based creator, to fix #3897",
                "name": "pr#3910",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3910"
                    }
                ],
                "similarity": 0.34241463893965635,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3895",
                "type": "issue",
                "content": "In 2.15 trying to encode records with PropertyAccessor.GETTER = Visibility.NONE will result in an empty object {}.\r\n```java\r\nrecord DataObject (int a, int b) {}\r\n\r\n@Test\r\npublic void testRecord() throws Exception {\r\n    final ObjectMapper jsonMapper = new JsonMapper();\r\n    final String r = jsonMapper.writeValueAsString(new DataObject(2, 3));\r\n    jsonMapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n    jsonMapper.setVisibility(PropertyAccessor.GETTER, Visibility.NONE);\r\n    Assertions.assertEquals(\"{\\\"a\\\":2,\\\"b\\\":3}\", r); // we get {}\r\n}\r\n```\r\n\r\nto resolve that we can set PropertyAccessor.GETTER = Visibility.DEFAULT or others, but that will break every single class serialization that does not have annotations on getter methods.\r\n```java\r\npublic class Foo {\r\n    private final int x = 2;\r\n    public int getComputedValue() { return 11; }\r\n}\r\n\r\njsonMapper.writeValueAsString(new Foo()) // { x: 2, computedValue: 11 }\r\n```\r\n\r\nThe behaviour in 2.14 with PropertyAccessor.GETTER = Visibility.NONE is the expected one, with records able to serialize all fields\r\n\r\n\r\nIs this change something done on purpose? are there alternatives to set the visibility of getters and annotate every class method?\n\n\nComment by cowtowncoder:\nWrong repo, moving.\r\n\n\nComment by cowtowncoder:\n@matteobertozzi We publish RC versions -- 2.15.0-rc1, rc2, rc3 -- to find these kinds of concerns; cases that are not supported explicitly (there not being unit tests to cover). So one way to think of it is that unless we test something, and no one contributes tests, feature is not formally supported.\r\n\r\nThis does not mean that usage might not be intended to work: there are gaps.\r\n\r\nHaving said that, I think I agree that if Field visibility is set to `Any`, it would seem serialization should consider these fields.\r\n\r\nI am guessing #3894 would solve this issue?\r\n\r\n\n\nComment by matteobertozzi:\ni'm really sorry to have not tested the RCs. \r\n\r\n#3894 should solve this one\r\n\r\nThank you!\n\nComment by yihtserns:\n@matteobertozzi can you share the reason for that config? Is the reason the same as #3628? \n\nComment by matteobertozzi:\n@yihtserns the main reason is because we have \"bad code\". with classes that contains methods called \"getXyz()\" but they are not getters and they are doing computations and maybe some business logic.\r\n\r\nso if we use something different from .GETTERS = Visbility.NONE, we end up with a value that is not supposed to be serialized and maybe some business logic triggered.\r\n```java\r\npublic class Foo {\r\n    private final int x = 2;\r\n    public int getComputedValue() { return 11; }\r\n}\r\n\r\njsonMapper.writeValueAsString(new Foo()) // { x: 2, computedValue: 11 }\r\n```\r\ngoing around all the methods in the codebase to add annotations may be fine for a major (e.g. the 3.x) but we didn't expect that for a minor. \n\nComment by cowtowncoder:\n@matteobertozzi Sorry did not mean that you specifically should have tested, just that it is too bad no one with this use case had tried it and reported. There are gaps, hopefully over time fewer and fewer.\r\n\r\nSo this is a surprise to us and not a planned behavioral change.\r\n\n\nComment by agavrilov76:\nIt is probably related that since version 2.15 `MapperFeature.SORT_PROPERTIES_ALPHABETICALLY` is not longer respected by record method based JSON properties.\r\n\r\nThe property 'a' in the example below comes at the last place:\r\n\r\n```java\r\n    final var mapper =\r\n        Jackson.mapperBuilder()\r\n            .enable(SerializationFeature.INDENT_OUTPUT)\r\n            .enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)\r\n            .build();\r\n\r\n    record R(String c, String b, String e) {\r\n\r\n      @JsonProperty\r\n      String a() {\r\n        return \"4\";\r\n      }\r\n    }\r\n\r\n    System.out.println(mapper.writeValueAsString(new R(\"1\", \"2\", \"3\")));\r\n```\r\nOutput:\r\n\r\n  {\r\n    \"b\" : \"2\",\r\n    \"c\" : \"1\",\r\n    \"e\" : \"3\",\r\n    \"a\" : \"4\"\r\n  }\r\n\n\nComment by yihtserns:\n@agavrilov76 can you create another issue for that?  It's not related to this, but rather is caused by #3724.\n\nComment by agavrilov76:\n@yihtserns https://github.com/FasterXML/jackson-databind/issues/3900\n\nComment by cowtowncoder:\nWould #3894 fix solve this as well? I just merged the fix.\n\nComment by matteobertozzi:\nHi, I did run my tests with the 2.15.1-20230504.033533-11 SNAPSHOT\r\n#3894 seems to solve this issue!\r\n\r\nThanks!\r\n\r\n```xml\r\n<repositories>\r\n    <repository>\r\n      <id>oss.sonatype.snapshots</id>\r\n      <url>https://oss.sonatype.org/content/repositories/snapshots</url>\r\n      <snapshots>\r\n        <enabled>true</enabled>\r\n      </snapshots>\r\n    </repository>\r\n  </repositories>\r\n\r\n  <properties>\r\n    <jackson.version>2.15.1-SNAPSHOT</jackson.version>\r\n...\r\n```\n\nComment by cowtowncoder:\nThank you @matteobertozzi !\n\nComment by haraldk:\nI just discovered that the default mapper configuration for the Azure SDK for Java is:\r\n\r\n```java\r\n        .visibility(PropertyAccessor.FIELD, Visibility.ANY)\r\n        .visibility(PropertyAccessor.GETTER, Visibility.NONE)\r\n```\r\n\r\nUpgrading `jackson-databind` to 2.15.0 did break my message serialization in Azure Service Bus... Was about to file a new issue, when I found this. Indeed, 2.15.1-SNAPSHOT does seem to restore things to how it worked in 2.14.2 again. \ud83d\udc4d\ud83c\udffb ",
                "source_code": null,
                "distance": 0.75,
                "title": "2.15.0 breaking behaviour change for records and Getter Visibility",
                "name": "issue#3895",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3895"
                    }
                ],
                "similarity": 0.3375621841737085,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3724",
                "type": "issue",
                "content": "### New\r\n- Supports `@JsonCreator.mode=DISABLED` on canonical constructor.\r\n- Supports deserialization using \"implicit\" (i.e. without `@JsonCreator` annotation) non-canonical constructor when 1/more of its parameter is/are annotated with `@JsonProperty`.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating constructor.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating factory method.\r\n- Supports disabling \"implicit\" (i.e. without `@JsonCreator` annotation) constructor/factory method detection via `MapperFeature.AUTO_DETECT_CREATORS`.\r\n\r\nThis is a non-exhaustive list - I don't have full knowledge of existing JavaBeans deserialization capabilities.\r\n\r\n### Fixes\r\n- Fixes #2974\r\n- Fixes #2992\r\n- Resolves #3180 (via \"implicit\" 1-arg delegating constructor/factory method)\r\n- Fixes #3297\r\n- Fixes #3342\r\n\n\n\nComment by cowtowncoder:\nFirst of all, thank you for contributing this @yihtserns ! It sounds like solid improvement, potentially.\r\n\r\nI added some smaller notes on keeping existing API in some places, but there is one bigger request I have: this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14 -- patches are typically for smaller, less risky changes, and while I don't have specific issues here I feel there is potential for some breakage.\r\n\r\n\n\nComment by yihtserns:\n> ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n\r\nDo I put \"since 2.15\" in the deprecation notice?\r\n\r\nAnd yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter...  That doc needs to be updated?\n\nComment by cowtowncoder:\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n> \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\n\r\n\r\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n\r\nYes.\r\n \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\nThanks, I'll need to update that. There are some things that should go into earlier branches too -- generally earliest maintained, for safe enough fixes. So it is not easy to correctly guess what I think is the right branch :)\r\n(which is also why I don't mind pointing out what I think should be used).\r\n\r\n\r\n\n\nComment by cowtowncoder:\nOk, looks pretty good. I do need to go over it again with more thought, but I like how small changes are.\r\n\n\nComment by cowtowncoder:\n@yihtserns One more thing: I hope to be able to merge this soon. One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution. This only needs to be done once and then it is good for all future PRs for Jackson project.\r\n\r\nDocument is here:\r\n\r\nhttps://github.com/FasterXML/jackson/blob/master/contributor-agreement.pdf\r\n\r\nand the usual way is to print, fill & sign, scan/photo, email to `info` at fasterxml dot com.\r\nOnce I get the document I will be able to merge the PR (I will do one more code review but I assume we are very close).\r\n\r\nThank you again for providing this patch -- looking forward to merging it!\r\n\r\n\r\n\r\n\n\nComment by yihtserns:\nI'm currently re-reviewing if `@JsonIgnore` can be supported in a different way (else the explanation of the current approach will be a headache).\r\n\r\n**UPDATE**: Didn't manage to find a low-change way, so decided to stick with this approach (with some difference) + smothered it with docs.\n\nComment by yihtserns:\n> One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution\r\n\r\nCLA sent.\n\nComment by cowtowncoder:\nOk looks good, will merge! Will see how much trouble merging into `master` (3.0) will be....\n\nComment by cowtowncoder:\nUgh. Ok, so I was able to merge code. But now there are ~20 failures for Record-related tests in `master`.\r\n\r\nAlso: I think I may disagree with test\r\n\r\n        public void testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames() throws Exception\r\n\r\nwherein it is claimed there are 2 usable Creators (canonical, one with `@JsonProperty` annotation).\r\nIt seems to me that while constructor has no `@JsonCreator`, existence of `@JsonProperty` would make that explicit constructor, over canonical constructor.\r\n\r\nBut be that as it may, I think I will need help with `master`, failing tests. I think some calls are now missing so that even simplest of `Record` tests in `RecordsBasicTest` fail.\r\n\r\n\r\n\n\nComment by yihtserns:\n> But be that as it may, I think I will need help with master, failing tests.\r\n\r\nOK I'll look into them.\n\nComment by cowtowncoder:\nThank you @yihtserns! I am zeroing in on one issue: VisibilityChecker for Constructors is somehow claiming default record constructors are not visible. I'll try to see what gives...\n\nComment by cowtowncoder:\nOk, yes; there is something in minimum visibility needed; defaults are defined by `@JsonAutoDetect` annotation in `VisibilityChecker` and have changed to require `public` for 3.0.\r\n\r\nBut what seems odd to me is how canonical constructor is apparently not generated as `public` (looking at decompiled record classes) but as package default.\r\nSo I think one way to fix this would be to somehow use differently configured `VisibilityChecker` for records; similar to have \"all public\" variant is (by default) used for JDK types.\r\nLooks like logic could be injected from `getDefaultVisibilityChecker()` of `MapperConfigBase`; possibly checking if type is a record type (before even checking for \"is JDK class\").\r\n\r\n\n\nComment by yihtserns:\n> But what seems odd to me is how canonical constructor is apparently not generated as public\r\n\r\nThey aren't public because the `record` declarations weren't public.  Changing `record XXX` to `public record XXX` reduced test failures from 21 to 3.\r\n\r\n(For some of the records, although the declaration itself weren't `public`, their _declared_ constructors are `public` so they're not failing.)\n\nComment by yihtserns:\nI've created https://github.com/FasterXML/jackson-databind/pull/3733 (will remain in draft until all test failures are resolved) to deal with issues related to the 3.0 port - let's continue this conversation there.\n\nComment by yihtserns:\n@pjfanning @cowtowncoder thank you for taking the time to review this PR, I really appreciate it.\n\nComment by cowtowncoder:\nFWTW, I think this change may have also caused a regression of one Kotlin test:\r\n\r\nhttps://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\n\nComment by yihtserns:\n> FWTW, I think this change may have also caused a regression of one Kotlin test: https://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\r\nSo [Github396.kt](https://github.com/FasterXML/jackson-module-kotlin/blob/2.15/src/test/kotlin/com/fasterxml/jackson/module/kotlin/test/github/failing/Github396.kt) is a negative test that expects deserialization to fail with `MismatchedInputException`, but it is now by managing to deserialize `<product><stuff></stuff></product>` into `Product(stuff=Stuff(str=null))`.\r\n\r\nThat seems to have been caused by #3676.  When I change `BeanDeserializerBase.getEmptyValue(...)` from `_valueInstantiator.createUsingDefaultOrWithoutArguments(...)` back to `_valueInstantiator.createUsingDefault(...)`, that negative test is passing again.\n\nComment by cowtowncoder:\n@yihtserns Ok. So not these changes but earlier one; and unnoticed since there's no cascading CI builds across projects (that is, without changes to Kotlin module, no CI triggered when databind has changed -- something that'd be really nice to somehow resolve).\r\n\r\nBut this sounds like it would be a good thing? I am not big fan of negative tests because of this, although the main alternative (having failing tests under `failing/`) has the problem of \"hiding\" fixes.\r\n\r\n\n\nComment by cowtowncoder:\n@yihtserns Ok yes, thank you for pointing out the \"failing to fail\" part. This is indeed something fixed in `jackson-dataformat-xml` so I just had to change test. Looking how things work it's actually not a bad idea to verify \"is now fixed\" part... need to keep that in mind wrt other modules :)\n\nComment by yihtserns:\n> Also: I think I may disagree with test `testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames()` wherein it is claimed there are 2 usable Creators (canonical, one with @JsonProperty annotation).\r\nIt seems to me that while constructor has no @JsonCreator, existence of @JsonProperty would make that explicit constructor, over canonical constructor.\r\n\r\n@cowtowncoder when I test the POJO equivalent:\r\n```\r\npublic static class BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator {\r\n\r\n    // Private fields\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(int id, String name, String email) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n    }\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(@JsonProperty(\"id_only\") int id, String email) {\r\n        this.id = id;\r\n        this.email = email;\r\n    }\r\n\r\n    // Public getters\r\n}\r\n```\r\n\r\nI get the same failure as Records':\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.github.yihtserns.records.jackson.RecordCanonicalVsJsonPropertyTest$RecordWithJsonPropertyAndImplicitPropertyWithoutJsonCreator` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n\r\nBug?  Although from a quick search in Issues, nobody is complaining about it anyway.  \ud83e\udd37\u200d\u2642\ufe0f \n\nComment by cowtowncoder:\n@yihtserns If there is no module for getting implicit constructor parameter names, I'd expect failure since partial use of `@JsonProperty` is not enough for detection. But if parameter name detection exists, I am not 100% sure if logic would only allow it if there are no competing constructors (ones with or without annotation).\r\n\r\nThe thing that further complications matters is that POJOs do not have canonical constructor to solve the case where nothing is annotated -- but there are always implicit names.\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nRenovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n\r\nThese are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\n\nComment by yihtserns:\n@leonardehrenfried that symptom sounds similar to the one describe in https://github.com/FasterXML/jackson-databind/issues/3628#issuecomment-1504892161 - let me test that.\n\nComment by yihtserns:\n@leonardehrenfried so I tested `OpenTripPlanner`:\r\n1. Changed `jackson.version` in `pom.xml` to `2.15.0`.\r\n2. Run `mvn test` to observe the test failures (there's 1 unrelated to Records, so I'm ignoring it).\r\n3. Create a local fork of `jackson-databind:2.15.0`, reverting [0a4cfc4](https://github.com/FasterXML/jackson-databind/commit/0a4cfc46bc491aed9eab83e13dcd65d415b10c64#diff-8a89bf8f93c483493c778cda25b2e31e2e89bd4b0a8a131e71bfd2ed5a199fff).\r\n4. Change `OpenTripPlanner/pom.xml`'s `jackson-databind` to refer to that local fork.\r\n5. Run `mvn test` again - no more test failures related to Records.\r\n\r\nI've confirmed that the issue you're facing is related to the broken workaround mentioned in #3628, unrelated to this change.\n\nComment by leonardehrenfried:\nI since checked and we seem to be using a custom object mapper in the test:\r\n\r\n```\r\n      objectMapper = new ObjectMapper();\r\n      objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);\r\n      objectMapper.enable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);\r\n      objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n      objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\r\n      objectMapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);\r\n      objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n      objectMapper.registerModule(new JavaTimeModule());\r\n      objectMapper.registerModule(new Jdk8Module());\r\n\r\n      objectMapper.setVisibility(\r\n        objectMapper\r\n          .getSerializationConfig()\r\n          .getDefaultVisibilityChecker()\r\n          .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n          .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n      );\r\n```\r\n\r\nhttps://github.com/opentripplanner/OpenTripPlanner/blob/dev-2.x/src/test/java/org/opentripplanner/routing/algorithm/mapping/SnapshotTestBase.java#L366-L384\r\n\r\nSo it appears that your analysis is totally correct.\r\n\r\nI'm still not clear if this is was an intentional change in Jackson or not - can you clarify this for me?\r\n\r\nAsked the other way around: is the old behaviour going to be restored and I should just wait for a new release or do I need to change the config of my object mapper?\n\nComment by yihtserns:\n> ...do I need to change the config of my object mapper?\r\n\r\nI think that config was used because you had the same problem as #3628, and I can't think of an alternative solution for that problem.\r\n\r\n> ...is the old behaviour going to be restored and I should just wait for a new release...\r\n\r\nI've helped create #3894 to support that type of config.\n\nComment by cowtowncoder:\n> Renovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n> \r\n> These are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\r\n\r\nThis is why we publish release candidates -- 2.15.0-rc1, rc2, rc3 -- to try to get users to verify if they find any regressions beyond what our unit test suite catches. Nothing was reported for this.\r\n\r\nNow, I don't know what tests you have so I cannot say if behavior is expected or not: sometimes usage is based on undefined behavior, in which case change may be intended (typically due to a fix to some known problem, and change to unsupported case incidental).\r\n\r\nThank you for helping create a new issue. We'll see where that leads.\r\n\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nI'm sorry and as an open source maintainer myself I feel you.\r\n\r\nI'm the last guy showing up on an issue making demands.\r\n\r\nI would love to help diagnose and test and don't expect you to make a potentially broken config work for my benefit.\n\nComment by cowtowncoder:\n@leonardehrenfried Oh and just to make sure: I did not mean to blame you or users at all. I appreciate your reaching out and reporting the issue. I think we can figure this out; PR submitted might be the way, although I have some reservations. But it's a tricky problem.\n\nComment by yihtserns:\n@leonardehrenfried I've spent a bit of time to study your codebase to understand why that config was used - seems like it was to prevent `ApiLeg.getDuration()` from being serialized.\r\n\r\nI assume that is to make assertion easier, since that method returns non-constant number?\r\n\r\nIf that's the case, here's my suggestion (tested with `2.15.0`):\r\n```java\r\npublic abstract class SnapshotTestBase {\r\n    ...\r\n\r\n    private static class SnapshotItinerarySerializer implements SnapshotSerializer {\r\n\r\n        private SnapshotItinerarySerializer() {\r\n            ...\r\n\r\n            // Remove this config:\r\n            //objectMapper.setVisibility(\r\n            //    objectMapper\r\n            //      .getSerializationConfig()\r\n            //      .getDefaultVisibilityChecker()\r\n            //      .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n            //      .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //);\r\n\r\n            // Add this:\r\n            objectMapper.addMixIn(ApiLeg.class, ApiLegMixin.class);\r\n            ...\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * To exclude {@link ApiLeg#getDuration()} from being deserialized because the returned number\r\n     * is non-constant making it impossible to assert.\r\n     */\r\n    private abstract static class ApiLegMixin {\r\n\r\n      @JsonIgnore\r\n      abstract double getDuration();\r\n    }\r\n}\r\n```\n\nComment by leonardehrenfried:\n@yihtserns thanks so much for this. It absolutely fixes the problems we are having. Fantastic work!\n\nComment by agavrilov76:\nRelated to https://github.com/FasterXML/jackson-databind/issues/3900\n\nComment by cowtowncoder:\nAnother breakage: #3938.\n\nComment by yihtserns:\nI used to think \"nobody would ever put a setter in a Record since nothing is mutable, right?\"\r\n\r\nNow I know how ignorant I was...\n\nComment by cowtowncoder:\nTo be honest, that use case is a bit \"Creative\" and just used to prevent deserialization of something without full ignoral.\r\nBut it is something I'd have used with regular POJOs and works very well for what is needed.\r\n\r\nIf someone else has shown that use case to me, I might have argued against it tho, with Records. Given that they are immutable.\r\n\r\nAnyway, was happy to figure out how to make it work again via fix for #3928.\r\n\n\nComment by yihtserns:\nCaused #3968.",
                "source_code": null,
                "distance": 0.75,
                "title": "Change Records deserialization to use the same mechanism as POJO deserialization.",
                "name": "pr#3724",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3724"
                    }
                ],
                "similarity": 0.33638406211705496,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4157",
                "type": "issue",
                "content": "### Describe your Issue\n\nBecause Java is not Delphi ObjectPascal or modern JavaScript or Kotlin, it has no idea of \"properties\", although the JavaBeans specification was an attempt to shoehorn in the concept by guessing based upon convention. That's why in the wild olden days, Jackson assumed that a method `String getDisplayName()` was a getter; and if there were no `setDisplayName(String)`, well, it's a getter to an imputed read-only property. If you didn't like it, you added a `@JsonIgnore` annotation to your class. (Back then we had a heck of a time figuring out how to make an immutable instance if the constructor had `String foo, String bar, \u2026`, too.)\r\n\r\nBut now we have the Java `record`, which (despite its downsides\u2014it's just one step to a lot of other features coming in Java) beautifully encapsulates not only a set of fields, but also the names of the fields and their required order in the constructor! Moreover Java adds some nifty new reflection methods to access records at runtime.\r\n\r\nSo let's say we have this record:\r\n\r\n```java\r\n/**\r\n * A user's profile information.\r\n * @param username The user's login identifier.\r\n * @param firstName The first name of the user.\r\n * @param lastName The last name of the user.\r\n */\r\npublic record UserProfile(@Nonnull String username, @Nonnull String firstName, @Nonnull String lastName) {\r\n\r\n  public UserProfile {\r\n    requireNonNull(username);\r\n    requireNonNull(firstName);\r\n    requireNonNull(lastName);\r\n  }\r\n\r\n  /** @return A form of the user name appropriate for displaying in messages. */\r\n  public String getDisplayName() {\r\n    return firstName() + \" \" + lastName();\r\n  }\r\n\r\n}\r\n```\r\n\r\nWe know at runtime exactly what the constructor types _and names_ (e.g. `username`); and which fields they correspond to. We know what the field getters are (e.g. `username()`. More importantly, we know what methods are _not_ getters, and have nothing to do with the fields\u2014`getDisplayName()` is an example.\r\n\r\nUnfortunately Jackson will generate a JSON object that has a `displayName` attribute, which will prevent the object from being parsed back round-trip, because `displayName` doesn't correspond to any of the record fields.\r\n\r\nMaybe the user wanted to generate a JSON object with the `displayName` attribute and _never use it for deserializing back to a `UserProfile` instance_. That's a valid use case, but it doesn't seem like it should be the default use case.\r\n\r\nI can get around this by adding a `@JsonIgnore`:\r\n\r\n```java\r\n  /** @return A form of the user name appropriate for displaying in messages. */\r\n  @JsonIgnore\r\n  public String getDisplayName() {\r\n    return firstName() + \" \" + lastName();\r\n  }\r\n```\r\n\r\nBut I don't want to dirty the model (even though it's a DTO model) with serialization information unless I have to. As recounted above, at one time we had to. But with Java `record`, we shouldn't have to.\r\n\r\nIs there a way to configure Jackson to automatically ignore non-field methods for Java `record`? If there is something I could use in `JsonMapper.builder()` that would be fine. Is there something like `JsonMapper.builder().serializationMethodInclusion(JsonInclude.Include.NON_RECORD)`? If not, what would you recommend as the best way forward to get this sort of functionality? Is there some little logic I can inject into my `JsonMapper` to detect and handle this case, for example?\n\n\nComment by JooHyukKim:\n> Is there a way to configure Jackson to automatically ignore non-field methods for Java `record`? If there is something I could use in `JsonMapper.builder()` that would be fine. Is there something like `JsonMapper.builder().serializationMethodInclusion(JsonInclude.Include.NON_RECORD)`? If not, what would you recommend as the best way forward to get this sort of functionality? Is there some little logic I can inject into my `JsonMapper` to detect and handle this case, for example?\r\n\r\nOkay, it seems like a usage question, right?\n\nComment by garretwilson:\n> Okay, it seems like a usage question, right?\r\n\r\nWell ultimately this is a request to add an option to turn off automatic serialization of additional methods on Java records. I assume there isn't a way already, but I was asking so as to confirm that first. Being none, I'd like to request that such an option be added.\n\nComment by JooHyukKim:\nI see. Since the issue template is for \"Something Else\", was wondering what the issue would be \ud83d\ude05.\r\n\r\nMaybe we can treat this as \"Feature Request\", but with conditions and maybe add some sort of header, for hint, so others can easily get on helping?\n\nComment by pjfanning:\n@garretwilson have you checked around the web? Plenty of stackoverflow and blogs to look up.\r\n\r\nI've never gone near the visibility settings but they look like the kind of settings that might work here.\r\n\r\nhttps://stackoverflow.com/questions/7105745/how-to-specify-jackson-to-only-use-fields-preferably-globally covers the opposite - only using fields - but maybe you could use some trial and error on this?\n\nComment by cowtowncoder:\n@pjfanning I would recommend against trying make use of Fields `record` types have tho... it requires forcing access and is less than ideal, possibly breaking at some point with later JDKs.\r\n\r\nI think I'd be +1 for new `MapperFeature` -- if need be -- for disabling implicit \"getter-discovery\" for Record types (probably should also disable setter discovery fwtw). And I think it is quite doable.\r\n\r\n... although most likely for 2.17, unless someone can come up with a patch in a day or so; I am trying to close the last issue I really want in for 2.16.\r\n\r\n\r\n\n\nComment by JooHyukKim:\n> ... although most likely for 2.17, unless someone can come up with a patch \r\n\r\n+1 for `2.17` planning \ud83d\udc4d\ud83c\udffc `record` type has taken lots of battle scars past few minor versions, so we may want to take it slow (unless criticial)\n\nComment by JooHyukKim:\n> I think I'd be +1 for new `MapperFeature` -- if need be -- for disabling implicit \"getter-discovery\" for Record types (probably should also disable setter discovery fwtw). And I think it is quite doable.\r\n\r\nThrowing out some naming ideas,\r\n\r\n- `MapperFeature.IGNORE_SETTER_METHODS_IN_RECORD_TYPE`,\r\n- `MapperFeature.IGNORE_GETTER_METHODS_IN_RECORD_TYPE`,\r\n- `MapperFeature.IGNORE_GETTER_AND_SETTER_METHODS_IN_RECORD_TYPE`,\n\nComment by cowtowncoder:\nLooking at existing `MapperFeature`, we have `AUTO_DETECT_GETTERS`. The reason I like referring to auto-detection (or implicit detection) is that this would not ignore explicitly annotated getters; only disable auto-detection -- this so that defining explicit getters is fine since that is often needed (f.ex to change default behavior).\r\n\r\nAnd to refer to both getters and setters we could use term \"accessors\", so could consider `AUTO_DETECT_RECORD_ACCESSORS` (default `true` for backwards compatibility).\r\n\r\nOne possible complication is that users might expect existing `AUTO_DETECT_GETTERS`/`_SETTERS` to still have some effect, so would need to consider semantics there -- for `Mapper-`/`Deserialization-`/`SerializationFeature` we only have on/off setting and no \"use default\".\r\nIn that sense, maybe use of `DISABLE_RECORD_ACCESSOR_AUTO_DETECTION` would make most sense; enabling of which would forcibly prevent auto-detection for Record fields, setters, getters, is-getters (but not Creator detection).\r\n\r\nAnd yes, it does sound like waiting until 2.17 would be prudent, even if this initially seemed like a simple  thing to add.\r\n\n\nComment by yihtserns:\n> I assume there isn't a way already, but I was asking so as to confirm that first.\r\n\r\n> I've never gone near the visibility settings but they look like the kind of settings that might work here.\r\n\r\n> I would recommend against trying make use of Fields record types have tho... it requires forcing access and is less than ideal, possibly breaking at some point with later JDKs.\r\n\r\nIgnoring the question of whether it is an appropriate method or not, just want to note that using (abusing?) visibility seems to be the typical way of achieving this - see:\r\n- #3628\r\n- https://github.com/FasterXML/jackson-databind/pull/3724#issuecomment-1520643404\r\n- #3895\r\n- https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532842582\n\nComment by cowtowncoder:\n@yihtserns yes. On plus side, there are workarounds. On downside all these workarounds probably make it more not less difficult to fix things (since they are now behavior that arguably needs to be supported, being used somewhat widely).\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`MapperFeature` to ignore setter/getter method implicit detection for Record types",
                "name": "issue#4157",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3628"
                    },
                    {
                        "start_node": "issue#3628",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4157"
                    }
                ],
                "similarity": 0.33408685610860583,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4629",
                "type": "issue",
                "content": "### Search before asking\n\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nA JSON field:\r\n- Not included in `@JsonIncludeProperties`, or\r\n- Included in `@JsonIgnoreProperties`\r\n\r\n...will still get deserialized as a Record's component with the same name.\n\n### Version Information\n\nOldest I tried this with is `2.14.2`, latest is `2.18`.\n\n### Reproduction\n\n#### For @JsonIncludeProperties\r\n```java\r\nrecord Id2Name(int id, String name) {\r\n}\r\nrecord RecordWithJsonIncludeProperties(@JsonIncludeProperties(\"id\") Id2Name child) {\r\n}\r\n\r\nRecordWithJsonIncludeProperties value = new ObjectMapper().readValue(\"{\\\"child\\\":{\\\"id\\\":123,\\\"name\\\":\\\"Bob\\\"}}\", RecordWithJsonIncludeProperties.class);\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError:\r\n// Expected :RecordWithJsonIncludeProperties[child=Id2Name[id=123, name=null]]\r\n// Actual   :RecordWithJsonIncludeProperties[child=Id2Name[id=123, name=Bob]]\r\nassertEquals(new RecordWithJsonIncludeProperties(new Id2Name(123, null)), value);\r\n```\r\n\r\n#### For @JsonIgnoreProperties\r\n```java\r\nrecord Id2Name(int id, String name) {\r\n}\r\nrecord RecordWithJsonIgnoreProperties(@JsonIgnoreProperties(\"name\") Id2Name child) {\r\n}\r\n\r\nRecordWithJsonIgnoreProperties value = new ObjectMapper().readValue(\"{\\\"child\\\":{\\\"id\\\":123,\\\"name\\\":\\\"Bob\\\"}}\", RecordWithJsonIgnoreProperties.class);\r\n// failed with:\r\n// org.opentest4j.AssertionFailedError:\r\n// Expected :RecordWithJsonIgnoreProperties[child=Id2Name[id=123, name=null]]\r\n// Actual   :RecordWithJsonIgnoreProperties[child=Id2Name[id=123, name=Bob]]\r\nassertEquals(new RecordWithJsonIgnoreProperties(new Id2Name(123, null)), value);\r\n```\n\n### Expected behavior\n\n_No response_\n\n### Additional context\n\n**NOTE**: I'm not personally affected by this, just something I found when testing for #4626 - I thought they have the same cause, but apparently not.\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "@JsonIncludeProperties & @JsonIgnoreProperties is ignored when deserializing Records",
                "name": "issue#4629",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4626"
                    },
                    {
                        "start_node": "issue#4626",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4629"
                    }
                ],
                "similarity": 0.3325421747810361,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4175",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nWhen deserializing a record, jackson fails with\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of ... (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n```\r\nIt looks like jackson does not see default constructor.\r\n\r\n### Version Information\r\n\r\n2.16.0-rc1\r\n\r\n### Reproduction\r\n\r\n```java\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Tag;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nclass TestObjectTest {\r\n\r\n    @Test\r\n    public void shouldDeserialize() throws JsonProcessingException {\r\n        TestObject testObject = new ObjectMapper().readValue(\"{\\\"text\\\":\\\"anything\\\"}\", TestObject.class);\r\n        Assertions.assertEquals(\"anything\", testObject.text());\r\n    }\r\n\r\n    private record TestObject(String text) {}\r\n}\r\n```\r\n\r\nWhen I add compact constructor with `@JsonCreator` to TestObject, it works correctly:\r\n\r\n```java\r\n    private record TestObject(String text) {\r\n        @JsonCreator\r\n        private TestObject {\r\n        }\r\n    }\r\n```\r\n\r\n### Additional context\r\n\r\n- It works correctly in version 2.15.3\r\n- tested on java 21\r\n- May be related to https://github.com/FasterXML/jackson-databind/issues/4119\n\n\nComment by pjfanning:\n@janpachol we have tests with records like this. I think that this is most likely down to the record being `private` as opposed to the fact that jackson can't handle `public record TestObject(String text) {}`.\n\nComment by pjfanning:\nI created https://github.com/FasterXML/jackson-databind/pull/4176 as a reproducible test case.\n\nComment by janpachol:\nOh, you're correct, but it looks problem is not in private record, but in private constructor (when record is private, it looks that compilation creates also private constructor):\r\n\r\nThis doesn't work:\r\n```java\r\n    public record TestObject(String text) {\r\n        private TestObject {\r\n        }\r\n    }\r\n```\r\nThis works:\r\n```java\r\n    private record TestObject(String text) {\r\n        public TestObject {\r\n        }\r\n    }\r\n```\n\nComment by cowtowncoder:\nYes, it makes sense the issue is `private` constructor via Record being `private` (in the original case).\r\nGiven it is regression from 2.15, would be great to fix.\n\nComment by JooHyukKim:\nCreated a PR for #4178. The issue seems to link back to the fix for #3906 via https://github.com/FasterXML/jackson-databind/commit/75d0c46a4a773d1852ae2305cba9231d465940fc where sort of force setting of record constructor visibility. \n\nComment by cowtowncoder:\nCool. While I have am bit concerned about change causing some other regression, there isn't much that can be done without reproduction of such problem.\r\n\n\nComment by JooHyukKim:\n> Cool. While I have am bit concerned about change causing some other regression, there isn't much that can be done without reproduction of such problem.\r\n\r\nWrt regression, we may already have some tests against regression via https://github.com/FasterXML/jackson-databind/commit/228bc0ef4a59dd47422603a59812768153ddd1c8 --though indirectly covers.",
                "source_code": null,
                "distance": 0.75,
                "title": "Exception when deserialization of `private` record with default constructor",
                "name": "issue#4175",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4175"
                    }
                ],
                "similarity": 0.3300291363174884,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3180",
                "type": "issue",
                "content": "Using Jackson 2.12.\r\n\r\nOne common pattern in code on my teams is to use 'alias' types to decorate otherwise primitive value types in APIs and/or for dimensional units to gain compiler support for detecting otherwise subtle programming errors (such as using the wrong unit or passing parameters in the wrong order).\r\n\r\nToday, to do this with Java records, we need to write classes like\r\n```java\r\npublic record Watts(@JsonValue double value) {\r\n    @JsonCreator\r\n    public static Watts of(double value) {\r\n        return new Watts(value);\r\n    }\r\n}\r\n```\r\nWithout the `@JsonCreator` annotated static method (or similarly trivial but verbose constructor), Jackson produces the error\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `...Watts` \r\n  (although at least one Creator exists): no double/Double-argument constructor/factory method to \r\n  deserialize from Number value (<value>)\r\n```\r\n\r\n\r\nIf we could place `@JsonCreator` on record classes and infer use of the single argument default constructor I think it'd cut the boilerplate even more. Alternatively, or in addition, it might be interesting to infer that a record class with a single labeled `@JsonValue` parameter should use the default constructor, allowing us to write either:\r\n```java\r\n@JsonCreator\r\npublic record Watts(@JsonValue int value) {}\r\n```\r\n\r\nor\r\n```java\r\npublic record Watts(@JsonValue int value) {}\r\n```\r\n\n\n\nComment by yihtserns:\n@markelliot You can do this:\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n    public Watts {}\r\n}\r\n```\r\n---\r\n\r\nBTW, how can this even work in `2.12.0`:\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n    @JsonCreator\r\n    public static Watts of(double value) {\r\n        return new Watts(value);\r\n    }\r\n}\r\n```\r\nUsing that, I'm getting:\r\n> com.fasterxml.jackson.databind.JsonMappingException: Problem with definition of [AnnotedClass <package>.Watts]: Multiple 'as-value' properties defined ([field <package>.Watts#value] vs [method <package>.Watts#value()])\r\n\r\nFor it to work, I need to move the `@JsonValue` annotation to the overridden accessor like this:\r\n```\r\npublic record Watts(double value) {\r\n    @JsonCreator\r\n    public static Watts of(double value) {\r\n        return new Watts(value);\r\n    }\r\n\r\n    @JsonValue // HERE\r\n    @Override\r\n    public double value() {\r\n        return value;\r\n    }\r\n}\r\n```\r\n\r\n**UPDATE**: Apparently this one is a known issue: [#3063d](https://github.com/FasterXML/jackson-databind/issues/3063).\r\n\r\n\n\nComment by markelliot:\nI think the specific minor version for my example was 2.12.2, though I'm unsure if the minor version made a difference in behavior. \r\n\r\nMy example was extracted from:\r\nhttps://github.com/markelliot/allezgo/blob/0.1.0/allezgo-service/src/main/java/io/allezgo/units/Watts.java\r\n\r\nWhere the version of Jackson is specified in:\r\nhttps://github.com/markelliot/allezgo/blob/0.1.0/versions.props#L3\n\nComment by yihtserns:\n@markelliot OK thanks I think I've satisfied my curiousity: a quick scan through the codebase seems to hint that `Watts` is mostly used for JSON deserialization, never for serialization so the `@JsonValue` wasn't used at all which is why no error was experienced.\r\n\r\nBTW does the solution I suggested in the [previous comment](https://github.com/FasterXML/jackson-databind/issues/3180#issuecomment-1305933685) satisfies this request, i.e.:\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n    public Watts {}\r\n}\r\n```\r\n\r\nBut after looking at [Watts.java](https://github.com/markelliot/allezgo/blob/0.1.0/allezgo-service/src/main/java/io/allezgo/units/Watts.java), maybe you'd want this instead to replace the two factory methods:\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n    public Watts(Number value) {\r\n        this(value.doubleValue());\r\n    }\r\n}\r\n```\n\nComment by markelliot:\nThanks -- I'll take your advice on reducing the total boilerplate.\r\n\r\n> BTW does the solution I suggested in the previous comment satisfies this request\r\n\r\nI think it'd be more ergonomic for Jackson to have better default handling of record classes, such as functioning with sane defaults using minimal (or no) annotations:\r\n\r\n```java\r\npublic record Watts(@JsonValue int value) {}\r\n```\n\nComment by cowtowncoder:\n@markelliot Took me a while to understand intent here but I guess I can see it. So the assumption is that use of `@JsonValue` would imply expectation to use `DELEGATING` mode for 1-argument constructed (1-property Record).\r\n\r\nThis may be tricky to pull off, but would also, I think, apply to equivalent non-record POJO case.\r\n\r\nI will file a separate issue since it's both more specific and more general than this issue.\r\n\n\nComment by yihtserns:\n`public record Watts(@JsonValue int value) {}` will work starting from `2.15.x` (auto detects 1-arg constructor + `@JsonValue` as `mode=DELEGATING` creator, thanks to #3724 + #3654), but it won't fully satisfy your need because from the [given example](https://github.com/markelliot/allezgo/blob/0.1.0/allezgo-service/src/main/java/io/allezgo/units/Watts.java), I see that you need to support both `int` & `double` value.\r\n\r\nSo starting from `2.15.x`, if you don't want to use `@JsonCreator` you have these options to choose from:\r\n### Option 1\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n    public Watts(int value) {\r\n        this((double) value);\r\n    }\r\n}\r\n```\r\n### Option 2\r\n```\r\npublic record Watts(@JsonValue double value) {\r\n\r\n    // Method name must be \"valueOf\"\r\n    public static Watts valueOf(int value) { \r\n        return new Watts(value);\r\n    }\r\n}\r\n```\r\n------\r\n**Observation**: Parameter of type `Number` is accepted if a constructor/factory method is annotated with `@JsonCreator`, but not for implicit detector.  \ud83e\udd14 \n\nComment by cowtowncoder:\n@yihtserns Right, `Number` will not work just because there is a small set of \"well-known\" types that are supported (`int`, `long`, `boolean`, `String`, `double`). While it would be possible to expand that there's diminishing return for effort.\r\nBut explicitly annotated creator can use any type -- however, there can only be one such fully-delegating creator method, whereas \"well-known\" types can exist separate from others.\r\n\r\nCome to think of that, the problem with `Number` one would be that it would overlap with all of `int`, `long` and `double` so logic needed to validate Creators would get a bit complicated (I'm sure it's doable with enough effort, `Number` being less-specific than, say, `double`, so would have lower precedence.\r\nBut not sure how valuable it'd be overall.\r\n\r\n\r\n\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Support `@JsonCreator` annotation on record classes",
                "name": "issue#3180",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3063"
                    },
                    {
                        "start_node": "issue#3063",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3180"
                    }
                ],
                "similarity": 0.3119743216158146,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1261",
                "type": "issue",
                "content": "As a follow-up to bug #1255, the patch I provided exposes related deserialization problems.\nI have attached a small project ('jackson-test.zip') to demonstrate these issues. When run with both patches from #1255, the output is provided in the attached 'both.txt'. When run with just the first patch from #1255, the output is provided in the attached 'first.txt'.\nImportant points:\n1. When the object expressed as an id is contained within a collection or map (List in this example), deserialization works correctly. When it is a field of an object, deserialization is broken.\n2. This particular example doesn't have forward references, but it does have cycles. Nevertheless, I have seen situations where non-cyclical forward-references also do not deserialize properly, with the same caveat as in 1.\n[jackson-test.zip](https://github.com/FasterXML/jackson-databind/files/301884/jackson-test.zip)\n[both.txt](https://github.com/FasterXML/jackson-databind/files/301885/both.txt)\n[first.txt](https://github.com/FasterXML/jackson-databind/files/301886/first.txt)\n\n\n\nComment by arifogel:\nI've attached a new version of the test project that also includes forward references. You can see that problem is the same for the cyclical reference to the parent and for the forward reference.\n[jackson-test2.zip](https://github.com/FasterXML/jackson-databind/files/301899/jackson-test2.zip)\n[forward-both.txt](https://github.com/FasterXML/jackson-databind/files/301900/forward-both.txt)\n[forward-first.txt](https://github.com/FasterXML/jackson-databind/files/301901/forward-first.txt)\n\n\nComment by jannispl:\nI think I'm experiencing a similar issue regarding deserialization and cyclic references - during deserialization, Jackson attempts to resolve some fields (like the `@class` field) in a wrong object (wrong scope, the scope before). This results in exceptions like `Unexpected token (END_OBJECT), expected FIELD_NAME: missing property '@class' that is to contain type id` but also `Unrecognized field`. Very hard to explain and visualize. @arifogel Do you think this is relevant to the original issue?\n\n\nComment by arifogel:\nWhat happens is that when an unresolved reference is encountered, an UnresolvedForwardReference is thrown. If you look at the code, this is only caught properly in CollectionDeserializer and MapDeserializer. It does not appear to be handled correctly in BeanDeserializer. So what happens is that when an UnresolvedReference is encountered as a field of a bean, an exception gets thrown that goes down the stack until a MapDeserializer or a CollectionDeserializer catch block is encountered. If there is no such deserializer on the stack, then the error message that eventually gets output is correct (a message about an unresolved forward reference). However if it gets caught in a MapDeserializer or CollectionDeserializer, then all hell breaks loose. Deserialization continues on the bean fields in JSON, but the deserializer thinks it's in a map or collection down the stack. So then nonsensical error messages get output about how the next field after the UnresolvedForwardReference is not compatible with the value type in the map or collection being deserialized.\nI attempted to fix this by adding catch block in BeanDeserializer (the 2nd patch I provided in discussion of bug #1255), but while it stops the crashes, the resulting deserialized objects can still have incorrect values in the case of forward/cyclical references (as noted in this bug description).\nEDIT:\n@jannispl is this explanation consistent with your observations?\n\n\nComment by cowtowncoder:\nLack of catching for beans is particularly puzzling since that is the main use case.\nSo going back to the original pr, #388 (and issue #351) (they were missing from release notes for reason, added), I think that bean property handling should be included via `ObjectIdReferenceProperty`, and question would be why this isn't triggered in test cases. I will try to see what tests uncover.\n\n\nComment by cowtowncoder:\nHmmh. So tests use Creators (constructors). That's typically something that does not mix very well with Object ids, so that's bit of a warning sign. But would explain why it could be an as-of-yet-not-working case.\n\n\nComment by arifogel:\nYes. Unfortunately I cannot avoid using creators in my use case without very significant rewrites to my data model. So I am effectively blocked on this bug at work. Please let me know if there is anything else I can do to help.\n\n\nComment by arifogel:\nOh and I should comment that the Creators don't seem to be a problem when the field is wrapped in a list (as in the test cases provided), so I'm hoping it won't be too hard to generalize what has been done for objects in maps and collections to beans.\n\n\nComment by cowtowncoder:\nLooks like failure that I see is `No _idValue when handleIdValue called`, so in some ways it looks like initialization might be missing. This could be a good sign.\n\nFundamental theoretical problem with Creators is that not all cycles can be ever resolved: if a refers to b, and b refers to a (directly or indirectly), then only one of references can be passed via creator.\nSo although I hope many cases can be supported, there are some hard limits to keep in mind.\n\nAnother thing to keep in mind is this: even when using `@JsonCreator`, it is also possible to use setters: so -- for example -- all non-reference properties can be passed via Creator, and references then passed via setter (or directly assigned to Field).\nSo hybrid schemes are possible.\n\nI think I will try to see if locally modifying properties to use setters or fields would make specific test pass. That gives some information on where problems reside.\n\n\nComment by arifogel:\nBut why does this case work properly for the parentAsList property, but not\nthe parent property? This suggests to be that we are not dealing with a\nfundamental theoretical limitation here, but an implementation problem.\nOn Jun 7, 2016 8:59 PM, \"Tatu Saloranta\" notifications@github.com wrote:\n\n> Looks like failure that I see is No _idValue when handleIdValue called,\n> so in some ways it looks like initialization might be missing. This could\n> be a good sign.\n> \n> Fundamental theoretical problem with Creators is that not all cycles can\n> be ever resolved: if a refers to b, and b refers to a (directly or\n> indirectly), then only one of references can be passed via creator.\n> So although I hope many cases can be supported, there are some hard limits\n> to keep in mind.\n> \n> Another thing to keep in mind is this: even when using @JsonCreator, it\n> is also possible to use setters: so -- for example -- all non-reference\n> properties can be passed via Creator, and references then passed via setter\n> (or directly assigned to Field).\n> So hybrid schemes are possible.\n> \n> I think I will try to see if locally modifying properties to use setters\n> or fields would make specific test pass. That gives some information on\n> where problems reside.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/FasterXML/jackson-databind/issues/1261#issuecomment-224481212,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AHYSEneiHN6j2ScTgguyVlo1U_IcgSU2ks5qJj4agaJpZM4IvkKy\n> .\n\n\nComment by cowtowncoder:\n@arifogel I agree. But I did want to mention eventual challenge in trying to use Creators for Object Id references, to make sure limitations are not a surprise.\n\n\nComment by arifogel:\nSo what discipline do you recommend exactly?\nShould JsonCreator still set every field?\nShould reference fields always be non-final and have a corresponding setter\n(and is that irrelevant when using JsonCreator)?\nHow exactly does one instantiate the hybrid approach?\nOn Jun 7, 2016 9:14 PM, \"Tatu Saloranta\" notifications@github.com wrote:\n\n> @arifogel https://github.com/arifogel I agree. But I did want to\n> mention eventual challenge in trying to use Creators for Object Id\n> references, to make sure limitations are not a surprise.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/FasterXML/jackson-databind/issues/1261#issuecomment-224482826,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AHYSEj42CDhAespjTzS89wRPVukhgdMLks5qJkG3gaJpZM4IvkKy\n> .\n\n\nComment by cowtowncoder:\n@arifogel I would suggest using fields (or setters) for reference properties (except that Collection/Map values appear to be safe as per your comments), and creator for everything else. Nice thing about using fields is that it is possible to keep them private or protected.\n\nAs to resolving issues with creator-passed references: looks like test case passes if only fields (or setters) are used, for what that is worth. I did not try anything fancier, just simple replacement.\nNext step is to reintroduce a failure and see why expected handling is by-passed.\nIt is possible that this could be related to other known issues with Creator property handling (to be worked on 2.9 I hope). That would be both good and bad; good in that it would get resolved along with other work; bad in that I know that work involved is sizable and requires rewrite of property discovery and resolution.\n\n\nComment by cowtowncoder:\n@arifogel I actually suspect the example case is indeed impossible (either in general, even with straight java; or with the Jackson deserialization works, more on that below): note that setup code itself does not pass `child5` as \"favorite child\" for constructor of `parent` -- it can't. Instead test calls setter for that.\nThis is needed to break the cycle.\n\nSo what object model needs to do is the same here; remove \"favorite child\" property from constructor, and leave setter. With that modification test passes locally for me.\n\nAs to Jackson limitations: when dealing with Creators, all parameters must be resolvable when matching JSON Object is complete. Unlike with setter/field injection where deferral of Object Id resolution is possible with catching of exception, it can not be done with Creators because they can only be called once; and further Creator must be called to create the instance. For Collections this is different: they are not created using Creator, but simple no-arguments constructor; and elements may be added afterwards. It would be possible to force failure if custom Creator creator, taking all elements as array/Collection argument, was used; test does not do it and I don't think it is common usage pattern. I think this explains difference you saw wrt Collection/Map case compared to POJOs-with-creator.\n\nI'll try to think of better exception to throw, however; current message is not useful at all.\n\n\nComment by arifogel:\nThanks! I don't think I need to set references in constructors in my main\nproject, so at least now I know how to modify my code to avoid this problem.\nOn Jun 7, 2016 10:14 PM, \"Tatu Saloranta\" notifications@github.com wrote:\n\n> @arifogel https://github.com/arifogel I actually suspect the example\n> case is indeed impossible (either in general, even with straight java; or\n> with the Jackson deserialization works, more on that below): note that\n> setup code itself does not pass child5 as \"favorite child\" for\n> constructor of parent -- it can't. Instead test calls setter for that.\n> This is needed to break the cycle.\n> \n> So what object model needs to do is the same here; remove \"favorite child\"\n> property from constructor, and leave setter. With that modification test\n> passes locally for me.\n> \n> As to Jackson limitations: when dealing with Creators, all parameters must\n> be resolvable when matching JSON Object is complete. Unlike with\n> setter/field injection where deferral of Object Id resolution is possible\n> with catching of exception, it can not be done with Creators because they\n> can only be called once; and further Creator must be called to create the\n> instance. For Collections this is different: they are not created using\n> Creator, but simple no-arguments constructor; and elements may be added\n> afterwards. It would be possible to force failure if custom Creator\n> creator, taking all elements as array/Collection argument, was used; test\n> does not do it and I don't think it is common usage pattern. I think this\n> explains difference you saw wrt Collection/Map case compared to\n> POJOs-with-creator.\n> \n> I'll try to think of better exception to throw, however; current message\n> is not useful at all.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/FasterXML/jackson-databind/issues/1261#issuecomment-224489648,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AHYSEuUD55tTQ2cIZzIhdukZPiZPoJ0rks5qJk_MgaJpZM4IvkKy\n> .\n\n\nComment by cowtowncoder:\n@arifogel Right, I wanted to make sure there is a work-around. I believe there is still something off with handling, so I hope to play with the setup: I added a modified version as a failing test (one with creators used for everything).\n\n\nComment by arifogel:\nOK I implemented the workaround in my code, but I still ran into a similar problem as the one for which I produced the second patch in #1255. The problem is more or less the same: unresolved references for NON-CREATOR properties are properly lazily resolved when they are a value in a collection or map, but not when they are the NON-CREATOR property itself. In the latter case, the exception is caught too far below; the parser continues chomping away at the remaining properties in the bean with the unresolved reference, while the deserializer thinks it's at least one level up from said bean.\n\nSee the new attached patch. I'll follow up later on with a modified small example.\n[patch.txt](https://github.com/FasterXML/jackson-databind/files/305452/patch.txt)\n\nEDIT:\nThis time I did a more comprehensive check to see that my most complex objects are serialized identically both initially and after deserializing and reserializing.\n\n\nComment by arifogel:\nOn further reflection, I think it may make sense to combine this patch with the 2nd one from #1255, with one modification: the handleResolvedForwardReference function from the 2nd patch from #1255 (in the version of BeanReferring that deals with creator properties) should check to see if the value is null, and if so, throw an Exception stating that there is a cycle of final creator fields among objects.\n\nTo be clear, the purpose of BOTH of these patches is to fix handling of unresolved forward references to objects that are direct bean properties so that they are [correctly] handled the same way as values in collections and maps.\nEDIT:\nIf your comment:\n\n> As to Jackson limitations: when dealing with Creators, all parameters must be resolvable when matching JSON Object is complete. Unlike with setter/field injection where deferral of Object Id resolution is possible with catching of exception, it can not be done with Creators because they can only be called once; and further Creator must be called to create the instance. For Collections this is different: they are not created using Creator, but simple no-arguments constructor; and elements may be added afterwards. It would be possible to force failure if custom Creator creator, taking all elements as array/Collection argument, was used; test does not do it and I don't think it is common usage pattern. I think this explains difference you saw wrt Collection/Map case compared to POJOs-with-creator.\n\napplies to creator properties even when there are no cycles, then never mind about using the 2nd patch from #1255.\n\n\nComment by arifogel:\nHmm.. I'm having trouble reproducing my problem with a small example. Better wait on this..\n\n\nComment by arifogel:\nOK @cowtowncoder, I figured it out. My project was taking a different code path than the example you modified. I had JsonCreator functions that took a multitude of non-reference fields that were not being output initially because they were null-valued and I had @JsonInclude(Include.NON_NULL) set. Then when they were being deserialized, since not all creator properties were present, BeanDeserializer._deserializeUsingPropertyBased never thought that we were done with creator properties. As such, non-creator reference properties were deserialized using buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop)) in the same function. This call did not have proper handling for unresolved forward references, unlike the deserialize call after the comment \"// or just clean?\".\n\nMy fix was to modify my code to not have creator properties that could be null-valued.\n\nSo basically the patch I've provided in this issue added that handling to the later code path. I should note that if someone constructs JSON by hand with non-creator reference properties appearing before creator properties, this problem may still pop up. I don't think it's reasonable that field ordering in the JSON should impact execution. In fact, the current serialization code is ugly because it refuses to put fields strictly in alphabetical order, but rather puts creator properties first (I assume to prevent this problem). So I still think my patch (or something similar) should be applied, since it appears to enable arbitrary field ordering.\nNow that I know what caused the problem, I can also provide you with a smaller example (when I have some more free time).\n\n\nComment by arifogel:\nHere is a small example demonstrating the error. Note that simply by adding '@JsonIgnore' to Child.getParent, you can avert the crash.\n[jackson-test.zip](https://github.com/FasterXML/jackson-databind/files/305765/jackson-test.zip)\n[unmodified.txt](https://github.com/FasterXML/jackson-databind/files/305766/unmodified.txt)\n[with-json-ignore-getparent.txt](https://github.com/FasterXML/jackson-databind/files/305767/with-json-ignore-getparent.txt)\n\n\nComment by arifogel:\nAlmost forgot to mention: when you apply my patch, then you get the output in with-json-ignore-getparent.txt even without adding the JsonIgnore annotation. This indicates that this is an inconsistency between handling of unresolved forward references in beans vs maps and collections.\nEDIT: I mean you get the correct output for everything when you apply the patch.\n\n\nComment by cowtowncoder:\n@arifogel Thanks. I agree in that ordering should not matter; serialization order is mostly optimization, not related to correctness of deserialization (but helps in common case as deserializer can avoid possibly costly buffering; just does not count on it). My main concern with original patch was just that adding second place for handling should not be done to cover other problems, so it'd be good to know why initial handling for bean properties was not working. I guess I still don't fully understand that.\n\nBut I hope looking through examples helps. I think @pgelinas implemented original handling so I'll see if he might have suggestions as well.\n\n\nComment by cowtowncoder:\nIn updated tests there seems to be some problem with type resolution, so that array of `Child` instances somehow is not recognized as such. Or perhaps token buffering is incorrectly handled. Regardless there is something wrong there; I can see a failure.\n\n\nComment by cowtowncoder:\n@arifogel After reading through the latest patch it is nice and small, and does fix the issue! Thank you very much for going through the code and figuring out the solution to this problem. It goes in 2.8.0 (.rc2); I am bit hesitant to try to backport it in 2.7.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`@JsonIdentityInfo` deserialization fails with combination of forward references, `@JsonCreator`",
                "name": "issue#1261",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1261"
                    }
                ],
                "similarity": 0.3087503068640697,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3907",
                "type": "issue",
                "content": "There doesn't seem to be coverage for null handling in deserializing of records with default mappers.\r\n\r\nRelates to #3906 \n\n",
                "source_code": null,
                "distance": 1.0,
                "title": "add tests for null handling",
                "name": "pr#3907",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3907"
                    }
                ],
                "similarity": 0.27438884602654,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "147",
                "type": "issue",
                "content": "If a standard ValueInstantiator does not have a complete set of\nproperties, don't fail right away; there may be a later replacement\ncoming from a module.\n\nThe less intrusive solution (catching the exception in `BeanSerializerFactory.findValueInstantiator`) was considered, but I thought that function might benefit from consistent messaging of broken instantiators from Modules as well. Let me know if you'd rather have that approach and I can back out the ValueInstantiator changes.\n\n\n\nComment by cowtowncoder:\nThis seems totally reasonable, will merge. Would it be easy to write a unit test to verify that missing (non-annotated) parameters are still caught when using default ValueInstantiator impl?\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Defer incomplete ValueInstantiator build errors.",
                "name": "pr#147",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    },
                    {
                        "start_node": "issue#562",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#147"
                    }
                ],
                "similarity": 0.27132156509747923,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3904",
                "type": "issue",
                "content": "Here is a small main reproducing the behaviour change:\r\n```kt\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor\r\nimport com.fasterxml.jackson.databind.ObjectMapper\r\nimport com.fasterxml.jackson.module.kotlin.KotlinModule\r\n\r\n\r\nfun main() {\r\n    val mapper = ObjectMapper().apply {\r\n        registerModule(KotlinModule.Builder().build())\r\n        setVisibility(PropertyAccessor.IS_GETTER, JsonAutoDetect.Visibility.NONE)\r\n    }\r\n\r\n    class Foo(val bar: Int) {\r\n        val isZero get() = bar == 0\r\n    }\r\n\r\n    println(mapper.writeValueAsString(Foo(1)))\r\n    // with Jackson 2.14.2, prints: {\"bar\":1}\r\n    // with Jackson 2.15.0, prints: {\"bar\":1,\"isZero\":false}\r\n}\r\n\r\n```\r\nWe serialize these classes with `setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE)` to ignore the isXXX methods, and please note that we cannot use `@JsonIgnore` (\"This annotation is not applicable to target 'member property without backing field or delegate'\").\r\nStarting with Jackson 2.15.0, the `isZero` property is serialized, then the deserialization fails.\r\nThe way we use the visibility feature looks fine to me, this property was correctly ignored at serialization with version 2.14.2, so I would say the 2.15 change does look like a regression.\n\n\nComment by pjfanning:\nCould you move this to the jackson kotlin module? Noone in core jackson team uses Kotlin.\n\nComment by fleiber:\n> Could you move this to the jackson kotlin module? Noone in core jackson team uses Kotlin.\r\n\r\nAs you wish, but I can also edit it to write the same code in Java :)\n\nComment by pjfanning:\ntry a Java example but as long as this remains a Kotlin example, it will probably require us to pass this off to the Kotlin module team to look at\n\nComment by fleiber:\n> try a Java example but as long as this remains a Kotlin example, it will probably require us to pass this off to the Kotlin module team to look at\r\n\r\nI could not reproduce in Java, and with the cleaner example shown in the updated description, the issue disappears when removing the KotlinModule... Let me close this issue and open a new one in the Kotlin module repo.\r\n\r\n [jackson-module-kotlin#669](https://github.com/FasterXML/jackson-module-kotlin/issues/669)\r\n\r\nSorry for the inconvenience,\n\nComment by cowtowncoder:\n@fleiber Thank you for checking this. I think this is related to the nasty incompatibility between Kotlin's handling of \"isXxx\" properties wrt Java Beans handling. I think Kotlin will retain \"is\" part for logical property name (as per Kotlin spec, perfectly fine), but that does not necessarily play nicely with databind as the rules are different.\r\nBut I hope this can be resolved; I don't know what change (and intentional or unintentional) caused behavior to change between versions.\r\n\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "2.15.0 does not seem to honor PropertyAccessor.IS_GETTER visibility anymore",
                "name": "issue#3904",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#3894"
                    },
                    {
                        "start_node": "pr#3894",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3904"
                    }
                ],
                "similarity": 0.26771043773990866,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "532",
                "type": "issue",
                "content": "I have a model class like so:\n\n``` java\npublic class PostProject\n{\n    /* The field template of this project */\n    private List< FieldTemplateObject > field_templates;\n\n    /**\n     * @author Damilola Okuboyejo\n     */\n    @JsonFilter( \"FieldTemplateIdFilter\" )\n    public static class FieldTemplateObject\n    {\n      private int     id;\n      private boolean is_inherited;\n      private String  item_type;\n\n      /**\n       * @return the id\n       */\n      public int getId()\n      {\n         return id;\n      }\n\n      /**\n       * @param id\n       *           the id to set\n       */\n      public void setId( int id )\n      {\n         this.id = id;\n      }\n\n      /**\n       * @return the is_inherited\n       */\n      public boolean isIs_inherited()\n      {\n         return is_inherited;\n      }\n\n      /**\n       * @param is_inherited\n       *           the is_inherited to set\n       */\n      public void setIs_inherited( boolean is_inherited )\n      {\n         this.is_inherited = is_inherited;\n      }\n\n      /**\n       * @return the item_type\n       */\n      public String getItem_type()\n      {\n         if( item_type == null )\n         {\n            item_type = PostProject.item_type;\n         }\n         return item_type;\n      }\n\n      /**\n       * @param item_type\n       *           the item_type to set\n       */\n      public void setItem_type( String item_type )\n      {\n         this.item_type = item_type;\n      }\n   }\n}\n```\n\nAnd a filter serializer:\n\n``` java\npublic static class ModelFieldSerializer extends SimpleBeanPropertyFilter\n{\n  @Override\n  protected boolean include( BeanPropertyWriter writer )\n  {\n     return true;\n  }\n\n  @Override\n  protected boolean include( PropertyWriter writer )\n  {\n     return true;\n  }\n\n  @Override\n  public void serializeAsField( Object pPojo, JsonGenerator pJgen,\n        SerializerProvider pProvider, PropertyWriter pWriter )\n        throws Exception\n  {\n     if( pPojo instanceof FieldTemplateObject )\n     {\n        if( (\"id\".equals( pWriter.getName() ))\n              && ((FieldTemplateObject) pPojo).isIs_inherited() )\n        {\n           pWriter.serializeAsOmittedField( pPojo, pJgen, pProvider );\n        }\n        else\n        {\n           super.serializeAsField( pPojo, pJgen, pProvider, pWriter );\n        }\n     }\n  }\n}\n```\n\nI then added the filter to the mapper, like so:\n\n``` java\nSimpleFilterProvider vSimpleFilterProvider = new SimpleFilterProvider();\nvSimpleFilterProvider.addFilter( \"FieldTemplateIdFilter\",\n                        new FieldTemplateObjectFilter() );\n```\n\nAs soon as I attempt to serliaze the model: \n\n``` java\nString vBody = vJsonMapper.writeValueAsString( pModelObject ),\n```\n\nJackson complains about the filter: 'FieldTemplateIdFilter'\nErrorMessage: ... no FilterProvider configured for id FieldTemplateIdFilter (through reference chain: ... ->java.util.ArrayList[0])\n\n\n\nComment by cowtowncoder:\nHmmh. I don't see you actually adding the provider to mapper in code above? It is just constructing a filter. It needs to be registered with mapper, using `mapper.setFilters()`.\n\n\nComment by dokuboyejo:\nThanks @cowtowncoder \nit was an oversight from my part. That resolved the issue.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "JsonMappingException for @JsonFilter for a List<Pojo>",
                "name": "issue#532",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3063"
                    },
                    {
                        "start_node": "issue#3063",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#532"
                    }
                ],
                "similarity": 0.26636940923570945,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1428",
                "type": "issue",
                "content": "Looks like `@JsonValue` is currently only applicable to `Method`s; should also allow `Field`s for convenience.\n\n\n\nComment by cowtowncoder:\nImplemented for 2.9.0.\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Allow `@JsonValue` on a field, not just getter",
                "name": "issue#1428",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3063"
                    },
                    {
                        "start_node": "issue#3063",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1428"
                    }
                ],
                "similarity": 0.24496626275467193,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3921",
                "type": "issue",
                "content": "This PR provides all cases (including both regression and work-arounds) mentioned in #3906. Thought it might help for future modification/rewrite of (Record, or property discovery in genenral) that seems to be coming.... \ud83d\ude4f\ud83c\udffc\r\n\r\nNOTE: Feel free to close this PR if you think this is unncessary~ \u270c\ufe0f\u270c\ufe0f\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Add tests for `Record` deserialization regression and related",
                "name": "pr#3921",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4627"
                    },
                    {
                        "start_node": "pr#4627",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    },
                    {
                        "start_node": "issue#3906",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3921"
                    }
                ],
                "similarity": 0.2444749356704688,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "258",
                "type": "issue",
                "content": "I have the following POJO hierarchy:\n\n``` java\npublic class Item {\n    @JsonProperty(\"value\")\n    private final String value;\n\n    public Item(String value) {\n        this.value = value;\n    }\n\n    public String getValue() { return value; }\n}\n\n@JsonSerialize(using=Event.EventSerializer.class)\npublic class Event extends Item {\n    @JsonIgnore\n    private final String type;\n\n    public Event(String value, String type) {\n        super(value);\n        this.type = type;\n    }\n\n    public static class EventSerializer extends JsonSerializer<Event> {\n\n        /** {@inheritDoc} */\n        @Override\n        public void serialize(Event event, JsonGenerator generator, SerializerProvider provider)\n                throws IOException {\n            generator.writeStartObject();\n            generator.writeStringField(\"text\", event.getValue());\n            generator.writeEndObject();\n        }\n\n    }\n}\n\npublic class List<T extends Item> {\n    @JsonProperty\n    private final java.util.List<T> results;\n\n    public (java.util.List<T> results) {\n        this.results = results;\n    }\n}\n```\n\nWhen I attempt to serialize a `List<Event>` I get:\n\n``` json\n{\"results\":[{\"text\":\"Some Message.\"}]}  // expected\n{\"results\":[{\"value\":null}]}            // actual\n```\n\nThe problem appears to be `List<T extends Item>` if I use `List<T extends Object>` it works. Ideally I don't want to sacrifice type safety at compile-time to get the right JSON structure to serialize. Is there a workaround?\n\n\n\nComment by novabyte:\nI think essentially my question boils down to why does the custom `Serializer` fail when I use bounded type parameters? Is this a known bug?\n\n\nComment by cowtowncoder:\nGithub Issue tracker is not a Q&A forum, so please ask this question on Jackson mailing list (or jackson-users forum).\n\n\nComment by novabyte:\n@cowtowncoder It's not a Q&A forum agreed, but it is a **bug tracker** and I asked if this example I put together demonstrates a bug...\n\n\nComment by cowtowncoder:\nOk. Fair enough. I have had some cases where basic questions were added, and did not read closely details you did add.\n\nOne thing that is missing is actual code that does serialization: this is actually important here. So if you could add it, that would help.\n\nThe problem has to do with generic type variable, and possible lack of actual type (possible due to that missing piece of code); but behavior does sound odd. Type variable should be resolved to bound; and regardless it should be possible to produce similar output.\n\nBut if you can add call (maybe even trivial unit test method) it should be possible to figure what is going on.\n\n\nComment by novabyte:\n@cowtowncoder In an effort to create a minimal test example of the problem I created this gist using the version of Jackson I've got in my dependencies (`2.1.4`) and much closer to how my code actually looks:\n\nhttps://gist.github.com/novabyte/5989351\n\nHowever, the minimal test case shows that Jackson is working perfectly without having to loosen the bounds of the type parameter in the `List`.\n\nMy actual software stack is [Dropwizard](http://dropwizard.codahale.com/) and I'm serializing to JSON via Jersey. I guess the bug is somewhere else in the stack, some sort of incorrect type coercion going on somewhere in the processing. I don't have the time to find it. I'll use the workaround I mentioned above.\n\nThanks for your time. `:)`\n\n\nComment by cowtowncoder:\nThank you for digging through this. Yes, unfortunately while JAX-RS is a pretty nice standard, it does have issues with passing of root value type. Part of this is that there isn't really anything in JDK to pass true generic types (`java.lang.reflect.Type` is just a tag interface with no functionality). So what is missing is the \"context\" for type (Class in which property is declared).\n\nLonger explanation of these problems can be found here: http://www.cowtowncoder.com/blog/archives/2010/12/entry_436.html\n\nI hope you can work around the problem.\n\nJust in case you want to continue further with this, most likely place where something could perhaps be done is Jackson JAX-RS provider component: https://github.com/FasterXML/jackson-jaxrs-providers\nThat component is responsible for resolving from JAX-RS provided `java.lang.reflect.Type`, and Jackson types. There are some work-around in trying to address edge cases, but perhaps there is something more that could be done. It should at least be possible to reproduce the problem that way, as a unit test.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Serialize Generic <T extends Type>",
                "name": "issue#258",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4626"
                    },
                    {
                        "start_node": "issue#4626",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#258"
                    }
                ],
                "similarity": 0.23338505392754555,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3352",
                "type": "issue",
                "content": "**Is your feature request related to a problem? Please describe.**\r\n\r\nWhen using records in a Java modular app you must add opens declarations to the `module-info.java` for the package which contains the records you want to be serializable/deserializable:\r\n\r\n```java\r\nopens some.package to com.fasterxml.jackson.databind;\r\n```\r\n\r\nIf you do not do this, when it comes to using an object mapper you will fail to deserialize with the error:\r\n\r\n```\r\n Caused by Failed to call `setAccess()` on Field ...... module <module-name> does not \"opens <module-name>\" to module com.fasterxml.jackson.databind\r\n```\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nSince it is a record I would like for there to be no need to provide 'opens' clauses in the `module-info.java` file. \r\n\r\nI do not know if this is actually possible.\r\n\n\n\nComment by cowtowncoder:\nThis problem might be a side-effect of some other issues wrt handling of `Record`s, and if so, could be indirectly solved.\r\n\r\nDoes this problem occur with any Record type, even ones with no annotations, deserialize using basic default `ObjectMapper`, using method `readValue()`?\r\n\n\nComment by robertvazan:\nI can confirm that Jackson 2.13.1 is unable to deserialize public records without opening the package.\n\nComment by robertvazan:\nMy setup:\r\n\r\n```java\r\nObjectMapper mapper = new ObjectMapper(new CBORFactory());\r\nmapper.readValue(serialized, MyRecord.class)\r\n```\n\nComment by cowtowncoder:\nOk but here's my question: wouldn't \"opens\" always be required for Reflection to work both for:\r\n\r\n1. Introspecting methods and fields that infer properties for POJOs and Records?\r\n2. Calling constructor (for deserialization) and getter methods (for serialization)\r\n\r\nand if so access must be given, does not exist by default.\r\n\r\n\r\n\n\nComment by GedMarc:\n@robertvazan use AccessType=Property instead of field ;) \r\n\r\nThis behavior is correct for strict encapsulation, no bug.\n\nComment by GedMarc:\nPut this on your record ;)\r\n``` \r\n@JsonAutoDetect(fieldVisibility = NONE,\r\n                getterVisibility = ANY,\r\n                setterVisibility = ANY)  ```\n\nComment by GedMarc:\n@cowtowncoder using ASM to proxy records into the current module and avoid opens clauses adds too much overhead, I believe the constraints of strict encapsulation must be adhered to, there is a lot of risk in trying to avoid java locking people out of invalid operations\n\nComment by cowtowncoder:\nOk I am just not 100% sure I understand what exactly is allowed and what is not, by default. If introspection of public accessors (field, methods), reflective access are ok, then that'd be fine.\r\nAnd we could conceivably avoid using other access. But I have never been quite sure exactly what the limits are.\r\n\r\nAs to Records tho, with 2.13 at least, no access should be made for fields... I wish I had more time to dig in this as there is no need by Jackson to use fields in case of records. But I didn't think they'd be accessed with latest versions.\r\n\r\n\n\nComment by vab2048:\n@GedMarc\r\n> @cowtowncoder using ASM to proxy records into the current module and avoid opens clauses adds too much overhead, I believe the constraints of strict encapsulation must be adhered to, there is a lot of risk in trying to avoid java locking people out of invalid operations\r\n\r\nI had asked a slightly unrelated question on the [amber mailing list](https://mail.openjdk.java.net/pipermail/amber-dev/2020-December.txt) a while back about records and got some clarification:\r\n\r\n>   Records are named tuples, they are defined only by their components, in a transparent manner i.e. no encapsulation. From a tuple, you can access to the value of each component and from all component values, you can create a tuple. The idea is that, in a method, if you are able to see a record, you can create it. Thus the canonical constructor has the same visibility as the record itself.\r\n\r\nKey point:  ***The idea is that, in a method, if you are able to see a record, you can create it***\r\n\r\nBased on this I don't think there is much risk in future java versions locking people out from serialising/deserialising public records which are in packages which are explicitly exported in the `module-info.java`.\r\n\r\n---\r\n@cowtowncoder \r\n\r\n> Ok but here's my question: wouldn't \"opens\" always be required for Reflection to work both for:\r\n> \r\n>     1. Introspecting methods and fields that infer properties for POJOs and Records?\r\n> \r\n>     2. Calling constructor (for deserialization) and getter methods (for serialization)\r\n> \r\n> \r\n> and if so access must be given, does not exist by default.\r\n\r\nThis is the crux of the matter... can someone please answer definitively? \r\nIdeally we would just require the record to be public and in a package which is exported. Then in the spirit of records being \"dumb data carriers\" we would be able to serialise/deserialise without needing any annotations. \n\nComment by robertvazan:\n@GedMarc I don't want to add annotations to the records themselves, because they are part of public API, but I have tried the following on `ObjectMapper` with no success:\r\n\r\n```java\r\n\tprivate static final ObjectMapper mapper = new ObjectMapper(new CBORFactory())\r\n\t\t.setVisibility(PropertyAccessor.FIELD, Visibility.NONE)\r\n\t\t.setVisibility(PropertyAccessor.GETTER, Visibility.PUBLIC_ONLY)\r\n\t\t.setVisibility(PropertyAccessor.SETTER, Visibility.PUBLIC_ONLY)\r\n\t\t.setVisibility(PropertyAccessor.CREATOR, Visibility.PUBLIC_ONLY);\r\n```\r\n\r\nI have also tried `Visibility.ANY` instead of `Visibility.PUBLIC_ONLY`. I always get `InaccessibleObjectException` unless I open the package.\r\n\r\nThese are public records in exported package, so reflection should work on them according to [setAccessible](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/reflect/Method.html#setAccessible(boolean)) documentation:\r\n\r\n> This method may be used by a caller in class C to enable access to a member of declaring class D if any of the following hold: \r\n>\r\n> - ...\r\n> - The member is public and D is public in a package that the module containing D exports to at least the module containing C.\n\nComment by GedMarc:\n@vab2048 Noted - Yes if the package is exported and not sealed, the API is public and should be accessible across the module-loader, \r\n\r\nI notice two things here, the first is the CBOR factory, So I'm checking the order of the calling for that particular addon, if field access isn't required, checking the field access is not necessary and that might be triggering the invalid access, the other is if the property accessor is being applied in the factory \r\n\r\n@cowtowncoder did say earlier records shouldn't do field access at all, I think he's coming up with a plan around that, but the cbor factory is very important to know in debugging this, thanks!\r\n\n\nComment by cowtowncoder:\nIf there was a way to write a unit test (for maybe `jackson-jdk11-compat-test` or... ?) that shows the problem, I could try digging deeper. But unfortunately I think this is difficult to do. I'd really need to know where access is attempted: although ideally there should be none, it is quite difficult to prove other than having piece of code that shows unintended access.\r\n\r\nMy main suspicion would be that code that does property discovery will attempt to force access, perhaps as a \"backup\" setter via field.\r\n\r\nIf I did have time to proceed with Property Introspection rewrite (long-time plan), this could help here too but... as of now, my time to work on that is rather limited, unfortunately.\r\n\n\nComment by robertvazan:\n@cowtowncoder Why do you think the test would be hard to write? All you need is a tiny Java 16+ project with `module-info.java`, serializable record under `src` in exported package, and unit test attempting to serialize the record.\n\nComment by cowtowncoder:\nSorry, I meant to suggest that getting suitable information out on offending access seemed non-trivial. Not triggering of the issue. Well, that, and then running it from IDE -- I have had some problems with module-info settings wrt test code (esp. with Eclipse).\r\n\r\nBut I'd be happy to find my concerns unfounded. :)\r\n\n\nComment by robertvazan:\n@cowtowncoder Well, exception is trivial to obtain:\r\n\r\n```\r\nCaused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Failed to call `setAccess()` on Field 'width' due to `java.lang.reflect.InaccessibleObjectException`, problem: Unable to make field private final int mypkg.MyClass.width accessible: module mypkg does not \"opens mypkg\" to module com.fasterxml.jackson.databind\r\n at [Source: (byte[])[1306040 bytes]; byte offset: #0]\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1904)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:268)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:642)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4805)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4675)\r\n\tat com.fasterxml.jackson.databind@2.13.1/com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3690)\r\n```\r\n\r\nBut I notice that Jackson fails to include the original exception in exception chain. I set breakpoint on `IllegalArgumentException` and debugger landed here:\r\n\r\n```\r\nClassUtil.checkAndFixAccess(Member, boolean) line: 1009\t\r\nFieldProperty.fixAccess(DeserializationConfig) line: 104\t\r\nBeanDeserializerBuilder._fixAccess(Collection<SettableBeanProperty>) line: 522\t\r\nBeanDeserializerBuilder.build() line: 373\t\r\nBeanDeserializerFactory.buildBeanDeserializer(DeserializationContext, JavaType, BeanDescription) line: 294\t\r\nBeanDeserializerFactory.createBeanDeserializer(DeserializationContext, JavaType, BeanDescription) line: 150\t\r\nDeserializerCache._createDeserializer2(DeserializationContext, DeserializerFactory, JavaType, BeanDescription) line: 415\t\r\nDeserializerCache._createDeserializer(DeserializationContext, DeserializerFactory, JavaType) line: 350\t\r\nDeserializerCache._createAndCache2(DeserializationContext, DeserializerFactory, JavaType) line: 264\t\r\nDeserializerCache._createAndCacheValueDeserializer(DeserializationContext, DeserializerFactory, JavaType) line: 244\t\r\nDeserializerCache.findValueDeserializer(DeserializationContext, DeserializerFactory, JavaType) line: 142\t\r\nDefaultDeserializationContext$Impl(DeserializationContext).findRootValueDeserializer(JavaType) line: 642\t\r\nObjectMapper._findRootDeserializer(DeserializationContext, JavaType) line: 4805\t\r\nObjectMapper._readMapAndClose(JsonParser, JavaType) line: 4675\t\r\nObjectMapper.readValue(byte[], Class<T>) line: 3690\t\r\n```\r\n\r\nMember being accessed is field rather than corresponding getter method, which is also apparent from the exception message. Here I got lost. I have no idea what makes Jackson use fields or getters.\r\n\r\nI tried to add `@JsonAutoDetect` directly on the record as suggested by @GedMarc, but Jackson keeps accessing fields instead of getters.\n\nComment by GedMarc:\n> @cowtowncoder Why do you think the test would be hard to write? All you need is a tiny Java 16+ project with `module-info.java`, serializable record under `src` in exported package, and unit test attempting to serialize the record.\r\n\r\nYou cannot test module-info viability in any unit test unfortunately,  right now the only real way is to create a JLink project and monitor the outputs, what may be working for you in class path mode, will not as a native runtime.  The results from unit tests are not on a modular environment but still run in class path and you are getting away with a lot of incorrect implementations which only appear when turning it off.\r\n\r\nNot an easy task by any means :)\n\nComment by cowtowncoder:\n@robertvazan Thanks, that is useful -- in earlier cases I have only seen warnings wrt access; those do not have stack traces.\r\nBut this is more actionable, given that I can quite easily add chaining to except during troubleshooting.\r\n\r\nThis does leave the issue @GedMarc mentions, but I think that as long as it need not be unit from `jackson-databind` itself but an external project it may be possible. I'm fine with ability to produce stack trace being separate from simple regression test to verify fix (if and when we have it).\r\n\r\nNow as to fields, setters: since Jackson's Record support is based on earlier POJO access, it does consider Fields as potential secondary (or tertiary) way to set property values during deserialization -- that is, each logical property can have one or more modifiers. For Records we do not really need that but I suspect that reuse of earlier functionality leaves some of these access changes in place (i.e. code does not have special handling for Record type in relevant places).\r\nChallenge, then, would be to add more contextual handling to avoid calls to force access in this case where there is a Creator method (constructor); or, even prevent collection of Fields altogether.\r\nIn fact that'd probably be best since there really is no need for Field access for serialization or deserialization, for `Record` types.\r\nTo do that it is necessary to dig into where special Record handling actually starts...  looks like mostly it'd be in `BasicDeserializerFactory`. But where we could actually more easily block Field introspection would be .... `POJOPropertiesCollector`, I think.\r\n\n\nComment by robertvazan:\n@GedMarc I am observing these exceptions in unit tests of the project that defines the records, so unit tests definitely do use modules. The only gotcha I can see is that automatic modules don't work with workspace dependency resolution (in Eclipse at least), so locally modified Jackson has to be installed in local maven repo before it can be tested. I am not sure about the MRJAR `module-info.java` generated by moditect plugin. That one might work with workspace dependencies too.\n\nComment by GedMarc:\nnaw @robertvazan it doesn't quite work like that :) \r\n\r\nThere are a lot of restrictions put in place on the module-info that take place outside of running on a classpath (are you running jdk11^ apps on a JDK?)  - if you are using jar files, you are on a classpath - with the -m flag or not, With the phasing out of this execution mode, the restrictions are being brought in slowly into classpath mode to assist with people moving over \r\nOne of these restrictions which you mention above is Automatic-Module-Name, the specific error is \"Automatic module cannot be used with jlink\" - this change is slated for JDK19/20 to disallow automatic module naming in classpath mode, so best to step away from that now, another example is classpath mode allowing encapsulation passthroughs, where from JDK 16, the restriction is moved from module to classpath which you note above, but for those using modules from JDK 9/11 this has been the default ever since the JDK release (9)\r\n\r\nAlso take note of how the service loader changes as well between the two operational modes\r\n\r\nWe have a jdk11-compat-test which generates the final artifact and performs all necessary validations on the module-info so it works on module \"mode\", which I am updating, I'm just going through a job change right now so it's going a little slow\r\n\r\nThe other thing we need to check on is sealed packages (package-info) and sealed classes, and it's effect on the library as well, especially with records - \r\n\r\nI hope this clears a few things up, and maybe highlights a misstep in some of the assumptions?\n\nComment by vab2048:\n@GedMarc Thanks for stating all these upcoming issues (and the sealed class issue). It is interesting to me as an observer and user of Jackson to see how it will evolve.\r\n\r\n@cowtowncoder I don't have the faintest clue of how to write a unit test for Jackson but I made this repo [here](https://github.com/vab2048/jackson-records-modules-bug) where you can reference the problem with an illustrative integration test. Hope it helps. \r\n\n\nComment by cowtowncoder:\n@vab2048 thank you! Np wrt unit tests part (first things first). I hope to find time to look into this issue in near future (there are a few others on my longish todo list) as it seems possible we might have relatively easy improvements to make. But need to make sure there's a way to verify results with reproduction.\n\nComment by cowtowncoder:\n@vab2048 On sample repo: I may have missed it, but which JDK is required for it? JDK 17?  And is the command to use\r\n\r\n    ./gradlew test\r\n\r\nor something else?\r\n\r\nWith JDK 17 I get failure like so:\r\n\r\n```\r\ntatu@ts-2020 jackson-records-modules-bug % ./gradlew test         \r\nStarting a Gradle Daemon, 1 incompatible Daemon could not be reused, use --status for details\r\n\r\n> Task :test FAILED\r\nError occurred during initialization of boot layer\r\njava.lang.module.FindException: Module org.apiguardian.api not found, required by org.junit.platform.launcher\r\nError occurred during initialization of boot layer\r\njava.lang.module.FindException: Module org.apiguardian.api not found, required by org.junit.platform.launcher\r\nProcess 'Gradle Test Executor 2' finished with non-zero exit value 1\r\norg.gradle.process.internal.ExecException: Process 'Gradle Test Executor 2' finished with non-zero ex\r\n```\r\n\n\nComment by vab2048:\n@cowtowncoder apologies - I was running the test directly in IntelliJ 2021.3.1 (using the JUnit launcher) and it was displaying fine like so:\r\n\r\n![image](https://user-images.githubusercontent.com/9255825/149835272-8ceb28da-2640-43ae-b8b2-c3a74f017dc3.png)\r\n\r\nI have now since updated the build file so `gradlew.bat test` works. The reason for the issue you faced is Gradle bundles their own old version of Jupiter (see [here](https://github.com/junit-team/junit5/issues/2730)) - which I have now overridden in the `build.gradle` file. \r\n\r\nHope this helps.\n\nComment by cowtowncoder:\nThank you! It does; test now runs, fails, and results show the stack trace.\n\nComment by cowtowncoder:\nInterestingly enough, skipping collection of Fields for Record types, in `POJOPropertiesCollector` would avoid the exception. Unfortunately I think it would actually break some pre-JDK17 usage wherein use of fields for Records actually compensates for another flaw in Record handling (Constructor properties not bound to other properties).\r\nThere are 3 new test failures, mostly related to Naming Strategy handling.\r\n\r\nIt could even be that the annotations added in Record declaration are associated with underlying fields (I don't remember if this is the case or not). If so, Fields need to be collected first for the annotations that are then associated with getters and Constructor.\r\n\r\nSo I'll have to think of a less direct route; collecting Fields but preventing their use as Mutators.\r\n\r\n\n\nComment by yihtserns:\n@vab2048 disabling this should fix your issue: http://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/MapperFeature.html#ALLOW_FINAL_FIELDS_AS_MUTATORS.\n\nComment by cowtowncoder:\nOk, with changes from #3736 (via #3737) -- which should fully remove Field discovery for Records -- so I _think_ this would be resolved for 2.15.0.\r\n\r\nHowever, it'd be great if someone could actually verify this (and maybe include instructions here?) so I won't close this if there are remaining issues.\r\n\r\n\n\nComment by Blacklands:\n@cowtowncoder Just tested this in a project with a record, using `2.15.0-SNAPSHOT` of jackson-databind, and on Java 19. Seems to work fine! You just need to `exports` the package to Jackson (`com.fasterxml.jackson.databind` module), `opens` is not necessary.\n\nComment by cowtowncoder:\nOk. Closing this then, thank you @Blacklands.",
                "source_code": null,
                "distance": 0.5,
                "title": "Do not require the usage of opens in a modular app when using records.",
                "name": "issue#3352",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3352"
                    }
                ],
                "similarity": 0.22432468470191824,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "502",
                "type": "issue",
                "content": "When trying to bind the following json: `{\"min\":10,\"max\":\"xxx\"}`\n\nto this java class:\n\n```\nclass Range {\nDouble min;\nDouble max;\n}\n```\n\njackson throws an InvalidFormatException exception:\n`Can not construct instance of java.lang.Double from String value 'xxx': not a valid Double value at [Source: {\"min\":10,\"max\":\"xxx\"}; line: 1, column: 10]`\n\nColumn 10 stops at: `{\"min\":10`, whearas we expect column 22: `{\"min\":10,\"max\":\"xxx\"`\n\n**Proposed fix:**\n\nLooking at the static `from` method from class InvalidFormatException:\n\n```\n        return new InvalidFormatException(msg, jp.getTokenLocation(),\n                value, targetType);\n```\n\nI think it should be:\n\n```\n        return new InvalidFormatException(msg, jp.getCurrentLocation(),\n                value, targetType);\n```\n\n\n\nComment by cowtowncoder:\nThis is bit problematic, for two reasons:\n1. token location is (alas!) incorrectly maintained; it should point to first character of value, but as things are, it points to first character of property name (I think there is an issue reported for this)\n2. current location will most likely point to character after String value in this case.\n\nSo you could say that what you see is due to (1), that is, another bug.\n\n\nComment by jgottero:\nThanks for this explanation; I thought it was a design choice to display the location after the problematic token, as currently that's what we get from many exceptions (all PropertyBindingExceptions...). The icing on the cake would be to get the problematic token itself (when relevant), with its starts/stop location. FYI, I'm currently using a simple lexer to get the token before the exception location to highlight errors in a rich text editor, and it works pretty well, except for this exception. Anyway, I will have a deeper look at the code to see if I can help fixing token locations ;-)\n\n\nComment by cowtowncoder:\nI think one way to look at it is that location to give depends on who detects the problem:\n1. When streaming reader (`JsonParser`) detects the problem, like malformed JSON, it will report exact character since it knows the location\n2. When databind component detects the problem, the token is usually fully decoded, and it does not have more accurate information available; it typically then reports starting location (token location) as that is stable (current location is usually at the end, but with lazy parsing could be somewhere else).\n\nbut yes, it'd be good to get the token location problem fixed. Problem came from parser rewrite a while ago, where parsing of property name was combined with initial decoding of value token; this gave measurable performance improvement. But the issue with location info was not caught at that point, since no tests were checking for this case (all tests only verified either name location, or array value location).\n\n\nComment by cowtowncoder:\nFor sake of completeness, I think the underlying issue is this:\n\nhttps://github.com/FasterXML/jackson-core/issues/37\n\nso will close this (for now?) as duplicate.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "InvalidFormatException reports a wrong location",
                "name": "issue#502",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3439"
                    },
                    {
                        "start_node": "issue#3439",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#502"
                    }
                ],
                "similarity": 0.21616749760658852,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3736",
                "type": "issue",
                "content": "(note: inspired by #3352)\r\n\r\nAlthough Record types do have internal fields for storing data, these should never need to be accessed.\r\nAccess may seem to \"work\" in some cases (if strong module constraints are disabled) but are more likely to cause issues when module access checks are fully enforced.\r\n\r\nSo let's see if we can reduce/remove Field introspection via `POJOPropertiesCollector`.\r\n\r\n\r\n\n\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Try to avoid auto-detecting `Field`s for `Record` types",
                "name": "issue#3736",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    },
                    {
                        "start_node": "pr#3737",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3352"
                    },
                    {
                        "start_node": "issue#3352",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3736"
                    }
                ],
                "similarity": 0.2054890233769359,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3737",
                "type": "issue",
                "content": "\n\n",
                "source_code": null,
                "distance": 0.25,
                "title": "Avoid mutator-inference for Records (to avoid pulling in Fields as mutators)",
                "name": "pr#3737",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3737"
                    }
                ],
                "similarity": 0.2010152786576997,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4635",
                "type": "issue",
                "content": "\n\n\nComment by cowtowncoder:\nNot sure this is going anywhere, bumping into issue of #4634, among other problems.",
                "source_code": null,
                "distance": 0.5,
                "title": "Try to fix #4626, #4630 (start with failing tests)",
                "name": "pr#4635",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4634"
                    },
                    {
                        "start_node": "issue#4634",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4635"
                    }
                ],
                "similarity": 0.14319192955656782,
                "end_line": null,
                "signature": null
            }
        ]
    },
    "artifact_stats": {
        "skipped_due_to_time": 31,
        "valid_related_items": 469
    }
}