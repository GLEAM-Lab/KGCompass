{
    "related_entities": {
        "methods": [
            {
                "start_line": 1385,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated ann) {\n        // 13-May-2024, tatu: Before 2.18, used to delegate to deprecated methods\n        //   like so: no longer with 2.18\n        /*\n        if (hasCreatorAnnotation(ann)) {\n            JsonCreator.Mode mode = findCreatorBinding(ann);\n            if (mode == null) {\n                mode = JsonCreator.Mode.DEFAULT;\n            }\n            return mode;\n        }\n        */\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findCreatorAnnotation",
                "documentation": "/**\n     * Method called to check whether potential Creator (constructor or static factory\n     * method) has explicit annotation to indicate it as actual Creator; and if so,\n     * which {@link com.fasterxml.jackson.annotation.JsonCreator.Mode} to use.\n     *<p>\n     * NOTE: caller needs to consider possibility of both `null` (no annotation found)\n     * and {@link com.fasterxml.jackson.annotation.JsonCreator.Mode#DISABLED} (annotation found,\n     * but disabled); latter is necessary as marker in case multiple introspectors are chained,\n     * as well as possibly as when using mix-in annotations.\n     *\n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param ann Annotated accessor (usually constructor or static method) to check\n     *\n     * @return Creator mode found, if any; {@code null} if none\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findCreatorAnnotation"
                    }
                ],
                "similarity": 0.16979967764778672,
                "end_line": 1398,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findCreatorAnnotation(MapperConfig config, Annotated ann): JsonCreator"
            },
            {
                "start_line": 1415,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean hasCreatorAnnotation(Annotated ann) {\n        return false;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasCreatorAnnotation",
                "documentation": "/**\n     * Method for checking whether given annotated item (method, constructor)\n     * has an annotation\n     * that suggests that the method is a \"creator\" (aka factory)\n     * method to be used for construct new instances of deserialized\n     * values.\n     *\n     * @param ann Annotated entity to check\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     *\n     * @deprecated Since 2.9 use {@link #findCreatorAnnotation} instead.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasCreatorAnnotation"
                    }
                ],
                "similarity": 0.11502467706593132,
                "end_line": 1417,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasCreatorAnnotation(Annotated ann): boolean"
            },
            {
                "start_line": 1433,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonCreator.Mode findCreatorBinding(Annotated ann) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findCreatorBinding",
                "documentation": "/**\n     * Method for finding indication of creator binding mode for\n     * a creator (something for which {@link #hasCreatorAnnotation} returns\n     * true), for cases where there may be ambiguity (currently: single-argument\n     * creator with implicit but no explicit name for the argument).\n     *\n     * @param ann Annotated entity to check\n     *\n     * @return Creator mode found, if any; {@code null} if none\n     *\n     * @since 2.5\n     * @deprecated Since 2.9 use {@link #findCreatorAnnotation} instead.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findCreatorBinding"
                    }
                ],
                "similarity": 0.11162783163466262,
                "end_line": 1435,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findCreatorBinding(Annotated ann): JsonCreator"
            },
            {
                "start_line": 1043,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean hasAnyGetter(Annotated ann) {\n        // 21-Nov-2016, tatu: Delegate in 2.9; remove redirect from later versions\n        if (ann instanceof AnnotatedMethod) {\n            if (hasAnyGetterAnnotation((AnnotatedMethod) ann)) {\n                return true;\n            }\n        }\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasAnyGetter",
                "documentation": "/**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for accessing set of miscellaneous \"extra\"\n     * properties, often bound with matching \"any setter\" method.\n     *\n     * @param ann Annotated entity to check\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasAnyGetter"
                    }
                ],
                "similarity": 0.10376773986223554,
                "end_line": 1051,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasAnyGetter(Annotated ann): Boolean"
            },
            {
                "start_line": 163,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "nopInstance",
                "documentation": "/**\n     * Factory method for accessing \"no operation\" implementation\n     * of introspector: instance that will never find any annotation-based\n     * configuration.\n     *\n     * @return \"no operation\" instance\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "nopInstance"
                    }
                ],
                "similarity": 0.10373440605515935,
                "end_line": 165,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.nopInstance(): AnnotationIntrospector"
            },
            {
                "start_line": 1020,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean hasAsValue(Annotated a) {\n        // 20-Nov-2016, tatu: Delegate in 2.9; remove redirect from later versions\n        if (a instanceof AnnotatedMethod) {\n            if (hasAsValueAnnotation((AnnotatedMethod) a)) {\n                return true;\n            }\n        }\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasAsValue",
                "documentation": "/**\n     * Method for checking whether given method has an annotation\n     * that suggests that the return value of annotated method\n     * should be used as \"the value\" of the object instance; usually\n     * serialized as a primitive value such as String or number.\n     *\n     * @return {@link Boolean#TRUE} if such annotation is found and is not disabled;\n     *   {@link Boolean#FALSE} if disabled annotation (block) is found (to indicate\n     *   accessor is definitely NOT to be used \"as value\"); or `null` if no\n     *   information found.\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasAsValue"
                    }
                ],
                "similarity": 0.09909902003332574,
                "end_line": 1028,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasAsValue(Annotated a): Boolean"
            },
            {
                "start_line": 167,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "pair",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "pair"
                    }
                ],
                "similarity": 0.09543001713392776,
                "end_line": 169,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.pair(AnnotationIntrospector a1, AnnotationIntrospector a2): AnnotationIntrospector"
            },
            {
                "start_line": 608,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JacksonInject.Value findInjectableValue(AnnotatedMember m) {\n        // 05-Apr-2017, tatu: Just for 2.9, call deprecated method to help\n        //    with some cases of overrides for legacy code\n        Object id = findInjectableValueId(m);\n        if (id != null) {\n            return JacksonInject.Value.forId(id);\n        }\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findInjectableValue",
                "documentation": "/**\n     * Method called to find out whether given member expectes a value\n     * to be injected, and if so, what is the identifier of the value\n     * to use during injection.\n     * Type if identifier needs to be compatible with provider of\n     * values (of type {@link InjectableValues}); often a simple String\n     * id is used.\n     *\n     * @param m Member to check\n     *\n     * @return Identifier of value to inject, if any; null if no injection\n     *   indicator is found\n     *\n     * @since 2.9\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findInjectableValue"
                    }
                ],
                "similarity": 0.09315307509030776,
                "end_line": 616,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findInjectableValue(AnnotatedMember m): JacksonInject"
            },
            {
                "start_line": 986,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public PropertyName findNameForSerialization(Annotated a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findNameForSerialization",
                "documentation": "/**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for serialization.\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     *\n     * @param a Property accessor to check\n     *\n     * @return Name to use if found; null if not.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findNameForSerialization"
                    }
                ],
                "similarity": 0.09232610966044474,
                "end_line": 988,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findNameForSerialization(Annotated a): PropertyName"
            },
            {
                "start_line": 1293,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findDeserializationContentConverter",
                "documentation": "/**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * Other notes are same as those for {@link #findDeserializationConverter}\n     *\n     * @param a Annotated property (field, method) to check.\n     *\n     * @since 2.2\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findDeserializationContentConverter"
                    }
                ],
                "similarity": 0.08961497751999382,
                "end_line": 1295,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findDeserializationContentConverter(AnnotatedMember a): Object"
            },
            {
                "start_line": 899,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findSerializationContentConverter",
                "documentation": "/**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * Other notes are same as those for {@link #findSerializationConverter}\n     *\n     * @param a Annotated property (field, method) to check.\n     *\n     * @since 2.2\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findSerializationContentConverter"
                    }
                ],
                "similarity": 0.0891801259325055,
                "end_line": 901,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findSerializationContentConverter(AnnotatedMember a): Object"
            },
            {
                "start_line": 840,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findNullSerializer(Annotated am) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findNullSerializer",
                "documentation": "/**\n     * Method for getting a serializer definition for serializer to use\n     * for nulls (null values) of associated property or type.\n     *\n     * @since 2.3\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findNullSerializer"
                    }
                ],
                "similarity": 0.0886774846761679,
                "end_line": 842,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findNullSerializer(Annotated am): Object"
            },
            {
                "start_line": 463,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonTypeInfo.Value findPolymorphicTypeInfo(MapperConfig<?> config, Annotated ann) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findPolymorphicTypeInfo",
                "documentation": "/**\n     * Method for checking whether given Class or Property Accessor specifies\n     * polymorphic type-handling information, to indicate need for polymorphic\n     * handling.\n     *\n     * @param config Effective mapper configuration in use\n     * @param ann Annotated entity to introspect\n     *\n     * @since 2.16 (backported from Jackson 3.0)\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findPolymorphicTypeInfo"
                    }
                ],
                "similarity": 0.08834446829438838,
                "end_line": 465,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findPolymorphicTypeInfo(MapperConfig config, Annotated ann): JsonTypeInfo"
            },
            {
                "start_line": 852,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findSerializationTyping",
                "documentation": "/**\n     * Method for accessing declared typing mode annotated (if any).\n     * This is used for type detection, unless more granular settings\n     * (such as actual exact type; or serializer to use which means\n     * no type information is needed) take precedence.\n     *\n     * @return Typing mode to use, if annotation is found; null otherwise\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findSerializationTyping"
                    }
                ],
                "similarity": 0.08784829930160999,
                "end_line": 854,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findSerializationTyping(Annotated a): JsonSerialize"
            },
            {
                "start_line": 911,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        return JsonInclude.Value.empty();\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findPropertyInclusion",
                "documentation": "/**\n     * Method for checking inclusion criteria for a type (Class) or property (yes, method\n     * name is bit unfortunate -- not just for properties!).\n     * In case of class, acts as the default for properties POJO contains; for properties\n     * acts as override for class defaults and possible global defaults.\n     *\n     * @since 2.6\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findPropertyInclusion"
                    }
                ],
                "similarity": 0.08635514407224808,
                "end_line": 913,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findPropertyInclusion(Annotated a): JsonInclude"
            },
            {
                "start_line": 651,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonFormat.Value findFormat(Annotated memberOrClass) {\n        return JsonFormat.Value.empty();\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findFormat",
                "documentation": "/**\n     * Method for finding format annotations for property or class.\n     * Return value is typically used by serializers and/or\n     * deserializers to customize presentation aspects of the\n     * serialized value.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findFormat"
                    }
                ],
                "similarity": 0.08551084556839457,
                "end_line": 653,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findFormat(Annotated memberOrClass): JsonFormat"
            },
            {
                "start_line": 210,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "allIntrospectors",
                "documentation": "/**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation adds this introspector in result; this usually\n     * works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     *\n     * @param result Container to add introspectors to\n     *\n     * @return Passed in {@code Collection} filled with introspectors as explained\n     *    above\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "allIntrospectors"
                    }
                ],
                "similarity": 0.08546315770041026,
                "end_line": 213,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.allIntrospectors(Collection result): Collection"
            },
            {
                "start_line": 1457,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public PropertyName findNameForDeserialization(Annotated ann) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findNameForDeserialization",
                "documentation": "/**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for deserialization (reading JSON into POJOs).\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     *\n     * @param ann Annotated entity to check\n     *\n     * @return Name to use if found; {@code null} if not.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findNameForDeserialization"
                    }
                ],
                "similarity": 0.08515103753048715,
                "end_line": 1459,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findNameForDeserialization(Annotated ann): PropertyName"
            },
            {
                "start_line": 560,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean isTypeId(AnnotatedMember am) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "isTypeId",
                "documentation": "/**\n     * Method for checking whether given accessor claims to represent\n     * type id: if so, its value may be used as an override,\n     * instead of generated type id.\n     *\n     * @param am Annotated accessor (field/method/constructor parameter) to check for annotations\n     *\n     * @return Boolean to indicate whether member is a type id or not, if annotation\n     *    found; {@code null} if no information found.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "isTypeId"
                    }
                ],
                "similarity": 0.08475990287859611,
                "end_line": 560,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.isTypeId(AnnotatedMember am): Boolean"
            },
            {
                "start_line": 953,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findSerializationSortAlphabetically",
                "documentation": "/**\n     * Method for checking whether an annotation indicates that serialized properties\n     * for which no explicit is defined should be alphabetically (lexicograpically)\n     * ordered\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findSerializationSortAlphabetically"
                    }
                ],
                "similarity": 0.08449528927596502,
                "end_line": 955,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findSerializationSortAlphabetically(Annotated ann): Boolean"
            },
            {
                "start_line": 877,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findSerializationConverter",
                "documentation": "/**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * serialization. If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * This feature is typically used to convert internal values into types\n     * that Jackson can convert.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit serializer is usually better way to handle serialization.\n     *\n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *\n     * @since 2.2\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findSerializationConverter"
                    }
                ],
                "similarity": 0.08279760779412808,
                "end_line": 879,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findSerializationConverter(Annotated a): Object"
            },
            {
                "start_line": 890,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonNode.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public final JsonNode requiredAt(final JsonPointer path) throws IllegalArgumentException {\n        JsonPointer currentExpr = path;\n        JsonNode curr = this;\n\n        // Note: copied from `at()`\n        while (true) {\n            if (currentExpr.matches()) {\n                return curr;\n            }\n            curr = curr._at(currentExpr); // lgtm [java/dereferenced-value-may-be-null]\n            if (curr == null) {\n                _reportRequiredViolation(\"No node at '%s' (unmatched part: '%s')\",\n                        path, currentExpr);\n            }\n            currentExpr = currentExpr.tail();\n        }\n    }",
                "distance": 1.5,
                "title": null,
                "name": "requiredAt",
                "documentation": "/**\n     * Method is functionally equivalent to\n     *{@code\n     *   at(path).required()\n     *}\n     * and can be used to check that there is an actual value node at specified {@link JsonPointer}\n     * starting from {@code this} node\n     * (but note that value may be explicit JSON null value).\n     * If such value node exists it is returned;\n     * otherwise {@link IllegalArgumentException} is thrown.\n     *\n     * @param path {@link JsonPointer} expression to use for finding value node\n     *\n     * @return Matching value node for given expression\n     *\n     * @throws IllegalArgumentException if no value node exists at given {@code JSON Pointer} path\n     *\n     * @since 2.10\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "properties"
                    },
                    {
                        "start_node": "properties",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "JsonNode"
                    },
                    {
                        "start_node": "JsonNode",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "requiredAt"
                    }
                ],
                "similarity": 0.08211514206089554,
                "end_line": 906,
                "signature": "com.fasterxml.jackson.databind.JsonNode.requiredAt(JsonPointer path): JsonNode"
            },
            {
                "start_line": 1203,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasAnyGetterAnnotation",
                "documentation": "/**\n     * @param am Annotated method to check\n     *\n     * @deprecated Since 2.9 Use {@link #hasAnyGetter} instead\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasAnyGetterAnnotation"
                    }
                ],
                "similarity": 0.08196789005098126,
                "end_line": 1205,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasAnyGetterAnnotation(AnnotatedMethod am): boolean"
            },
            {
                "start_line": 1271,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findDeserializationConverter",
                "documentation": "/**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * deserialization.\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * This feature is typically used to convert intermediate Jackson types\n     * (that default deserializers can produce) into custom type instances.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit deserializer is usually better way to handle deserialization.\n     *\n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *\n     * @since 2.2\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findDeserializationConverter"
                    }
                ],
                "similarity": 0.0818178913198156,
                "end_line": 1273,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findDeserializationConverter(Annotated a): Object"
            },
            {
                "start_line": 191,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Collection<AnnotationIntrospector> allIntrospectors() {\n        return Collections.singletonList(this);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "allIntrospectors",
                "documentation": "/**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation returns a Singleton list with this introspector\n     * as contents.\n     * This usually works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     *\n     * @return Collection of all introspectors starting with this one, in case\n     *    multiple introspectors are chained\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "allIntrospectors"
                    }
                ],
                "similarity": 0.081358528115893,
                "end_line": 193,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.allIntrospectors(): Collection"
            },
            {
                "start_line": 442,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,",
                "distance": 1.25,
                "title": null,
                "name": "findAutoDetectVisibility",
                "documentation": "/**\n     * Method for checking if annotations indicate changes to minimum visibility levels\n     * needed for auto-detecting property elements (fields, methods, constructors).\n     * A baseline checker is given, and introspector is to either return it as is\n     * (if no annotations are found), or build and return a derived instance (using\n     * checker's build methods).\n     *\n     * @param ac Annotated class to introspect\n     * @param checker Default visibility settings in effect before any override\n     *\n     * @return Visibility settings after possible annotation-based overrides\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findAutoDetectVisibility"
                    }
                ],
                "similarity": 0.08085938630967077,
                "end_line": 442,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker checker): VisibilityChecker"
            },
            {
                "start_line": 808,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findSerializer(Annotated am) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findSerializer",
                "documentation": "/**\n     * Method for getting a serializer definition on specified method\n     * or field. Type of definition is either instance (of type {@link JsonSerializer})\n     * or Class (of {@code Class<JsonSerializer>} implementation subtype);\n     * if value of different type is returned, a runtime exception may be thrown by caller.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findSerializer"
                    }
                ],
                "similarity": 0.08031807885435828,
                "end_line": 810,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findSerializer(Annotated am): Object"
            },
            {
                "start_line": 1145,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Enum<?> findDefaultEnumValue(AnnotatedClass ac, Enum<?>[] enumValues) {\n        // 11-Jul-2023, tatu: [databind#4025] redirect to old method for now (to\n        //    help backwards compatibility)\n        @SuppressWarnings(\"unchecked\")\n        Class<Enum<?>> enumCls = (Class<Enum<?>>) ac.getRawType();\n        return findDefaultEnumValue(enumCls);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findDefaultEnumValue",
                "documentation": "/**\n     * Finds the first Enum value that should be considered as default value \n     * for unknown Enum values, if present.\n     *\n     * @param ac The Enum class to scan for the default value.\n     * @param enumValues     The Enum values of the Enum class.\n     * @return null if none found or it's not possible to determine one.\n     *\n     * @since 2.16\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findDefaultEnumValue"
                    }
                ],
                "similarity": 0.07930215452893496,
                "end_line": 1151,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findDefaultEnumValue(AnnotatedClass ac, Enum[] enumValues): Enum"
            },
            {
                "start_line": 1586,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected boolean _hasOneOf(Annotated ann, Class<? extends Annotation>[] annoClasses) {\n        return ann.hasOneOf(annoClasses);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_hasOneOf",
                "documentation": "/**\n     * Alternative lookup method that is used to see if annotation has at least one of\n     * annotations of types listed in second argument.\n     *\n     * @param ann Annotated entity to check for specified annotation\n     * @param annoClasses Types of annotation to find\n     *\n     * @return {@code true} if at least one of specified annotation exists in given entity;\n     *    {@code false} otherwise\n     *\n     * @since 2.7\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_hasOneOf"
                    }
                ],
                "similarity": 0.0790394001464096,
                "end_line": 1588,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector._hasOneOf(Annotated ann, Class[] annoClasses): boolean"
            },
            {
                "start_line": 1570,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    protected boolean _hasAnnotation(Annotated ann, Class<? extends Annotation> annoClass) {\n        return ann.hasAnnotation(annoClass);\n    }",
                "distance": 1.25,
                "title": null,
                "name": "_hasAnnotation",
                "documentation": "/**\n     * Method that should be used by sub-classes for ALL\n     * annotation existence access;\n     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change value seen.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.hasAnnotation(annoClass);\n     *</code>\n     *\n     * @param ann Annotated entity to check for specified annotation\n     * @param annoClass Type of annotation to find\n     *\n     * @return {@code true} if specified annotation exists in given entity; {@code false} if not\n     *\n     * @since 2.5\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "_hasAnnotation"
                    }
                ],
                "similarity": 0.07857056216972091,
                "end_line": 1572,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector._hasAnnotation(Annotated ann, Class annoClass): boolean"
            },
            {
                "start_line": 277,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        return objectIdInfo;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findObjectReferenceInfo",
                "documentation": "/**\n     * Method for figuring out additional properties of an Object Identity reference\n     *\n     * @param ann Annotated entity to introspect\n     * @param objectIdInfo (optional) Base Object Id information, if any; {@code null} if none\n     *\n     * @return {@link ObjectIdInfo} augmented with possible additional information\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findObjectReferenceInfo"
                    }
                ],
                "similarity": 0.07808112195822141,
                "end_line": 279,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo): ObjectIdInfo"
            },
            {
                "start_line": 1307,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonNode.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectNode withObjectProperty(String propName) {\n        // To avoid abstract method, base implementation just fails\n        throw new UnsupportedOperationException(\"`JsonNode` not of type `ObjectNode` (but `\"\n                +getClass().getName()+\")`, cannot call `withObjectProperty(String)` on it\");\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withObjectProperty",
                "documentation": "/**\n     * Method similar to {@link #withObject(JsonPointer, OverwriteMode, boolean)} -- basically\n     * short-cut to:\n     *<pre>\n     *   withObject(JsonPointer.compile(\"/\"+propName), OverwriteMode.NULLS, false);\n     *</pre>\n     * that is, only matches immediate property on {@link ObjectNode}\n     * and will either use an existing {@link ObjectNode} that is\n     * value of the property, or create one if no value or value is {@code NullNode}.\n     * <br>\n     * Will fail with an exception if:\n     * <ul>\n     *  <li>Node method called on is NOT {@link ObjectNode}\n     *   </li>\n     *  <li>Property has an existing value that is NOT {@code NullNode} (explicit {@code null})\n     *   </li>\n     * </ul>\n     *\n     * @param propName Name of property that has or will have {@link ObjectNode} as value\n     *\n     * @return {@link ObjectNode} value of given property (existing or created)\n     *\n     * @since 2.16\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "properties"
                    },
                    {
                        "start_node": "properties",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "JsonNode"
                    },
                    {
                        "start_node": "JsonNode",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withObjectProperty"
                    }
                ],
                "similarity": 0.07755949834295511,
                "end_line": 1311,
                "signature": "com.fasterxml.jackson.databind.JsonNode.withObjectProperty(String propName): ObjectNode"
            },
            {
                "start_line": 716,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public String findImplicitPropertyName(AnnotatedMember member) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "findImplicitPropertyName",
                "documentation": "/**\n     * Method for finding implicit name for a property that given annotated\n     * member (field, method, creator parameter) may represent.\n     * This is different from explicit, annotation-based property name, in that\n     * it is \"weak\" and does not either proof that a property exists (for example,\n     * if visibility is not high enough), or override explicit names.\n     * In practice this method is used to introspect optional names for creator\n     * parameters (which may or may not be available and cannot be detected\n     * by standard databind); or to provide alternate name mangling for\n     * fields, getters and/or setters.\n     *\n     * @since 2.4\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findImplicitPropertyName"
                    }
                ],
                "similarity": 0.07745742948265832,
                "end_line": 716,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findImplicitPropertyName(AnnotatedMember member): String"
            },
            {
                "start_line": 818,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findKeySerializer(Annotated am) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findKeySerializer",
                "documentation": "/**\n     * Method for getting a serializer definition for keys of associated {@code java.util.Map} property.\n     * Type of definition is either instance (of type {@link JsonSerializer})\n     * or Class (of type  {@code Class<JsonSerializer>});\n     * if value of different type is returned, a runtime exception may be thrown by caller.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findKeySerializer"
                    }
                ],
                "similarity": 0.07665199945726163,
                "end_line": 820,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findKeySerializer(Annotated am): Object"
            },
            {
                "start_line": 378,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findNamingStrategy(AnnotatedClass ac) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "findNamingStrategy",
                "documentation": "/**\n     * Method for finding {@link PropertyNamingStrategy} for given\n     * class, if any specified by annotations; and if so, either return\n     * a {@link PropertyNamingStrategy} instance, or Class to use for\n     * creating instance\n     *\n     * @param ac Annotated class to introspect\n     *\n     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n     *   is specified for given class; null if not.\n     *\n     * @since 2.1\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findNamingStrategy"
                    }
                ],
                "similarity": 0.07662316536128119,
                "end_line": 378,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findNamingStrategy(AnnotatedClass ac): Object"
            },
            {
                "start_line": 1353,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findPOJOBuilder",
                "documentation": "/**\n     * Method for finding Builder object to use for constructing\n     * value instance and binding data (sort of combining value\n     * instantiators that can construct, and deserializers\n     * that can bind data).\n     *<p>\n     * Note that unlike accessors for some helper Objects, this\n     * method does not allow returning instances: the reason is\n     * that builders have state, and a separate instance needs\n     * to be created for each deserialization call.\n     *\n     * @param ac Annotated class to introspect\n     *\n     * @return Builder class to use, if annotation found; {@code null} if not.\n     *\n     * @since 2.0\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findPOJOBuilder"
                    }
                ],
                "similarity": 0.07657521143433975,
                "end_line": 1355,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findPOJOBuilder(AnnotatedClass ac): Class"
            },
            {
                "start_line": 1171,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonNode.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ObjectNode withObject(String exprOrProperty) {\n        // To avoid abstract method, base implementation just fails\n        throw new UnsupportedOperationException(\"`withObject(String)` not implemented by `\"\n                +getClass().getName()+\"`\");\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withObject",
                "documentation": "/**\n     * Method that works in one of possible ways, depending on whether\n     * {@code exprOrProperty} is a valid {@link JsonPointer} expression or\n     * not (valid expression is either empty String {@code \"\"} or starts\n     * with leading slash {@code /} character).\n     * If it is, works as a short-cut to:\n     *<pre>\n     *  withObject(JsonPointer.compile(exprOrProperty));\n     *</pre>\n     * If it is NOT a valid {@link JsonPointer} expression, value is taken\n     * as a literal Object property name and calls is alias for\n     *<pre>\n     *  withObjectProperty(exprOrProperty);\n     *</pre>\n     *\n     * @param exprOrProperty {@link JsonPointer} expression to use (if valid as one),\n     *    or, if not (no leading \"/\"), property name to match.\n     *\n     * @return {@link ObjectNode} found or created\n     *\n     * @since 2.14 (but semantics before 2.16 did NOT allow for non-JsonPointer expressions)\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "properties"
                    },
                    {
                        "start_node": "properties",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "JsonNode"
                    },
                    {
                        "start_node": "JsonNode",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withObject"
                    }
                ],
                "similarity": 0.07573069077838136,
                "end_line": 1175,
                "signature": "com.fasterxml.jackson.databind.JsonNode.withObject(String exprOrProperty): ObjectNode"
            },
            {
                "start_line": 830,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findContentSerializer(Annotated am) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findContentSerializer",
                "documentation": "/**\n     * Method for getting a serializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or {@code Map} property.\n     * Type of definition is either instance (of type {@link JsonSerializer})\n     * or Class (of type  {@code Class<JsonSerializer>});\n     * if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findContentSerializer"
                    }
                ],
                "similarity": 0.07570591903168092,
                "end_line": 832,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findContentSerializer(Annotated am): Object"
            },
            {
                "start_line": 1487,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        if (ann != null) {\n            return ann.mode();\n        }\n        if (_cfgConstructorPropertiesImpliesCreator\n                && config.isEnabled(MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES)\n            ) {\n            if (a instanceof AnnotatedConstructor) {\n                if (_java7Helper != null) {\n                    Boolean b = _java7Helper.hasCreatorAnnotation(a);\n                    if ((b != null) && b.booleanValue()) {\n                        // 13-Sep-2016, tatu: Judgment call, but I don't think JDK ever implies\n                        //    use of delegate; assumes as-properties implicitly\n                        return JsonCreator.Mode.PROPERTIES;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
                "distance": 2.75,
                "title": null,
                "name": "findCreatorAnnotation",
                "documentation": "",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasAnyGetter"
                    },
                    {
                        "start_node": "hasAnyGetter",
                        "description": "calls method",
                        "type": "RELATED",
                        "end_node": "hasAnyGetterAnnotation"
                    },
                    {
                        "start_node": "hasAnyGetterAnnotation",
                        "description": "contained in class",
                        "type": "RELATED",
                        "end_node": "JacksonAnnotationIntrospector"
                    },
                    {
                        "start_node": "JacksonAnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findCreatorAnnotation"
                    }
                ],
                "similarity": 0.07521481304985014,
                "end_line": 1507,
                "signature": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector.findCreatorAnnotation(MapperConfig config, Annotated a): JsonCreator"
            },
            {
                "start_line": 1003,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean hasAsKey(MapperConfig<?> config, Annotated a) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "hasAsKey",
                "documentation": "/**\n     * Method for checking whether given method has an annotation\n     * that suggests the return value of annotated field or method\n     * should be used as \"the key\" of the object instance; usually\n     * serialized as a primitive value such as String or number.\n     *\n     * @return {@link Boolean#TRUE} if such annotation is found and is not disabled;\n     *   {@link Boolean#FALSE} if disabled annotation (block) is found (to indicate\n     *   accessor is definitely NOT to be used \"as value\"); or `null` if no\n     *   information found.\n     *\n     * @since 2.12\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasAsKey"
                    }
                ],
                "similarity": 0.0750322900038782,
                "end_line": 1005,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasAsKey(MapperConfig config, Annotated a): Boolean"
            },
            {
                "start_line": 783,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public PropertyName findRenameByField(MapperConfig<?> config,",
                "distance": 1.25,
                "title": null,
                "name": "findRenameByField",
                "documentation": "/**\n     * Method called on fields that are eligible candidates for properties\n     * (that is, non-static member fields), but not necessarily selected (may\n     * or may not be visible), to let fields affect name linking.\n     * Call will be made after finding implicit name (which by default is just\n     * name of the field, but may be overridden by introspector), but before\n     * discovering other accessors.\n     * If non-null name returned, it is to be used to find other accessors (getters,\n     * setters, creator parameters) and replace their implicit names with that\n     * of field's implicit name (assuming they differ).\n     *<p>\n     * Specific example (and initial use case is for support Kotlin's \"is getter\"\n     * matching (see\n     * <a href=\"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html\">Kotling Interop</a>\n     * for details), in which field like '{@code isOpen}' would have implicit name of\n     * \"isOpen\", match getter {@code getOpen()} and setter {@code setOpen(boolean)},\n     * but use logical external name of \"isOpen\" (and not implicit name of getter/setter, \"open\"!).\n     * To achieve this, field implicit name needs to remain \"isOpen\" but this method needs\n     * to return name {@code PropertyName.construct(\"open\")}: doing so will \"pull in\" getter\n     * and/or setter, and rename them as \"isOpen\".\n     *\n     * @param config Effective mapper configuration in use\n     * @param f Field to check\n     * @param implName Implicit name of the field; usually name of field itself but not always,\n     *    used as the target name for accessors to rename.\n     *\n     * @return Name used to find other accessors to rename, if any; {@code null} to indicate\n     *    no renaming\n     *\n     * @since 2.11\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findRenameByField"
                    }
                ],
                "similarity": 0.07490008858163909,
                "end_line": 783,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findRenameByField(MapperConfig config, AnnotatedField f, PropertyName implName): PropertyName"
            },
            {
                "start_line": 676,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public String findPropertyDefaultValue(Annotated ann) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "findPropertyDefaultValue",
                "documentation": "/**\n     * Method for finding suggested default value (as simple textual serialization)\n     * for the property. While core databind does not make any use of it, it is exposed\n     * for extension modules to use: an expected use is generation of schema representations\n     * and documentation.\n     *\n     * @since 2.5\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findPropertyDefaultValue"
                    }
                ],
                "similarity": 0.07488231845538987,
                "end_line": 676,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findPropertyDefaultValue(Annotated ann): String"
            },
            {
                "start_line": 1220,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Object findDeserializer(Annotated am) {\n        return null;\n    }",
                "distance": 1.25,
                "title": null,
                "name": "findDeserializer",
                "documentation": "/**\n     * Method for getting a deserializer definition on specified method\n     * or field.\n     * Type of definition is either instance (of type {@link JsonDeserializer})\n     * or Class (of type  {@code Class&<JsonDeserializer>});\n     * type is returned, a runtime exception may be thrown by caller.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findDeserializer"
                    }
                ],
                "similarity": 0.07482508176584235,
                "end_line": 1222,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findDeserializer(Annotated am): Object"
            },
            {
                "start_line": 316,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "isIgnorableType",
                "documentation": "/**\n     * Method for checking whether properties that have specified type\n     * (class, not generics aware) should be completely ignored for\n     * serialization and deserialization purposes.\n     *\n     * @param ac Annotated class to introspect\n     *\n     * @return Boolean.TRUE if properties of type should be ignored;\n     *   Boolean.FALSE if they are not to be ignored, null for default\n     *   handling (which is 'do not ignore')\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "isIgnorableType"
                    }
                ],
                "similarity": 0.07474481270962174,
                "end_line": 316,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.isIgnorableType(AnnotatedClass ac): Boolean"
            },
            {
                "start_line": 1332,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonNode.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public <T extends JsonNode> T with(String exprOrProperty) {\n        throw new UnsupportedOperationException(\"`JsonNode` not of type `ObjectNode` (but \"\n                                +getClass().getName()+\"), cannot call `with(String)` on it\");\n    }",
                "distance": 1.5,
                "title": null,
                "name": "with",
                "documentation": "/**\n     * Method that works in one of possible ways, depending on whether\n     * {@code exprOrProperty} is a valid {@link JsonPointer} expression or\n     * not (valid expression is either empty String {@code \"\"} or starts\n     * with leading slash {@code /} character).\n     * If it is, works as a short-cut to:\n     *<pre>\n     *  withObject(JsonPointer.compile(exprOrProperty));\n     *</pre>\n     * If it is NOT a valid {@link JsonPointer} expression, value is taken\n     * as a literal Object property name and traversed like a single-segment\n     * {@link JsonPointer}.\n     *<p>\n     * NOTE: before Jackson 2.14 behavior was always that of non-expression usage;\n     * that is, {@code exprOrProperty} was always considered as a simple property name.\n     *\n     * @deprecated Since 2.14 use {@link #withObject(String)} instead\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "properties"
                    },
                    {
                        "start_node": "properties",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "JsonNode"
                    },
                    {
                        "start_node": "JsonNode",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "with"
                    }
                ],
                "similarity": 0.07460662442889121,
                "end_line": 1335,
                "signature": "com.fasterxml.jackson.databind.JsonNode.with(String exprOrProperty): T"
            },
            {
                "start_line": 623,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "hasRequiredMarker",
                "documentation": "/**\n     * Method that can be called to check whether this member has\n     * an annotation that suggests whether value for matching property\n     * is required or not.\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasRequiredMarker"
                    }
                ],
                "similarity": 0.07445875535250998,
                "end_line": 623,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasRequiredMarker(AnnotatedMember m): Boolean"
            },
            {
                "start_line": 548,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public String findTypeName(AnnotatedClass ac) { return null; }",
                "distance": 1.25,
                "title": null,
                "name": "findTypeName",
                "documentation": "/**\n     * Method for checking if specified type has explicit name.\n     *\n     * @param ac Class to check for type name annotations\n     *\n     * @return Explicit type name (aka Type Id) found, if any; {@code null} if none\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "findTypeName"
                    }
                ],
                "similarity": 0.07368733400757554,
                "end_line": 548,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.findTypeName(AnnotatedClass ac): String"
            },
            {
                "start_line": 591,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }",
                "distance": 1.25,
                "title": null,
                "name": "hasIgnoreMarker",
                "documentation": "/**\n     * Method called to check whether given property is marked to\n     * be ignored. This is used to determine whether to ignore\n     * properties, on per-property basis, usually combining\n     * annotations from multiple accessors (getters, setters, fields,\n     * constructor parameters).\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "hasIgnoreMarker"
                    }
                ],
                "similarity": 0.07355670540191718,
                "end_line": 591,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.hasIgnoreMarker(AnnotatedMember m): boolean"
            },
            {
                "start_line": 1309,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public JavaType refineDeserializationType(final MapperConfig<?> config,",
                "distance": 1.25,
                "title": null,
                "name": "refineDeserializationType",
                "documentation": "/**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "AnnotationIntrospector"
                    },
                    {
                        "start_node": "AnnotationIntrospector",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "refineDeserializationType"
                    }
                ],
                "similarity": 0.0731244233571777,
                "end_line": 1309,
                "signature": "com.fasterxml.jackson.databind.AnnotationIntrospector.refineDeserializationType(MapperConfig config, Annotated a, JavaType baseType): JavaType"
            },
            {
                "start_line": 1485,
                "file_path": "playground/fasterxml__jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonNode.java",
                "issue_id": null,
                "type": "method",
                "content": null,
                "source_code": "    public ArrayNode withArrayProperty(String propName) {\n        // To avoid abstract method, base implementation just fails\n        throw new UnsupportedOperationException(\"`JsonNode` not of type `ObjectNode` (but `\"\n                +getClass().getName()+\")`, cannot call `withArrayProperty(String)` on it\");\n    }",
                "distance": 1.5,
                "title": null,
                "name": "withArrayProperty",
                "documentation": "/**\n     * Method similar to {@link #withArray(JsonPointer, OverwriteMode, boolean)} -- basically\n     * short-cut to:\n     *<pre>\n     *   withArray(JsonPointer.compile(\"/\"+propName), OverwriteMode.NULLS, false);\n     *</pre>\n     * that is, only matches immediate property on {@link ObjectNode}\n     * and will either use an existing {@link ArrayNode} that is\n     * value of the property, or create one if no value or value is {@code NullNode}.\n     * <br>\n     * Will fail with an exception if:\n     * <ul>\n     *  <li>Node method called on is NOT {@link ObjectNode}\n     *   </li>\n     *  <li>Property has an existing value that is NOT {@code NullNode} (explicit {@code null})\n     *   </li>\n     * </ul>\n     *\n     * @param propName Name of property that has or will have {@link ArrayNode} as value\n     *\n     * @return {@link ArrayNode} value of given property (existing or created)\n     *\n     * @since 2.16\n     */",
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "properties"
                    },
                    {
                        "start_node": "properties",
                        "description": "contained in method",
                        "type": "RELATED",
                        "end_node": "JsonNode"
                    },
                    {
                        "start_node": "JsonNode",
                        "description": "contains class",
                        "type": "RELATED",
                        "end_node": "withArrayProperty"
                    }
                ],
                "similarity": 0.07310364934292925,
                "end_line": 1489,
                "signature": "com.fasterxml.jackson.databind.JsonNode.withArrayProperty(String propName): ArrayNode"
            }
        ],
        "classes": [],
        "issues": [
            {
                "content": "### Is your feature request related to a problem? Please describe.\r\n\r\nRelates to and described in https://github.com/FasterXML/jackson-module-kotlin/issues/805, to help better reduce maintenance points on module side.\r\n\r\n### Describe the solution you'd like\r\n\r\nProvide extension point for modules (esp. per language, like jackson-module-kotlin) to indicate primary Creator (usually properties-based constructor) to use if no annotations used: this is typically referred to as \"Canonical\" creator. Concept also exists in Java, for Record types.\r\n\r\nThe most obvious approach would be to add a new method (or methods) in `AnnotationIntrospector` as this is an existing extensible mechanism already used by language modules.\r\n\r\n### Usage example\r\n\r\nUsage to be discussed.\r\n\r\n### Additional context\r\n\r\nSee #4515 for work that enabled possibility to detect Canonical creator (for Java Records).\r\n\r\nFeel free to edit the title and all @cowtowncoder \n",
                "distance": 0,
                "title": "Provide extension point for detecting \"primary\" Constructor for Kotlin (and similar) data classes",
                "name": "root",
                "path": [],
                "issue_id": "root",
                "similarity": 2.0,
                "type": "issue"
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4584",
                "type": "issue",
                "content": "### Is your feature request related to a problem? Please describe.\r\n\r\nRelates to and described in https://github.com/FasterXML/jackson-module-kotlin/issues/805, to help better reduce maintenance points on module side.\r\n\r\n### Describe the solution you'd like\r\n\r\nProvide extension point for modules (esp. per language, like jackson-module-kotlin) to indicate primary Creator (usually properties-based constructor) to use if no annotations used: this is typically referred to as \"Canonical\" creator. Concept also exists in Java, for Record types.\r\n\r\nThe most obvious approach would be to add a new method (or methods) in `AnnotationIntrospector` as this is an existing extensible mechanism already used by language modules.\r\n\r\n### Usage example\r\n\r\nUsage to be discussed.\r\n\r\n### Additional context\r\n\r\nSee #4515 for work that enabled possibility to detect Canonical creator (for Java Records).\r\n\r\nFeel free to edit the title and all @cowtowncoder \n\n",
                "source_code": null,
                "distance": 0.5,
                "title": "Provide extension point for detecting \"primary\" Constructor for Kotlin (and similar) data classes",
                "name": "issue#4584",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4615"
                    },
                    {
                        "start_node": "pr#4615",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4584"
                    }
                ],
                "similarity": 0.7701889550136743,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4615",
                "type": "issue",
                "content": "Implements #4584.\n\n",
                "source_code": null,
                "distance": 0.25,
                "title": "Fixes #4584: add AnnotationIntrospector method for default Creator discovery (`findDefaultCreator()`)",
                "name": "pr#4615",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4615"
                    }
                ],
                "similarity": 0.6187308256402685,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3758",
                "type": "issue",
                "content": "**Is your feature request related to a problem? Please describe.**\r\n`AnnotationIntrospector` registered with `appendAnnotationIntrospector` is expected to be called after all higher priority `AnnotationIntrospectors` have been processed.\r\nFor example, if a `JsonCreator` is present in the class, the `findCreatorAnnotation` function is not expected to be called.\r\n\r\nOn the other hand, in the current situation, all `AnnotationIntrospectors` will try to process one target.\r\n\r\n**Describe the solution you'd like**\r\nEnsure that `AnnotationIntrospectors` registered with `appendAnnotationIntrospector` are called after all `AnnotationIntrospectors` with higher priority have been processed.\r\n\r\n**Usage example**\r\nBy changing the behavior in this way, processing related to the case where nothing is specified can be implemented.\r\nIn the `findJsonCreator` function example, such an implementation currently requires checking that the class does not contain any other `JsonCreator`.\r\nAlso, it is not possible to implement the function in such a way that it does not overwrite a `JsonCreator` that is specified with a higher priority by another module.\r\n\r\n**Additional context**\r\nThis would require a huge change, such as eliminating `AnnotationIntrospectorPair`.\r\nProbably not possible to achieve this until `Jackson 3.0`.\n\n\nComment by cowtowncoder:\nI don't quite understand suggested problem here. `AnnotationIntrospectorPair` handles calls to lower priority introspectors based on results from higher priority ones; merging information if necessary (and if possible). This is done on per-annotation basis (one by one).\r\n\r\nAlso keep in mind that although name of class is `AnnotationIntrospector`, the idea is that information used may come from alternate sources, not just annotations.\r\n\r\nWould it be possible to show an example of specific problem?\r\n\r\n\n\nComment by k163377:\nThis is the case for the following implementation(`KotlinNamesAnnotationIntrospector` is registered by `appendAnnotationIntrospector`)\r\nhttps://github.com/FasterXML/jackson-module-kotlin/blob/062176cbf53e6a60b1a1d9080708a4c168b6a17a/src/main/kotlin/com/fasterxml/jackson/module/kotlin/KotlinNamesAnnotationIntrospector.kt#L81-L88\r\n\r\nThis process is intended to \"use the `Kotlin Primary Constructor` if no other `JsonCreator` is specified.\r\nHowever, this implementation has a problem that it overrides the `Creator` specified by any other method than using the `JsonCreator` annotation.\r\nI don't think this problem can be solved with the current `Jackson` mechanism.\r\n\r\nAlso, I personally feel that the `findCreatorAnnotation` function should not be called in such cases.\n\nComment by cowtowncoder:\n@k163377 I think Kotlin module is really abusing expected usage of `AnnotationIntrospector`: method really should not use any complicated logic but simply indicate if marker annotation (or its equivalent) is seen. It may be that changes would be needed for constructor detection in `jackson-databind` and so on, but I do not think trying to add complex logic in `AnnotationIntrospector` should be done.\r\n\r\nKotlin module has often added elaborate (but not always sensible or maintainable) workarounds instead of trying to work in improving introspection with databind. Same sometimes happens with Scala module, but to a lesser degree.\r\nBoth of these do need more advanced handling than Java, although with Java 17 Record type this is changing a bit.\r\n\r\n\n\nComment by k163377:\nI think this is not a `kotlin-module` specific problem, but a `JsonCreator` handling design issue.\r\nThe current design has the following problems\r\n\r\n- Cannot prioritize between `OriginalMarker` and `JsonCreator`.\r\n  - Even when simply detecting annotations, the priority level changes depending on whether the annotation is given to the constructor or the factory function.\r\n- It is difficult to strictly apply the constraint that `JsonCreator` is limited to one per class.\r\n\r\nPersonally, I think it would be more correct if this process were done on a per-class basis.\r\n\r\n(I agree that the scope of benefit from this problem being solved is limited.)\n\nComment by cowtowncoder:\n@k163377 I am sorry but I really do not understand what `OriginalMarker` means here; or why you think `JsonCreator` was not processed on per-class basis. `AnnotationIntrospector` is only called to get markers on creators (constructors, factory methods) and it's then up to caller to figure out the whole picture. It is not up to `AnnotationIntrospector` to do ANY processing combining different annotations or accessors. That's up to `Bean[De]SerializerFactory` or `BasicBeanDescription`. Their handling gets complicated to be sure, and logic for Java handling differs from one needed by Kotlin module.\r\n\r\nBut I think one mistake Kotlin module may be doing is to do much in its AnnotationIntrospector implementation: those methods really should absolutely not try to access information across different methods and fields, but only on specific one being asked about.\r\n\r\n\r\n\n\nComment by cowtowncoder:\nI don't think approach here is doable; will close. I think problems (which are real for sure) need to be addressed differently, possibly changing `AnnotationIntrospector` implementations and/or usage.\n\nComment by yihtserns:\nFYI, I think #4584 will address this issue.  So once that is done, I think most of the things in `KotlinNamesAnnotationIntrospector` will no longer be necessary.  \ud83e\udd1e",
                "source_code": null,
                "distance": 0.75,
                "title": "Make the content registered with `appendAnnotationIntrospector` work correctly as a fallback.",
                "name": "issue#3758",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4615"
                    },
                    {
                        "start_node": "pr#4615",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4584"
                    },
                    {
                        "start_node": "issue#4584",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3758"
                    }
                ],
                "similarity": 0.4632294495066745,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4515",
                "type": "issue",
                "content": "### Describe your Issue\n\nWe need to rewrite the Bean Property introspection (see #3719 for background); and while this is ambitious undertaking, I think it should be done in Jackson 2.x timeframe, not 3.x. That way code remains potentially mergeable from 2.x to 3.x.\r\n\r\nThe main drivers for rewrite are to solve problems that are difficult if not impossible to solve with the current mechanism:\r\n\r\n1. Merging of annotations between Field/Method accessors and Creator (constructor/factory method) arguments\r\n2. Handling of Record types and in particular alternate (non-canonical) constructors\r\n3. Support for canonical constructors for non-Java JVM languages (Kotlin, Scala)\r\n\r\nThis issue is an umbrella ticket as refactoring will likely be spread across multiple PRs; they can all refer to this issue,\r\n\r\n\r\n\r\n\r\n\n\n\nComment by cowtowncoder:\nStarted reading the code and clearly more of code wrt Creator detection needs to move from `BeanDeserializerFactory`/`BasicDeserializerFactory` (later part of processing) into `POJOPropertiesCollector` (earlier part of processing).\r\n\r\nBut not sure whether to try to move abstractions from Factory part, or rewrite; and whether to try move things incrementally or not.\r\n\r\nStarted removing deprecated methods from code paths, to help isolate actual in-use code.\r\n\n\nComment by JooHyukKim:\n> But not sure whether to try to move abstractions from Factory part, or rewrite; and whether to try move things incrementally or not.\r\n\r\nIf we agree that we have enough test coverage, I guess.... rewrite, move big-step-incrementally? \n\nComment by cowtowncoder:\n@JooHyukKim Yes, I think test coverage is sufficient to allow refactoring. I am struggling at finding the steps tho. Especially in a way that would allow merging 2.18 -> master.\r\nSo it's not yet about mechanics but even conceptually which things to move or rewrite/re-implement.\r\n\r\nAnd one problem part is that the latest `BeanDeserializerFactory` code for processing Creators relies on `[Basic]BeanDescription`, which would not be available during `POJOPropertiesCollector` (since `BeanDescription` is mostly used as wrapper for actual `POJOPropertiesCollector`.\r\n\n\nComment by cowtowncoder:\nOk one big challenge that is coming up now, looking through functionality in `BasicDeserializerFactory` is the coupling to deserialization side in general (`DeserializationConfig` and `DeserializationContext`), and also dependency on context (`DeserializationContext`). This because `POJOPropertiesCollector` only operates on generic `MapperConfig` (base config of `DeserializationConfig` and `SerializationConfig`), and does not need or use context.\r\nDependencies are not trivial to remove; but they are also not exactly essential. But just means it is not easy to start by \"lift-and-shift\"ing (that is, by basically moving code from one place to the other), some rewriting required.\r\n\r\nIn the meantime I am making small incremental changes, including removal of deprecated code in affected areas.\r\n\n\nComment by JooHyukKim:\nRight. Also from my experience, many times it was necessary to both modify existing and add additional \"internal\" structure to make the code base in better shape. More of \"tidy up just before making changes\".\r\n\r\nJust out of curiosity, are we going to introduce `POJOPropertiesCollector`, `RecordPropertiesCollector` and such for new version? This question is just from my imagination \ud83d\ude06. I am asking this because, though not necessary, if there's any plan in written format that I can refer to, so I can help.\n\nComment by cowtowncoder:\n```\r\nJust out of curiosity, are we going to introduce POJOPropertiesCollector, RecordPropertiesCollector and such for new version? \r\n```\r\n\r\nNot planned yet. I am thinking it should be possible to make things work without fully separate implementation. But of course if it becomes necessary that could be done.\r\n\r\nAt this first I would really want to make existing logic work same as now, but get Creator properties discovered around time others are... so move it out of `BasicDeserializerFactory` into either `POJOPropertiesCollector` or where `BasicBeanDescription` is resolved.\r\n\r\n\r\n\n\nComment by cowtowncoder:\nHmmmh. Despite incremental refactoring, I don't think functional from `BasicDeserializerFactory` can moved as-is into `POJOPropertiesCollector` -- it does \"too much\", including instantiation of deserializers and so on.\r\nSo what we need is a subset. Need to re-think things a bit.\r\n\r\n...\r\n\r\nOk. So, in `POJOPropertiesCollector` I think handling needs to incorporate selection of actual Creator method and NOT just individual properties. And that information will then be used by `BasicDeserializerFactory`.\r\n\n\nComment by cowtowncoder:\nGood progress:\r\n\r\n1. All JDK-8 tests pass with re-factored `POJOPropertiesCollector`\r\n2. Only 4 Record tests fail\r\n3. Still have duplication with `BasicDeserializerFactory`: will leave resolving that to second PR\r\n\r\nHoping to solve remaining Record tests, to get first PR merged into 2.18, then master.\n\nComment by cowtowncoder:\nForgot to add an update: #4532 was merged 2 days ago, and it handles front-end half of changes:\r\n\r\n* `POJOPropertiesCollector` fully resolves explicit Properties-based creators, linking properties\r\n* Code in `BasicDeserializerFactory` still handles rest of introspection, including linking from (1) to Creators. This is to be removed as the next step.\r\n\r\nI also started to look into the second half (reducing/removing code from `BasicDeserializerFactory`); it is somewhat complicated too, but can hopefully be tackled incrementally as well.\r\n\r\n\n\nComment by cowtowncoder:\nOk some more progress: now `BasicDeserializerFactory` actually uses primary Properties-based Creator discovered by `POJOPropertiesCollector`. Additionally `POJOPropertiesCollector` keeps Creator-properties from that primary one better in-sync with getter/setter/field accessor info (in fact making failing test for #4119 pass -- but will not yet marked as fixed until getting further with refactoring).\r\n\r\nBut quite a bit remains to rewrite in `BasicDeserializerFactory` still.\r\n\n\nComment by cowtowncoder:\nCompleted `BasicDeserializerFactory` rewrite; merged the fix -- next steps (after merging to 3.0) is to check which of formerly `failing/` tests now pass (seems to be 4)\n\nComment by cowtowncoder:\nSigh. A few issues:\r\n\r\n1. Re-build of `jackson-modules-base` 2.18 failed. Just one failing test, for paranamer so not a big deal\r\n2. Re-build of `jackson-module-kotlin` 2.18 failed. Only one fail too? If so, not a huge problem\r\n3. Merge to `master` has 30+ fails (see #4546)\r\n\r\nso need to go through these.\n\nComment by cowtowncoder:\nSolved (1): only one fail, and that is due to changed exception message (although not sure if the new message is good)\n\nComment by JooHyukKim:\nLemme look into the Kotlin one. Theres already bunch of `master` branch failures\n\nComment by cowtowncoder:\nYeah first 2.18 (hopefully with a small number -- just 1 if I saw it right).\n\nComment by JooHyukKim:\nYup, just 1 actually. `TestGithub145.testPerson7()`\n\nComment by JooHyukKim:\nOkay I haven't found solution to resolve or pinpoint root cause for the \ud83d\udd17 [failing test](https://github.com/FasterXML/jackson-module-kotlin/blob/c307ad49517ef80325b2abf3b72a371714c84788/src/test/kotlin/com/fasterxml/jackson/module/kotlin/test/github/Github145.kt#L139) `testPerson7()` yet.\r\nAt this point, I am not sure if it should pass ... \ud83e\udd14 or @k163377 might know?\r\n\r\nUntil then, in case it helps anyone, below is the failing test in Kotlin module.\r\n\r\n```kotlin\r\n    // Cannot have companion object in class declared within function\r\n    class Person7 constructor(val preName: String, val lastName: String) {\r\n        private constructor(preNameAndLastName: String) : this(\r\n            preNameAndLastName.substringBefore(\",\"),\r\n            preNameAndLastName.substringAfter(\",\")\r\n        )\r\n\r\n        companion object {\r\n            @JsonCreator\r\n            @JvmStatic\r\n            fun createFromJson(preNameAndLastName: String): Person7 {\r\n                return Person7(preNameAndLastName)\r\n            }\r\n        }\r\n    }\r\n\r\n    @Test\r\n    fun testPerson7() {\r\n        val person7Json = objectMapper.readValue<Person7>(\"\"\"{\"preName\":\"TestPreName\",\"lastName\":\"TestLastname\"}\"\"\")\r\n    }\r\n```\r\n\r\nIt seems to be that Jackson 2.17 managed to discover PropertyCreator for `constructor(val preName: String, val lastName: String)` constructor.\r\nBut 2.18 does not and fails with message...\r\n\r\n```text\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `com.fasterxml.jackson.module.kotlin.test.github.TestGithub145$Person7` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 1, column: 2]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1754)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1379)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1510)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:348)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:342)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4907)\r\n```\r\n\r\nWill get back to it tommorow.\n\nComment by k163377:\nSorry, I am sick with COVID and don't have the energy to investigate.\r\nIf I recover this weekend I will look at it, but it may be next weekend.\n\nComment by JooHyukKim:\nOh, I am so sorry to hear about your illness \ud83d\ude2d. Please take care and get well soon.\r\nI will look at it as much as I could.\n\nComment by cowtowncoder:\n@k163377 I hope you get better soon! Don't worry about issues while you are recovering.\n\nComment by cowtowncoder:\n@JooHyukKim One possible reason for failure could be that auto-detection of properties-based creation with new code only occurs if there are no alternative constructors (including no default constructor). I am not 100% if behavior in 2.17 and before allowed existence of other constructors; there was one test that failed if not, yet another that failed if allowed.\r\nI added further logic based on `ConstructorDetector` state that solved that issue on databind side, but it is quite specific and might not help here.\r\n\r\nI do still need to extend 2.18 with extension points to let Kotlin (and Scala) module indicate if it has \"canonical\" Creator to use -- that would probably solve the issue here.\r\nBut that extension point does not exist.\r\n\r\nOne possibility, on short term, would be to change this test to be considered \"failing\", to be addressed with follow-up: this way build would remain green for now.\r\n\r\n\r\n\r\n\n\nComment by JooHyukKim:\n> One possibility, on short term, would be to change this test to be considered \"failing\", to be addressed with follow-up: this way build would remain green for now.\r\n\r\nAgreed, as per the issue https://github.com/FasterXML/jackson-module-kotlin/issues/145 the failing test belongs to, the test was already problematic.\r\n\r\nSo what we can do is \r\n\r\n1. move to failing test, \r\n2. File a Github issue against 2.18\r\n3. Fix it in 2.18\r\n\r\n\n\nComment by cowtowncoder:\n@JooHyukKim one quick note: while fixing issues with jackson-databind/3.0, I backported them into 2.x -- basically these are uncovered in 3.0 since it included parameter names module (unlike 2.x where it is separate). So there's a slight chance that something wrt Kotlin could be fixed by these changes.\r\n\n\nComment by JooHyukKim:\nKotlin module still failing. So I filed a PR moving the test to failing https://github.com/FasterXML/jackson-module-kotlin/pull/802.\n\nComment by StefanBratanov:\nHi, just to confirm after release `2.18` we would no longer need the following workaround that I had to use in one of my projects - https://stackoverflow.com/questions/68394911/why-record-class-cant-be-properly-deserialized-with-jackson/68998917#68998917 ?\n\nComment by JooHyukKim:\n@StefanBratanov Probably. You are free to test ur case against Jackson 2.18 \ud83d\udc4d\ud83c\udffc.\n\nIn case it doesn't, let us know \n\nComment by yihtserns:\n@StefanBratanov I think your use case is already supported since `2.14` (see #2992 that was referenced in the StackOverflow answer).",
                "source_code": null,
                "distance": 0.25,
                "title": "Rewrite Bean Property Introspection logic in Jackson 2.x",
                "name": "issue#4515",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    }
                ],
                "similarity": 0.42810242190663333,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4532",
                "type": "issue",
                "content": "This PR is for (roughly) first half of work for #4515.\r\n\r\nWhat it does is rewrite Creator (constructor, factory-method) introspection to happen mostly in `POJOPropertiesCollector` (early, along with Field/Getter/Setter introspection); and rely less on `BasicDeserializerFactory` handling which occurs much later on in the process.\r\n\r\nBut this first PR does not eliminate redundancy yet, leaving `BasicDeserializerFactory` to do sort of double processing; old methods in `POJOPropertiesCollector` are left (mostly) as-is as well (but they will be removed ASAP after merging to 3.0).\r\n\r\n\r\n\n\n\nComment by cowtowncoder:\nSome progress has been made, rewriting logic of `POJOPropertiesCollector`; leaving about 12 failures, not including Record-tests (more work for Records).\n\nComment by cowtowncoder:\nAnd with that, ALL tests pass! On to merging to 2.18, then try to tackle merge to `master` (3.0)\n\nComment by JooHyukKim:\nGreat work! @cowtowncoder \ud83d\udd25\n\nComment by cowtowncoder:\nThanks @JooHyukKim ! Hope to continue with follow-up refactoring to remove Creator selection from BasicDeserializerFactory -- and then maybe improve logic in POJOPropertiesCollector by:\r\n\r\n1. Better support for actual annotation-less auto-detection (finally possible now)\r\n2. Add hook(s) for Kotlin and Scala module to indicate canonical constructor (or maybe just creator, allowing factory methods) to use, f.ex for Kotlin Data classes (and Scala has something similar too I think)\r\n\r\nWith (2) I'll need @pjfanning 's and @k163377 's help; but I am not quite there yet.\r\nHook(s) to call would probably be via `AnnotationIntrospector`, called from `POJOPropertiesCollector` \"_addCreators()\" method.\r\n\r\n ",
                "source_code": null,
                "distance": 0.75,
                "title": "Refactor Bean property introspection",
                "name": "pr#4532",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4532"
                    }
                ],
                "similarity": 0.40253203036400204,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3241",
                "type": "issue",
                "content": "Was trying out the new constructor detector feature (https://cowtowncoder.medium.com/jackson-2-12-most-wanted-3-5-246624e2d3d0/) and stumbled upon the following issue.\r\n\r\nI had this code which forbids nulls on deserialization:\r\n\r\n```\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonSetter;\r\nimport com.fasterxml.jackson.annotation.Nulls;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.json.JsonMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class Input {\r\n    private final Boolean field;\r\n\r\n    @JsonCreator\r\n    public Input(Boolean field) {\r\n        this.field = field;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .defaultSetterInfo(JsonSetter.Value.construct(Nulls.FAIL, Nulls.FAIL))\r\n    .build();\r\n\r\nobjectMapper.readValue(\"{ \\\"field\\\": null }\", Input.class); // throws InvalidNullException, as expected\r\n```\r\n\r\nand was trying to get rid of `@JsonCreator` with the following\r\n\r\n```\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonSetter;\r\nimport com.fasterxml.jackson.annotation.Nulls;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.cfg.ConstructorDetector;\r\nimport com.fasterxml.jackson.databind.json.JsonMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class Input {\r\n    private final Boolean field;\r\n\r\n    // @JsonCreator gone!\r\n    public Input(Boolean field) {\r\n        this.field = field;\r\n    }\r\n\r\n    public Boolean field() {\r\n      return field;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED) // new!\r\n    .defaultSetterInfo(JsonSetter.Value.construct(Nulls.FAIL, Nulls.FAIL))\r\n    .build();\r\n\r\nobjectMapper.readValue(\"{ \\\"field\\\": null }\", Input.class); // no error, field is assigned to null\r\n```\r\n\r\nAlthough I no longer need to annotate my class with `@JsonCreator`, my settings for nullability are ignored, which means I can't really use the new feature.\r\n\r\n(Might be related with https://github.com/FasterXML/jackson-databind/issues/3227?)\n\n\nComment by cowtowncoder:\nYes, I can reproduce this. Strange... It is possible this is due to implicit detection of constructors missing some information that would be discovered by explicitly marker ones.\r\n\n\nComment by joca-bt:\nThis is particularly annoying when using records as we need to do something like:\r\n\r\n```\r\npublic record Input(Boolean field) {\r\n    @JsonCreator\r\n    public Input {}\r\n}\r\n```\r\n\r\nDo you think this fix can be included in 2.14?\r\n\n\nComment by cowtowncoder:\nAs soon as someone provides a fix, yes, it could probably be included in a 2.13.x patch as well. I haven't had and probably won't have time to work in this in near future.\r\n\n\nComment by cowtowncoder:\nSigh. Yes, I think this is because of the disprepancy between merging of annotations between explicitly annotated and implicitly located Creators: this is a long-standing general problem that manifests in many different ways.\r\n\r\nOn plus side: if and when property introspection gets rewritten (it is #1 top Big Thing for me to fix) this problem will be resolved.\r\nOn downside: I have not been able to find enough time to start the rewrite.\r\n\n\nComment by yihtserns:\n> This is particularly annoying when using records as we need to do something like:\r\n> ```\r\n> public record Input(Boolean field) {\r\n>    @JsonCreator\r\n>    public Input {}\r\n>}\r\n>```\r\n\r\n- **For Record**: With `2.15.0` (which contains #3724), you no longer need to annotate your Record's canonical constructor with `@JsonCreator` - it will just work (or rather, fail with `InvalidNullException`).\r\n- **For POJO**: Not fixed yet.\r\n\n\nComment by cowtowncoder:\nWork on #4515 likely makes it possible to solve this for 2.18.\n\nComment by cowtowncoder:\nFixed via #4515, to be included in 2.18.0.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`constructorDetector` seems to invalidate `defaultSetterInfo` for nullability",
                "name": "issue#3241",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3241"
                    }
                ],
                "similarity": 0.3730226484146719,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4513",
                "type": "issue",
                "content": "### Describe your Issue\n\nIn `Kotlin`, annotations are given to constructor parameters of the `record` class when written in a natural way.\r\n\r\n```kotlin\r\n@JvmRecord\r\ndata class JacksonTest(\r\n    @JsonProperty(\"propertyOne\")\r\n    val one: String,\r\n    @JsonProperty(\"propertyTwo\")\r\n    val two: String\r\n)\r\n```\r\n\r\nOn the other hand, `Jackson` seemed to ignore such annotations.\r\nFor this reason, the following problems have been reported\r\nhttps://github.com/FasterXML/jackson-module-kotlin/issues/773\r\n\r\nI am not familiar with the handling of the `record` class, but is it possible to handle annotations on parameters in the same way as the normal class?\n\n\nComment by cowtowncoder:\nCould the example be translated into plain Java? Records support annotations just fine for general case, so details matter a lot.\n\nComment by k163377:\n> Records support annotations just fine for general case, so details matter a lot.\r\n\r\nYou are right about the `record` class support in `Java`.\r\nThis is a `Kotlin` specific issue.\r\n\r\nFor verification purposes, I have created the following code.\r\n`Temp.JacksonTest` and `JacksonTestKt` are `record` classes with almost similar definitions.\r\nRunning `main` will display the constructor parameters for each class, as well as the annotations assigned to the fields.\r\n\r\n```kotlin\r\nimport com.fasterxml.jackson.annotation.JsonProperty\r\n\r\n@JvmRecord\r\ndata class JacksonTestKt(\r\n    @JsonProperty(\"propertyOne\") val one: String,\r\n    @JsonProperty(\"propertyTwo\") val two: String,\r\n)\r\n```\r\n\r\n```java\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\n\r\nimport java.lang.annotation.Annotation;\r\nimport java.util.Arrays;\r\n\r\npublic class Temp {\r\n    record JacksonTest(\r\n            @JsonProperty(\"propertyOne\") String one,\r\n            @JsonProperty(\"propertyTwo\") String two\r\n    ) {}\r\n\r\n    static void printCtorParamAnn(Class<?> c) {\r\n        System.out.println(\"- \" + c.getSimpleName());\r\n\r\n        Arrays.stream(c.getDeclaredConstructors()[0].getParameters()).forEach(p -> {\r\n            var a = p.getAnnotation(JsonProperty.class);\r\n\r\n            if (a == null) { return; }\r\n\r\n            System.out.println(\"-- \" + p.getName() + \" \" + a.annotationType());\r\n        });\r\n    }\r\n\r\n    static void printFieldParamAnn(Class<?> c) {\r\n        System.out.println(\"- \" + c.getSimpleName());\r\n\r\n        Arrays.stream(c.getDeclaredFields())\r\n                .forEach(f -> {\r\n                    for (Annotation a : f.getDeclaredAnnotations()) {\r\n                        System.out.println(\"-- \" + a.annotationType());\r\n                    }\r\n                });\r\n    }\r\n\r\n    public static void main(String[] args) throws JsonProcessingException {\r\n        System.out.println(\"param ann\");\r\n        printCtorParamAnn(JacksonTest.class);\r\n        printCtorParamAnn(JacksonTestKt.class);\r\n\r\n        System.out.println();\r\n\r\n        System.out.println(\"field ann\");\r\n        printFieldParamAnn(JacksonTest.class);\r\n        printFieldParamAnn(JacksonTestKt.class);\r\n    }\r\n}\r\n```\r\n\r\nThe result is as follows: `Kotlin` does not annotate the field.\r\n\r\n```\r\nparam ann\r\n- JacksonTest\r\n-- one interface com.fasterxml.jackson.annotation.JsonProperty\r\n-- two interface com.fasterxml.jackson.annotation.JsonProperty\r\n- JacksonTestKt\r\n-- arg0 interface com.fasterxml.jackson.annotation.JsonProperty\r\n-- arg1 interface com.fasterxml.jackson.annotation.JsonProperty\r\n\r\nfield ann\r\n- JacksonTest\r\n-- interface com.fasterxml.jackson.annotation.JsonProperty\r\n-- interface com.fasterxml.jackson.annotation.JsonProperty\r\n- JacksonTestKt\r\n```\r\n\r\nI believe that `Jackson` skips parsing parameter annotations only when parsing the `record` class (sorry if I am wrong).\r\nOn the other hand, at least in `Kotlin`, this behavior causes problems.\r\nI also feel that it is a bit difficult to fix this problem in `kotlin-module`.\r\n\r\nTo reiterate, I wanted to ask if it is possible to parse the `record` class in `jackson-databind` the same as the regular class (or if there is no reasonable reason to do so).\n\nComment by cowtowncoder:\nAh. Ok, I agree: it should be possible to find annotations from Constructor parameters; annotations in Fields should NOT be required.\r\n\r\nBut one challenging part is reproducing the issue on Java side, to be able to reproduce it, verify fix & guard against regression.\r\n\r\nOne more thing: this almost certainly would be something to handle as part of major Bean Property Introspection rewrite (for which I just created #4515).\r\n\n\nComment by k163377:\n> But one challenging part is reproducing the issue on Java side, to be able to reproduce it, verify fix & guard against regression.\r\n\r\nYou are absolutely right.\r\nIt is not possible to reproduce this in the usual way, so it would need to be mocked up or something.\r\n\r\n> this almost certainly would be something to handle as part of major Bean Property Introspection rewrite\r\n\r\nThank you very much.\r\nHowever, I am sorry to suggest this, but I honestly believe it would be a low priority.\r\nThere are workarounds in `Kotlin`, and it is reasonable to reduce the amount of processing to match the general mechanics of `Java`.\r\n\r\nI don't even think it should be fixed unless there is a way to annotate only parameters in `Java` or similar problems occur in `Scala` modules.\n\nComment by cowtowncoder:\n@k163377 On its own maybe low priority, but I would definitely hope to be able to solve this case as part of general rework -- I do not think annotations on underlying Record fields should be required.\r\n\r\n\n\nComment by yihtserns:\nThe decompiled Kotlin bytecode looks so bizarre:\r\n```\r\n<..snip>\r\npublic record JacksonTest() {\r\n   @NotNull\r\n   private final String one;\r\n   @NotNull\r\n   private final String two;\r\n\r\n   @NotNull\r\n   public final String one() {\r\n      return this.one;\r\n   }\r\n\r\n   @NotNull\r\n   public final String two() {\r\n      return this.two;\r\n   }\r\n\r\n   public JacksonTest(@JsonProperty(\"propertyOne\") @NotNull String one, @JsonProperty(\"propertyTwo\") @NotNull String two) {\r\n      Intrinsics.checkNotNullParameter(one, \"one\");\r\n      Intrinsics.checkNotNullParameter(two, \"two\");\r\n      super();\r\n      this.one = one;\r\n      this.two = two;\r\n   }\r\n\r\n   @NotNull\r\n   public final String component1() {\r\n      return this.one;\r\n   }\r\n\r\n   @NotNull\r\n   public final String component2() {\r\n      return this.two;\r\n   }\r\n\r\n   <..snip>\r\n}\r\n```\n\nComment by yihtserns:\nLikely caused by https://github.com/FasterXML/jackson-databind/pull/3929.\r\n\r\nBut I think the \"root\" cause is that weird \"record class\" generated by `@JvmRecord` - it basically violates the Record spec esp by not propagating the `@JsonProperty` annotation to the accessor methods.  **UPDATE**: I see that OP has [filed a bug against Kotlin](https://youtrack.jetbrains.com/issue/KT-67977).\n\nComment by k163377:\n@yihtserns \r\nLet me thank you again.\r\nAs I am not familiar with the `Java record` specification, I considered that ticket as just a feature request and did not even share it with this Issue, but it seems I was wrong.\n\nComment by cowtowncoder:\nWith #4515 now merged, this might be solvable more easily: detection and merging of annotations between Fields and Constructor parameters now works, even for implicitly (no annotations) detected Constructors (like canonical constructors of Record).\r\n\r\nBut will need a Java unit test in some form.\r\n\r\n... or add in Kotlin module I suppose.",
                "source_code": null,
                "distance": 0.75,
                "title": "Handling of annotations assigned to constructor parameters of the `record` class",
                "name": "issue#4513",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4513"
                    }
                ],
                "similarity": 0.3513381354426804,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3898",
                "type": "issue",
                "content": "The test in this PR fails with:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `com.fasterxml.jackson.failing.TestSetterlessProperty$ImmutableId` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{\r\n  \"id\" : 13\r\n}\"; line: 2, column: 3]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1739)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1364)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1424)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)\r\n\tat com.fasterxml.jackson.failing.TestSetterlessProperty.testSetterlessProperty(TestSetterlessProperty.java:34)\r\n        ....\r\n```\r\n\r\nAs someone who codes mainly in Scala, this is how I prefer to create Java Beans - with immutable values - thus, no setters.\r\n\r\nI know we have Java Records but this style is useful for older Java runtimes.\r\n\r\nIs there any chance that this could be made to work with a default mapper with no annotations or customisation of the mapper?\n\n\nComment by cowtowncoder:\nThere are 2 related problems as to why this can't quite be made to work at this point.\r\n\r\nThe main problem is that the names of Constructor parameters are only available with Parameter names module (or by Kotlin/Scala module providing implicit names similarly).\r\nThis can be mocked in tests however; this is done for some existing unit tests in jackson-databind (search for \"findImplicitPropertyName()\" override for AnnotationIntrospector).\r\n\r\nSecond challenge is figuring out choice between Properties- and Delegating- Creator; this because 1-argument case is fundamentally ambiguous.\r\nIn this case it could probably be heuristically determined from existence of matching getter.\r\n\r\nAnyway: adding implicit parameter name access, I think this test might actually pass already?\r\n\n\nComment by pjfanning:\nI tried various changes to the ImmutableId class. The prop names were not a problem. None of these helped:\r\n* adding a custom annotation introspector \r\n* adding `@JsonProperty` annotations\r\n\r\nThe main reason for the ParamNamesModule is Java 6 and 7 - Java 8+ has better support for finding parameter names. \r\n\r\nIn the end, the only thing that helped was adding an extra no-param constructor. It is not ideal to have it such that users need to modify their classes to get deserialization to work.\n\nComment by cowtowncoder:\nUse of `@JsonProperty` for constructor parameter(s) (just one of them if parameter names module exists; otherwise all) really does work. If not that's a bug. That's not \"no annotations\" but avoids use of `@JsonCreator`.\r\nBut note that they are specifically required for constructor parameters to make Constructor \"explicitly annotated\"; adding them in fields/getters/setters won't help.\r\n\r\nBut generally we could solve this if Property Discovery was rewritten -- my long-term nr 1 target. There's #3719 related to that; explaining the issue.\r\nSpecifically discovery of implicit Creators occurs too late in the process: if it happened earlier, we could auto-detect more cases as well (since the process actually would start with Creator discovery instead of other accessors).\r\n\r\nDownside is that I do not thing incremental smaller changes allow doing what is ideal; we have probably ran out of incremental fixes and new ones are likely counter-productive (adding hacks to handle individual problem cases, leading to more complex and error-prone combinations).\r\n\r\nAs to timeline, it's been \"next minor version\" since maybe 2.12. But lately vuln/cve focus has taken lots of time. Maybe with 2.16 things are different. :)\r\n\r\n**EDIT**: (10-Jun-2024)\r\n\r\nAbove-mentioned property discovery rewrite was done via #4515 and is now in 2.18 branch.\r\nHence further progress possible.\r\n\r\n\n\nComment by cowtowncoder:\n@pjfanning After rebasing to 2.18, merging changes to latest, updating wrt JUnit 5 test changes, all 5 tests now actually pass (probably due to #4515)!  (when running locally, failing tests would be skipped on CI)\r\n\r\nBut I am not sure what to do with the tests however, as I think they probably overlap with other tests under `com.fasterxml.jackson.databind.deser.creators`.\r\n\r\nWDYT? Some of these could be merged with existing `creators` test(s), or I can close the PR. But if some cases were not tested (possible, although I have moved 5 formerly failing test to regular ones), would of course be nice to have better coverage.\r\n\n\nComment by pjfanning:\n@cowtowncoder I moved the test to the 'ser' package. I think it is useful to add this test class as a regression scenario.\n\nComment by cowtowncoder:\nOk. I'll probably move it to under \"creators\" (since that's where `@JsonCreator`-related tests go, figure out better name for class) but keep them.\r\nThanks!\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "default mapper cannot handle basic immutable class",
                "name": "pr#3898",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#3898"
                    }
                ],
                "similarity": 0.3446767086846679,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4366",
                "type": "issue",
                "content": "resolves #562 \n\n\nComment by cowtowncoder:\nImpressive. I am bit hesitant to consider this as one more thing before work on Property Introspection rewrite, but no harm in figuring out how this could work. Added some notes.\n\nComment by JooHyukKim:\n> Impressive. I am bit hesitant to consider this as one more thing before work on Property Introspection rewrite, \n\nI concur. And also in the issue #562, this feature is to get included in 3.x.\n\nSo I think we can safely consider this feature only after Property Introspection rewrite.\n\n> but no harm in figuring out how this could work. Added some notes.\n\nThankssss! I will keep them updated\n\nComment by cowtowncoder:\nCool, this is much improved. I'll make tiny changes, wrt suggestions I added.\n\nComment by cowtowncoder:\n@JooHyukKim Ok, I made a few changes that I think help, including validation that only one \"any-setter\" is specified.\r\n\r\nI was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into `PropertyValueBuffer` (make it take `SettableAnyProperty`).\r\nAlso I think validation wrt `DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES` need to be able to skip check for placeholder there.\r\n\r\n\n\nComment by JooHyukKim:\n> I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n\r\nDo you mean do the `PropertyValueBuffer` construction with anySetter in it in the first place, in earlier part of `_deserializeUsingPropertyBased`? If so, sounds like an idea.\r\n\r\n> Also I think validation wrt DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES need to be able to skip check for placeholder there.\r\n\r\nPlaceholder? \ud83e\udd14 Could u elaborate a bit more? \r\n\n\nComment by cowtowncoder:\n> > I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n> \r\n> Do you mean do the `PropertyValueBuffer` construction with anySetter in it in the first place, in earlier part of `_deserializeUsingPropertyBased`? If so, sounds like an idea.\r\n\r\nRight.\r\n \r\n> > Also I think validation wrt DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES need to be able to skip check for placeholder there.\r\n> \r\n> Placeholder? \ud83e\udd14 Could u elaborate a bit more?\r\n\r\nWhat I mean is to test to see that if this setting is enabled, it will not cause failure since property that represents \"any-setter\" has no associated value.\r\nSo by placeholder I meant constructor parameter that is not a \"real\" parameter, similar to how injectable value isn't required to come from input.\r\n\n\nComment by JooHyukKim:\n> I was also wondering if it wouldn't make sense to add knowledge of \"any-setter\" creator property directly into PropertyValueBuffer (make it take SettableAnyProperty).\r\n\r\ncc/ @cowtowncoder Implemented as suggested in commit https://github.com/FasterXML/jackson-databind/pull/4366/commits/8612433174444c364f704fa6a82c802baba3f959. Apologies in advance for formatter taking up large portion.\r\n\r\nIMO, this new version seems more appropriate in that we don't handle values twice --first buffering in PropertyValueBuffer then transfer to map for AnySetter parameter.\n\nComment by cowtowncoder:\n@JooHyukKim We could revisit this, now that #4515 is complete. Would need to be re-based to 2.18, and I suspect it won't merge cleanly due to overlapping changes. But at least not blocked by concerns of property introspection complications.\n\nComment by JooHyukKim:\nWill rebase now \ud83d\udc4d\ud83c\udffc\ud83d\udc4d\ud83c\udffc\n\nComment by JooHyukKim:\nWDYT, @cowtowncoder ?\r\nWe can visit #4396 after this.\n\nComment by cowtowncoder:\n> WDYT, @cowtowncoder ? We can visit #4396 after this.\r\n\r\nOk. I am still struggling with this; reading again. It is improving, but I am still worried about added complexity. But at the same time this IS a VERY highly voted feature (that is, #562 is)\r\n\r\nSo it'd be great to be able to somehow simplify handling. Not sure how to, tho, so I need to keep on re-reading code.\r\n\r\nAside from that, some missing things:\r\n\r\n1. No tests yet for Record case? (should work fine I assume, but just noting)\r\n2. Only supports `Map`-backed any-setter, but not `JsonNode`-backed one (unlike Field-based one) -- adding support is probably not hard but does add to code, special casing\r\n\n\nComment by JooHyukKim:\n> So it'd be great to be able to somehow simplify handling. Not sure how to, tho, so I need to keep on re-reading code.\r\n\r\nI totally agree. Current implementation is both complex and scattered around places. \r\nI sort of focused on making work, not so much around maintainability.\r\n\r\nI will probably start isolating the any-setter logics first, maybe to a class, then will read through your comments and add suggested missing parts.\r\n\r\nthnx @cowtowncoder \r\n\r\nPS: Reviews applied first.\n\nComment by JooHyukKim:\nTemporarily closing this in favor of #4558 where I added `record` and `JsonNode` tests\r\n/cc @cowtowncoder ",
                "source_code": null,
                "distance": 0.75,
                "title": "Allow @JsonAnySetter on Creator constructors",
                "name": "pr#4366",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4366"
                    }
                ],
                "similarity": 0.33936491740426317,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4537",
                "type": "issue",
                "content": "Fix possible partially due to initial refactoring for #4515.\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Fix #4452 by introspecting Creators for Record serialization too",
                "name": "pr#4537",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4537"
                    }
                ],
                "similarity": 0.3391324345387202,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3846",
                "type": "issue",
                "content": "Constructor autodetection (https://cowtowncoder.medium.com/jackson-2-12-most-wanted-3-5-246624e2d3d0/) does not appear to be working when used together with naming strategies which don't match the field names. See the examples below for more details.\r\n\r\n```\r\npublic class Test {\r\n    private final String fieldName;\r\n\r\n    public Test(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n    .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n    .build();\r\n// Ok. Field name in JSON matches the one of the Java class so Jackson is able to find it, however, I've defined my strategy as snake case, so I was expecting fieldName to be invalid.\r\nobjectMapper.readValue(\"{ \\\"fieldName\\\": \\\"value\\\" }\", Test.class);\r\n// Fails. Field name doesn't match and the property naming strategy isn't being taken into consideration.\r\nobjectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class);\r\n```\r\n\r\n```\r\npublic class Test {\r\n    private final String fieldName;\r\n\r\n    public Test(@JsonProperty(\"field_name\") String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n    .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n    .build();\r\n// Ok. However we are helping Jackson by using @JsonProperty, which defeats the purpose of annotationless deserialization.\r\nobjectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class);\r\n```\r\n\r\n```\r\npublic class Test {\r\n    private String fieldName;\r\n\r\n    public Test(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n    \r\n    public void setFieldName(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n    .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n    .build();\r\n// Ok. Jackson is able to find the field without needing any annotation, but we need to define a setter. This is a no-go for records.\r\nobjectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class);\r\n```\n\n\nComment by JooHyukKim:\nSeems like problem is with detecting properties and registering `PropertyNamingStrategies`... \ud83e\udd14\r\nMaybe below test is more narrowed down? -- note that `jackson-module-parameter-names` module is assumed to exist.\r\n\r\n```Java\r\n    static class PointFail {\r\n        private int xNum;\r\n        private int yNum;\r\n\r\n        public PointFail(int xNum, int yNum) {\r\n            this.xNum = xNum;\r\n            this.yNum = yNum;\r\n        }\r\n    }\r\n\r\n    static class PointSuccess {\r\n        private int xNum;\r\n        private int yNum;\r\n\r\n        public PointSuccess(int xNum, int yNum) {\r\n            this.xNum = xNum;\r\n            this.yNum = yNum;\r\n        }\r\n\r\n        public void setxNum(int xNum) {\r\n            this.xNum = xNum;\r\n        }\r\n\r\n        public void setyNum(int yNum) {\r\n            this.yNum = yNum;\r\n        }\r\n    }\r\n\r\n    // with `jackson-module-parameter-names` module\r\n    ObjectMapper mapper = JsonMapper.builder()\r\n        .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n        .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n        .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n        .build();\r\n\r\n    // Fails\r\n    public void testPointFails() throws Exception {\r\n        PointFail strategyBean = mapper\r\n            .readValue(a2q(\"{'x_num':1, 'y_num':2}\"), PointFail.class);\r\n\r\n        assertEquals(strategyBean.xNum, 1);\r\n        assertEquals(strategyBean.yNum, 2);\r\n    }\r\n\r\n    // Success, with setters OR getters\r\n    public void testPointSuccess() throws Exception {\r\n        PointSuccess strategyBean = mapper\r\n            .readValue(a2q(\"{'x_num':1, 'y_num':2}\"), PointSuccess.class);\r\n\r\n        assertEquals(strategyBean.xNum, 1);\r\n        assertEquals(strategyBean.yNum, 2);\r\n    }\r\n```\n\nComment by cowtowncoder:\nYes, @JooHyukKim is right; this is due to issue discussed under #3719 and just one symptom.\n\nComment by yihtserns:\nJust a side note - about:\r\n```\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n    .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n    .build();\r\n// Ok. Jackson is able to find the field without needing any annotation, but we need to define a setter.\r\n// *****This is a no-go for records.****** <---------------------\r\nobjectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class);\r\n```\r\n\r\n...`PropertyNamingStrategy` actually never worked with Records (#2992), but that has been fixed in `2.15.0` (tested with `2.15.0-rc2`), so now it can work without any special configuration, e.g.:\r\n```\r\nrecord Test(String fieldName) {\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n        .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n        .build();\r\n\r\n// Prints Test[fieldName=value]\r\nSystem.out.println(objectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class));\r\n```\n\nComment by yihtserns:\nAsking out of curiousity: if the field is `private` & it doesn't have a getter method, how is the class actually used?\n\nComment by joca-bt:\nThe point is that it doesn't have a setter. Getter is irrelevant here.\n\nComment by yihtserns:\nIt works if there's a getter, though.  Why is a setter relevant?\n\nComment by yihtserns:\nI mean as pointed out [here](https://github.com/FasterXML/jackson-databind/issues/3846#issuecomment-1486025926), naming strategy is used when a getter exists e.g.:\r\n\r\n```\r\npublic class Test {\r\n    private final String fieldName;\r\n\r\n    public Test(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n\r\n    public String getFieldName() { // with getter\r\n        return this.fieldName;\r\n    }\r\n}\r\n\r\nObjectMapper objectMapper = JsonMapper.builder()\r\n    .addModule(new ParameterNamesModule(JsonCreator.Mode.PROPERTIES))\r\n    .constructorDetector(ConstructorDetector.USE_PROPERTIES_BASED)\r\n    .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n    .build();\r\n\r\nobjectMapper.readValue(\"{ \\\"field_name\\\": \\\"value\\\" }\", Test.class); // This works\r\nobjectMapper.readValue(\"{ \\\"fieldName\\\": \\\"value\\\" }\", Test.class); // This also works, but that's a (different) bug\r\n```\n\nComment by joca-bt:\n> Why is a setter relevant?\r\n\r\nIf there is a setter Jackson may use that instead of the constructor.\n\nComment by yihtserns:\nFor naming strategy to work for a \"property\", one of these is currently needed:\r\n1. Visible field (e.g. `public` field, or `private` field + `setVisibility(PropertyAccessor.FIELD, ANY)`).\r\n2. Getter.\r\n3. Setter.\r\n4. Method parameter with implicit name (e.g. with `ParameterNamesModule`), for a `@JsonCreator(mode=PROPERTIES)` annotated (`valueOf`) factory method.\r\n5. Constructor parameter with implicit name (e.g. with `ParameterNamesModule`), for a `@JsonCreator` annotated constructor.\r\n6. Constructor parameter for Record's canonical constructor.\r\n\r\nSo one of the things you can do to make naming strategy to work with:\r\n```\r\npublic class Test {\r\n    private final String fieldName;\r\n\r\n    public Test(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n}\r\n```\r\n...is to add a getter:\r\n```\r\npublic class Test {\r\n    private final String fieldName;\r\n\r\n    public Test(String fieldName) {\r\n        this.fieldName = fieldName;\r\n    }\r\n\r\n    public String getFieldName() {\r\n        return this.fieldName;\r\n    }\r\n}\r\n```\r\n...which is pretty normal because how else can that private field be used?\r\n\r\nI'm just curious about what are you doing with your JSON model class in your project/codebase, for it to have a private field without getter, resulting in you facing this issue?\n\nComment by joca-bt:\nThis example is about #5.\r\n\r\n> Constructor parameter with implicit name (e.g. with ParameterNamesModule), for a @JsonCreator annotated constructor.\r\n\r\nExcept @JsonCreator should not be needed contrary to what you wrote. You can read more about it here https://cowtowncoder.medium.com/jackson-2-12-most-wanted-3-5-246624e2d3d0.\r\n\r\n> for it to have a private field without getter, resulting in you facing this issue?\r\n\r\nI am not. It was not relevant for the example but I can see it being valid. Not all instance fields need/should have getters \ud83d\ude43.\n\nComment by yihtserns:\n> > Constructor parameter with implicit name (e.g. with ParameterNamesModule), for a @JsonCreator annotated constructor.\r\n>\r\n> Except @JsonCreator should not be needed contrary to what you wrote. You can read more about it here https://cowtowncoder.medium.com/jackson-2-12-most-wanted-3-5-246624e2d3d0.\r\n\r\nI specifically said \"**one of these** is currently needed\"...  Meaning, even if you don't have number 5, as long as you have either 1, 2, 3, 4, or 6, naming strategy will work.\r\n\r\n> I am not. It was not relevant for the example but I can see it being valid. Not all instance fields need/should have getters \ud83d\ude43.\r\n\r\nOK so you're not reporting for a _practical problem_ (i.e. \"I'm facing this issue now!\"), but rather an edge-case you found while testing Jackson.  I just wanted to know if I'm missing anything I should be careful of as a Jackson user, thanks!\n\nComment by cowtowncoder:\nAs per my earlier notes, I think it is very likely this is related to the problem of \"implicit\" Creators being discovered too late to be properly linked to accessors (getters/setters): explicit (annotation indicated) Creators are discovered first, their arguments get matched properly with getters/setters; implicit ones are discovered at a later phase.\r\nIt is sometimes possible to force proper linking by additional annotations (obviously `@JsonCreator`, but also `@JsonProperty` on Creator parameters).\r\n\r\nThis is something that I think requires a rewrite of property discovery (see #3719), and if and when this happens can be resolved. But I do not think smaller incremental fixes are possible.\r\n\n\nComment by cowtowncoder:\nWork on #4515 may make this fixable for 2.18.\r\n\r\nWhat would be great would be a reproduction (unit test), to help test eventual fix.\r\n\n\nComment by cowtowncoder:\nNow that #4515 is fixed, I think this issue is likely covered as well.\r\nSince no unit test added, I consider this as solved; may be reopened/re-filed with a reproduction (test) if there are further issues.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Constructor autodetection does not take naming strategy into account",
                "name": "issue#3846",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3846"
                    }
                ],
                "similarity": 0.33190149243850525,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4544",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nWhen using an 'ObjectMapper' with the ParameterNamesModule registered, errors occur when attempting to parse using by static methods annotated with @JsonCreator.\r\n\r\nThis error occurs under the following conditions:\r\n1. The objectMapper registers the parameterNamesModule.\r\n2. There exists a static method annotated with @JsonCreator, and if the names of the arguments in the constructor match those of the arguments in the static method.\r\n\r\n#### following class/enum exists.\r\n```java\r\n@Data\r\npublic class DataClass {\r\n\tDataEnum data;\r\n}\r\n\r\n@Getter\r\npublic enum DataEnum {\r\n\r\n\tTEST(0);\r\n\r\n\tprivate final int data;\r\n\r\n\tDataEnum(int data) {\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\t@JsonCreator\r\n\tpublic static DataEnum of(int data) {\r\n\t\treturn Arrays.stream(values())\r\n\t\t\t.filter(it -> it.getData() == data)\r\n\t\t\t.findAny().get();\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n#### test code\r\n```java\r\nString json = \"\"\"\r\n\t\t{\"data\" : 0}\r\n\t\t\"\"\";\r\n\r\n\t@Test\r\n\tvoid test() throws JsonProcessingException {\r\n\r\n\t\tObjectMapper objectMapper = new ObjectMapper();\r\n\t\tobjectMapper.registerModule(new ParameterNamesModule());\r\n\r\n\t\tDataClass data = objectMapper.readValue(json, DataClass.class);\r\n\t\tlog.info(\"data = {}\", data);\r\n\r\n\t}\r\n```\r\n\r\n#### stack trace\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Input mismatch reading Enum `com.test.DataEnum`: properties-based `@JsonCreator` ([method com.test.DataEnum#of(int)]) expects JSON Object (JsonToken.START_OBJECT), got JsonToken.VALUE_NUMBER_INT\r\n at [Source: (String)\"{\"data\" : 0}\r\n\"; line: 1, column: 11] (through reference chain: com.test.DataClass[\"data\"])\r\n```\r\n\r\nWhen using `@JsonCreator(mode = JsonCreator.Mode.DELEGATING)`, it operates correctly.\r\n\r\nbut, Isn't it ParameterNamedModules should only affect constructors, not static method?\r\nand Even in the properties mode, shouldn't it operate correctly?\r\n\r\n### versions\r\njdk : 21\r\njackson : 2.15.4\n\n\nComment by JooHyukKim:\nCan you provide reproduction without Lombok? It's not part of Jackson and not everyone knows how the gets compiled and run.\n\nComment by JooHyukKim:\n> but, Isn't it ParameterNamedModules should only affect constructors, not static method?\r\n> and Even in the properties mode, shouldn't it operate correctly?\r\n\r\nMay I ask which part from both [parameter-names module documentation](https://github.com/FasterXML/jackson-modules-java8/tree/2.18/parameter-names) and [@JsonCreator](https://github.com/FasterXML/jackson-annotations/blob/2.18/src/main/java/com/fasterxml/jackson/annotation/JsonCreator.java) made you conclude that static methods are not affected and should operate correctly in Properties mode?\n\nComment by cowtowncoder:\nParameter name modules provides names for Constructor as well as Method (including static ones) parameters. If there is something suggesting otherwise, that should be fixed.\r\n\n\nComment by cowtowncoder:\n> Can you provide reproduction without Lombok? It's not part of Jackson and not everyone knows how the gets compiled and run.\r\n\r\nPlus our unit tests are not allowed to add new external dependencies, not just Lombok (but Lombok in particular since it also requires build changes to process thigns).\r\n\n\nComment by ehdrms2034:\n@JooHyukKim @cowtowncoder thanks for giving comment.\r\n\r\n> May I ask which part from both [parameter-names module documentation](https://github.com/FasterXML/jackson-modules-java8/tree/2.18/parameter-names) and [@JsonCreator](https://github.com/FasterXML/jackson-annotations/blob/2.18/src/main/java/com/fasterxml/jackson/annotation/JsonCreator.java) made you conclude that static methods are not affected and should operate correctly in Properties mode?\r\n\r\nI thought it only affected the constructor, but thank you for pointing that out, too\r\n\r\n>Can you provide reproduction without Lombok? It's not part of Jackson and not everyone knows how the gets compiled and run.\r\n\r\nwhen lombok removed, same error occurs.\r\n\r\nIf only @JsonCreator is declared, it will operate in default mode.\r\nand if there is one argument, i know jsonCreator work in delegating mode. \r\nAdding only the ParameterNamesModule causes an error.\r\n\r\nthis is fixed code.\r\n```java\r\npublic class DataClass {\r\n\tDataEnum data;\r\n\r\n        public DataEnum(){\r\n           \r\n        }\r\n\r\n        public void setData(DataEnum data) {\r\n              this.data = data;\r\n        }\r\n}\r\n\r\npublic enum DataEnum {\r\n\r\n\tTEST(0);\r\n\r\n\tprivate final int data;\r\n\r\n\tDataEnum(int data) {\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\t@JsonCreator\r\n\tpublic static DataEnum of(@JsonProperty(\"data\") int data) { //@JsonProperty is optional\r\n\t\treturn Arrays.stream(values())\r\n\t\t\t.filter(it -> it.getData() == data)\r\n\t\t\t.findAny().get();\r\n\t}\r\n\r\n        public DataEnum getData(){\r\n                return this.data;\r\n        }\r\n\r\n}\r\n\r\n```\r\n\r\nIs there something I might have set up incorrectly?\n\nComment by cowtowncoder:\nAh. Enum types are rather special and do not use standard POJO introspection. This because handling of immutable types like enum are fundamentally different from typical POJOs.\r\nSo behavior could be due to specific handling of enums.\r\n\r\nIt is actually not true that 1-parameter case always defaults to delegation.\r\nBut in general detection of \"correct\" mode for 1-parameter case is difficult: in this specific case detection likely considers matching name between the parameter to static factory method and field `data`. You can test that hypothesis by using different field name (field visibility probably plays no role)\r\n\r\nSince I am rewriting introspection (via #4515) I again remember most of details wrt POJO case so maybe I can have a look here once I get refactoring complete.\r\n(there's still the question of different code path for Enum case of course).\r\n\n\nComment by ehdrms2034:\nokay. i see.\r\n\r\nin summary\r\n1. JsonCreator default mode is heuristic.\r\n2. Adding a ParameterNamesModule, Jackson get confused about which mode to choose.\r\n3. Because ParameterNamesModule add one way to parse 1 param-constructor\r\n4. so Explicitly setting JsonCreator mode to 'Delegating'(or changing the fieldName) resolves the issue \r\n\r\nisn't that right?\n\nComment by cowtowncoder:\n@ehdrms2034 Roughly, yes.\r\n\r\nMode is heuristic if\r\n\r\n1. Either no `@JsonCreator` specified (implicit detection, but only for POJOs, not enums), or `@JsonCreator` without `mode` AND\r\n2. Constructor/factory method takes 1 parameter\r\n\r\notherwise choice is deterministic.\r\n\n\nComment by ehdrms2034:\n@cowtowncoder \r\n\r\nthanks to tell me conditions that @JsonCreator works unexpectedly.\r\n\r\n I understand clearly now. thank you :)\n\nComment by cowtowncoder:\n@ehdrms2034 Actually, I went ahead and wrote a test for this and now I know exactly why the constructor is heuristically considered properties-based: it because of Lombok-generated `getData()` method. For 1-parameter case where:\r\n\r\n1. There is implicit name (one by parameter-names module) AND\r\n2. There is visible accessor (by default `public` getter method or Field)\r\n\r\nchoice is Properties-based. Otherwise it'd default to delegation-based.\r\n\r\nAlso existence of `@JsonValue` on class would make it Delegation-based.\r\n\r\nSo in this case, adding explicit `mode` is probably the way to go; otherwise could `@JsonIgnore` getter.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Can't Deserialize using by @JsonCreator with ParameterNamedModules",
                "name": "issue#4544",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4544"
                    }
                ],
                "similarity": 0.3218536608010073,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4530",
                "type": "issue",
                "content": "### Describe your Issue\r\n\r\n`ConstructorDetector` was added as configuration only on deserialization side (`DeserializationConfig`).\r\nWhile this seemed sensible earlier it will actually be necessary to access from general-purpose property introspection (see #4515). So let's:\r\n\r\n1. Add it in `SerializationConfig` for 2.18\r\n2. (ideally) Re-factor in 3.0 to belong to lower level (`MapperConfig`)\r\n\r\n\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Add `ConstructorDetector` configurability to `SerializationConfig` too",
                "name": "issue#4530",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4530"
                    }
                ],
                "similarity": 0.31696466077400887,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4452",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nSerialization of java records do not appear to be honoring `@JsonProperty` names in `@JsonCreator` constructors. \r\n\r\n\r\n### Version Information\r\n\r\n2.15.x+\r\n\r\n### Reproduction\r\n\r\nA test below fails for me and I expect it to pass.\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this.testFieldName = testFieldName;\r\n            this.testOtherField = testOtherField;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nThe field is renamed to what is specified in the `@JsonProperty` annotation in the record's `@JsonCreator`\r\n\r\n### Additional context\r\n\r\nWe encountered this upgrading from 2.14.x up to 2.16.x, so this functionality was working at that earlier version (perhaps before records were really addressed). \r\n\r\nPerhaps we have versions incorrect between jackson modules and libraries, but we haven't found the exact mismatch yet.\n\n\nComment by yihtserns:\nTested using `2.14.2` - not working.  But it's amazing that it ever worked at all because annotating on constructor arguments will only produce this compiled code:\r\n```java\r\npublic static record TestObject(String testFieldName, Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(@JsonProperty(\"strField\") String testFieldName, @JsonProperty(\"intField\") Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\r\n...the `@JsonProperty` annotation won't be propagated to the field & accessor method since Java doesn't know which constructor argument is associated with which field/accessor.\r\n\r\nOnly by annotating in the Record's header i.e.:\r\n```java\r\npublic static record TestObject(@JsonProperty(\"strField\") String testFieldName, @JsonProperty(\"intField\") Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(String testFieldName, Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\r\n...will a usable compiled code be produced:\r\n```java\r\npublic static record TestObject(String testFieldName, Integer testOtherField) {\r\n    @JsonCreator\r\n    public TestObject(String testFieldName, Integer testOtherField) {\r\n        this.testFieldName = testFieldName;\r\n        this.testOtherField = testOtherField;\r\n    }\r\n\r\n    @JsonProperty(\"strField\")\r\n    public String testFieldName() {\r\n        return this.testFieldName;\r\n    }\r\n\r\n    @JsonProperty(\"intField\")\r\n    public Integer testOtherField() {\r\n        return this.testOtherField;\r\n    }\r\n}\r\n```\n\nComment by Incara:\nYeah, I think we've figured out this test specifically doesn't work on any version. We're not sure why it works for us with our application's old dependency combination. I don't know if it's something about the parameter names module or properties on the spring `ObjectMapper` injected at runtime that allows it to be possible. \r\n\r\nIs this something that is intended to be supported or is it a requirement that `@JsonProperty` annotations must appear in the record declaration?\n\nComment by yihtserns:\nIf the `ObjectMapper` is created with:\r\n- `.registerModule(new ParameterNamesModule())`, or\r\n- `.findAndRegisterModules()` with `jackson-module-parameter-names` in the classpath\r\n\r\n...then it'll work but I think that's more of a happy coincidence that worked because the constructor argument names happen to match the property (field/accessor) names.  And that's now broken in `2.16.0` (works OK in `2.15.4`).\r\n\r\nI'm not entirely sure, but I vaguely remember seeing an issue talking about names...  But I'm not gonna dig further since I'm just here to make sure it wasn't my contribution from 1 year ago that caused this - imma leave this to the core maintainers.\r\n\r\n\ud83c\udfc3\u200d\u2640\ufe0f\ud83d\udca8\n\nComment by Incara:\nMuch appreciated, this helps with analysis for sure. I think that narrows this down to something changed between `2.15.4` and `2.16.0` and now it doesn't seem like `@JsonProperty` renames are honored on `@JsonCreator` in `record`s. The below works in `2.15.4` but fails in `2.16.0`:\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this.testFieldName = testFieldName;\r\n            this.testOtherField = testOtherField;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nFor now, our solution is to eliminate our `@JsonCreator`s on `record`s in favor using `@JsonProperty` directly on the record definition attributes since there is larger support in jackson for `record`s since we last updated.\r\n\r\nI don't know if there is supposed to be support for the above test case from the repo maintainers, but I will also stop and let them comment. \n\nComment by JooHyukKim:\nSo as per [release note](https://github.com/FasterXML/jackson-databind/blob/2.18/release-notes/CREDITS-2.x) there seem to be these three PRs --#3906, #3992, #4175 -- that are titled with the word `record` in it. Other than that, there is a long list of updates that got included in 2.16.0 release.\n\nComment by yihtserns:\n> ...titled with the word `record` in it.\r\n\r\nI don't think this thing is Record-specific.\n\nComment by JooHyukKim:\nBecause of project's current on-going milestone aka `Property Introspection Rewrite` (also mentioned in [2.17](https://groups.google.com/d/msgid/jackson-dev/CAL4a10gtvE9_X78DtEBpyA%3DV_0WjrxgpzJ9kUif_aBLKRu-noQ%40mail.gmail.com)), we neither can have have fix any time soon nor confidently specify how record should behave.\n\nComment by Incara:\n> Because of project's current on-going milestone aka `Property Introspection Rewrite` (also mentioned in [2.17](https://groups.google.com/d/msgid/jackson-dev/CAL4a10gtvE9_X78DtEBpyA%3DV_0WjrxgpzJ9kUif_aBLKRu-noQ%40mail.gmail.com)), we neither can have have fix any time soon nor confidently specify how record should behave.\r\n\r\nI think that's fine. The below test does work on 2.16.x and that suits our use cases for now.\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                             @JsonProperty (\"intField\") Integer testOtherField) {\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 1));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nIt's possible that this is the correct and only supported future usage, but there probably needs to be some consideration (an error, documentation, warning, etc) about the presence of a `@JsonCreator` in a `record` that modifies field names or changes the input of the `record`. Another example below:\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\n\r\npublic class RecordTest {\r\n\r\n    public static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\r\n            .registerModule(new ParameterNamesModule()).findAndRegisterModules();\r\n\r\n    public record TestObject(String testFieldName, Integer testOtherField) {\r\n\r\n        @JsonCreator\r\n        public TestObject(@JsonProperty (\"strField\") String testFieldName,\r\n                          @JsonProperty (\"someOtherIntField\") Integer testOtherIntField,\r\n                          @JsonProperty (\"intField\") Integer testOtherField) {\r\n            this(testFieldName, testOtherField + testOtherIntField);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws JsonProcessingException {\r\n        final String result = OBJECT_MAPPER.writeValueAsString(new TestObject(\"test\", 2, 1));\r\n        assertTrue(result.contains(\"intField\"));\r\n        assertTrue(result.contains(\"strField\"));\r\n    }\r\n}\r\n```\r\n\r\nI'm not even sure how the above could work, so it's most likely not valid or going to be supported, but I don't know that as a consumer. \n\nComment by cowtowncoder:\nFWTW, if not Record-specific, reproduction without Record would be great (since it's likely in shared code b/w POJOs, Records).\n\nComment by cowtowncoder:\nLooking at the original case, it does seem like a flaw: `@JsonCreator`-annotated constructor should be used as the primary one, and any property name changes should be used from that.\r\n\r\nAnd while fix may or may not be easy, a PR for reproduction, would be great.\r\nIt seems to be this would be Record-specific thing, fwtw, as fully annotated case\r\n\r\n\r\n> > ...titled with the word `record` in it.\r\n> \r\n> I don't think this thing is Record-specific.\r\n\r\nLooking at the original reproduction, it would seem it is?\r\nOr why do you think it isn't?\r\n\n\nComment by cowtowncoder:\nOk, at any rate: a PR for failing test case (under `src/test-jdk17/java/..../failing`) would be great, either against 2.17 or 2.18 branch.\n\nComment by JooHyukKim:\n> Ok, at any rate: a PR for failing test case (under `src/test-jdk17/java/..../failing`) would be great, either against 2.17 or 2.18 branch.\r\n\r\nMost test cases here make use of `ParameterNamesModule`, so it seems not possible?\n\nComment by yihtserns:\n@JooHyukKim I think this can help: https://github.com/FasterXML/jackson-databind/blob/2.18/src/test-jdk17/java/com/fasterxml/jackson/databind/records/Jdk8ConstructorParameterNameAnnotationIntrospector.java\n\nComment by cowtowncoder:\nUgh. I missed `ParameterNamesModule` reference since that wasn't in the original description.\r\n\r\nCorrect, tests here cannot use it.\r\n\r\nThere are a few tests tho that implement replica, `AnnotationIntrospector` that provides bogus names for testing. So it is possible, if tedious, to do that (beside one that @yihtserns referenced).\r\n\n\nComment by JooHyukKim:\nFiled PR #4477. It does fail from 2.16 version and on.\n\nComment by cowtowncoder:\nOk, I know what is causing this: before #4515, Constructor properties are not resolved for Record serialization (for some reason). It is likely this can be fixed ones #4515 fix is complete enough.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "`@JsonProperty` not serializing field names properly on `@JsonCreator` in Record",
                "name": "issue#4452",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4452"
                    }
                ],
                "similarity": 0.31522564712326334,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4545",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nI found a behavior change when enabling the javac `-parameters` option on an existing java project.\r\nNot sure if this is a bug or intended, just sharing in case it can help others.\r\n\r\n- In a `@JsonCreator` constructor, the value from a `@JsonProperty` appears to be ignored for a parameter if a match exists between a json key name and the parameter name\r\n- This behavior is not true anymore if the code is compiled with `-parameters` (javac) and `ParameterNamesModule` module is registered\r\n\r\n### Version Information\r\n\r\n2.17.1\r\n\r\n### Reproduction\r\n\r\nHave `jackson-module-parameter-names` as a dependency:\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>com.fasterxml.jackson.module</groupId>\r\n\t<artifactId>jackson-module-parameter-names</artifactId>\r\n</dependency>\r\n```\r\n\r\nObject used for deserialization:\r\n\r\n```java\r\npublic class Payload {\r\n\r\n    private final String key1;\r\n    private final String key2;\r\n\r\n    @JsonCreator\r\n    public Payload(\r\n            @JsonProperty(\"key\") String key1, // NOTE: the mismatch `key` / `key1` is important\r\n            @JsonProperty(\"key2\") String key2\r\n    ) {\r\n        this.key1 = key1;\r\n        this.key2 = key2;\r\n    }\r\n\r\n    public String getKey1() {\r\n        return key1;\r\n    }\r\n\r\n    public String getKey2() {\r\n        return key2;\r\n    }\r\n}\r\n```\r\n\r\nTest:\r\n\r\n```java\r\n@Test\r\nvoid test() throws JsonProcessingException {\r\n\tvar jsonPayload = \"\"\"\r\n\t\t\t{\r\n\t\t\t\t\"key1\": \"val1\",\r\n\t\t\t\t\"key2\": \"val2\"\r\n\t\t\t}\r\n\t\t\t\"\"\";\r\n\r\n\tPayload payload = new ObjectMapper()\r\n\t\t\t.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\r\n\t\t\t.findAndRegisterModules()\r\n\t\t\t.readValue(jsonPayload, Payload.class);\r\n\r\n\tAssertions.assertEquals(payload.getKey1(), \"val1\");\r\n\tAssertions.assertEquals(payload.getKey2(), \"val2\");\r\n}\r\n```\r\n\r\nThis test pass, I find it a bit weird that the `@JsonProperty` value can be by-passed if the parameter name matches, but I guess this is a wanted/documented behavior.\r\n\r\nNow, compile the code with `-parameters` javac option:\r\n\r\n```xml\r\n<build>\r\n\t<plugins>\r\n\t\t<plugin>\r\n\t\t\t<groupId>org.apache.maven.plugins</groupId>\r\n\t\t\t<artifactId>maven-compiler-plugin</artifactId>\r\n\t\t\t<version>3.12.1</version>\r\n\t\t\t<configuration>\r\n\t\t\t\t<parameters>false</parameters>\r\n\t\t\t</configuration>\r\n\t\t</plugin>\r\n\t</plugins>\r\n</build>\r\n```\r\n\r\nWithout any code change, the test does not pass anymore because `key1` is `null` after deserialization.\r\n\r\nI have created a small project to reproduce this case: https://github.com/ajacob/jackson-javac-parameters\r\n\r\n### Expected behavior\r\n\r\nWe expected `key1` to be `null` after deserialization when `-parameters` is not enabled but may be this is a wanted behavior to have a fallback on the parameter name.\r\n\r\nWe didn't expected a behavior change when `-parameters` option is enabled on javac with `ParameterNamesModule` enabled.\r\n\r\nIn our case, we simply fixed the wrongly annotated parameters from the constructor to fix our issue\r\n\r\n### Additional context\r\n\r\n_No response_\n\n\nComment by ajacob:\nWe also noticed that serialization behavior was different, without `-parameters` the resulting json is:\r\n\r\n```json\r\n{\r\n    \"key2\" : \"val2\",\r\n    \"key1\" : \"val1\"\r\n}\r\n```\r\n\r\nwith `-parameters` the resulting json becomes:\r\n\r\n```json\r\n{\r\n    \"key\" : \"val1\",\r\n    \"key2\" : \"val2\"\r\n}\r\n```\r\n\r\nThis can be reproduced with the following test:\r\n\r\n```java\r\n@Test\r\nvoid test_serialization() throws JsonProcessingException {\r\n\tPayload payload = new Payload(\"val1\", \"val2\");\r\n\r\n\tString jsonPayload = new ObjectMapper()\r\n\t\t\t.enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS) // deterministic output\r\n\t\t\t.enable(SerializationFeature.INDENT_OUTPUT)\r\n\t\t\t.findAndRegisterModules()\r\n\t\t\t.writeValueAsString(payload);\r\n\r\n\tAssertions.assertEquals(\"\"\"\r\n\t\t\t{\r\n\t\t\t  \"key2\" : \"val2\",\r\n\t\t\t  \"key1\" : \"val1\"\r\n\t\t\t}\"\"\", jsonPayload);\r\n}\r\n```\r\n\r\nI have updated the following repository: https://github.com/ajacob/jackson-javac-parameters\n\nComment by cowtowncoder:\nQuick note: change in serialization order is most likely due to `MapperFeature.SORT_CREATOR_PROPERTIES_FIRST` defaulting to `true` (for historical reasons): basically, properties bound to a Creator (constructor or factory method) gets sorted before any other properties, regardless of whether alphabetic ordering is enabled.\r\nNote, though, that without specific definition of property sorting, order is not really guaranteed, because JDK does not guarantee order in which Field and Method declarations are exposed via Reflection\r\n\r\nAnyway: you may want to disable that setting.\r\n\n\nComment by JooHyukKim:\nShould we start this issue over at [parameter-names-module](https://github.com/FasterXML/jackson-modules-java8) repo?\n\nComment by cowtowncoder:\nI was hoping to create a reproduction on `jackson-databind` side, with implicit name introspector.\r\nThat way we could cover 2.x and 3.0 both (3.0 won't have separate parameter-names module).\n\nComment by cowtowncoder:\nOk, with #4515 work, this actually works as expected now: deserialization fails as expected.\r\n\r\nHowever: I noticed that there can be cases where it unexpectedly passes (withOUT parameter names module...). This is because of combination of `public String getKey1();` and field `String key1`.\r\nWith default settings this field is actually considered mutator for `key1` -- despite being final.\r\nTo disable it, `MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS` needs to disabled (enabled by default).\r\n\r\n\n\nComment by ajacob:\n> Ok, with #4515 work, this actually works as expected now: deserialization fails as expected.\r\n> \r\n> However: I noticed that there can be cases where it unexpectedly passes (withOUT parameter names module...). This is because of combination of `public String getKey1();` and field `String key1`. With default settings this field is actually considered mutator for `key1` -- despite being final. To disable it, `MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS` needs to disabled (enabled by default).\r\n\r\nThank you for having a look and for detailed explanation",
                "source_code": null,
                "distance": 0.75,
                "title": "Unexpected deserialization behavior with `@JsonCreator`, `@JsonProperty` and javac `-parameters`",
                "name": "issue#4545",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4545"
                    }
                ],
                "similarity": 0.3137321963413173,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "806",
                "type": "issue",
                "content": "Just a reference to https://github.com/FasterXML/jackson-module-parameter-names/issues/18 since this is most likely a problem with databind and not the parameter names access module.\n\n\n\nComment by cowtowncoder:\nI can reproduce this, but it is not an easy problem to fix. The problem is that whereas with `@JsonCreator` properties get detected early, so that `POJOPropertiesCollector` can apply name mangling. without that annotation properties are only added to the map at a later stage, when doing more thorough introspection.\n\nSo: a problem to be fixed. But not a quick one to fix.\n\n\nComment by cowtowncoder:\nAnd just to clarify earlier note (since I had forgotten and had to re-learn this): inclusion of `@JsonCreator` will work around the issue, so this is due to renaming being performed at wrong phase, relative to processing.\r\n\r\n\n\nComment by cowtowncoder:\nFixed via #4515 for inclusion in 2.18.0.",
                "source_code": null,
                "distance": 0.75,
                "title": "Problem with `NamingStrategy`, creator methods with implicit names",
                "name": "issue#806",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#806"
                    }
                ],
                "similarity": 0.29478724597958617,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4547",
                "type": "issue",
                "content": "Try again, try to resolve single-param Creator issues.\n\n\nComment by cowtowncoder:\nOk. I think I know the problem ... after changes, auto-detection for\r\n\r\n```\r\n    static class DoubleConstructorBean {\r\n        Double d;\r\n        @JsonCreator protected DoubleConstructorBean(Double d) {\r\n            this.d = d;\r\n        }\r\n    }\r\n```\r\n\r\nwill auto-detect as properties-based (due to existence of field `d`) if (and only if!) parameter names are detected. And 3.0 (`master`) bundles parameter name introspector; 2.18 does not -- this is why the issue not found in 2.18.\r\n\r\nWill need to figure this out.\r\n\r\n\r\n\r\n\n\nComment by cowtowncoder:\nOk: was able to figure out improvement (see #4548), resolving 7 issues leaving just 4 left.\r\nSo getting there.\r\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Merge #4515 from 2.18 to master",
                "name": "pr#4547",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4546"
                    },
                    {
                        "start_node": "pr#4546",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4547"
                    }
                ],
                "similarity": 0.28501848206803515,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3900",
                "type": "issue",
                "content": "`MapperFeature.SORT_PROPERTIES_ALPHABETICALLY` is no longer respected by record method based JSON properties\r\n\r\n**Version information**\r\n2.15\r\n\r\n**To Reproduce**\r\n```java\r\n    final var mapper =\r\n        Jackson.mapperBuilder()\r\n            .enable(SerializationFeature.INDENT_OUTPUT)\r\n            .enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)\r\n            .build();\r\n\r\n    record R(String c, String b, String e) {\r\n\r\n      @JsonProperty\r\n      String a() {\r\n        return \"4\";\r\n      }\r\n    }\r\n\r\n    System.out.println(mapper.writeValueAsString(new R(\"1\", \"2\", \"3\")));\r\n```\r\nOutput:\r\n\r\n```\r\n  {\r\n    \"b\" : \"2\",\r\n    \"c\" : \"1\",\r\n    \"e\" : \"3\",\r\n    \"a\" : \"4\"\r\n  }\r\n\r\n```  \r\nThe property 'a' in the example below comes at the last place:\r\n\r\n\r\n**Expected behavior**\r\nAll record properties must be serialized the natural order\r\n\r\n\n\n\nComment by yihtserns:\n## Fix/workaround\r\nDisable `MapperFeature.SORT_CREATOR_PROPERTIES_FIRST`:\r\n```\r\nJackson.mapperBuilder()\r\n    .enable(SerializationFeature.INDENT_OUTPUT)\r\n    .enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)\r\n    .disable(MapperFeature.SORT_CREATOR_PROPERTIES_FIRST)\r\n    .build();\r\n\r\n```\r\n\r\n## Explanation\r\nPreviously, Records deserialization is specially handled, resulting in some behavioural differences (mostly missing behaviours) compared to POJO deserialization.\r\n\r\n~~#2992~~ #3724 was done to address those differences, to close the gap between Records vs POJO  de/serialization.  Because of that, this Record class:\r\n```\r\nrecord R(String c, String b, String e) {\r\n\r\n  @JsonProperty\r\n  String a() {\r\n    return \"4\";\r\n  }\r\n}\r\n```\r\n...behaves similarly to:\r\n```\r\npublic class R {\r\n    private String c;\r\n    private String b;\r\n    private String e;\r\n    \r\n    @ConstructorProperties({\"c\", \"b\", \"e\"})\r\n    public R(String c, String b, String e) {\r\n        this.c = c;\r\n        this.b = b;\r\n        this.e = e;\r\n    }\r\n\r\n    public String getC() { \r\n        return this.c;\r\n    }\r\n    \r\n    public String getB() {\r\n        return this.b;\r\n    }\r\n    \r\n    public String getE() {\r\n        return this.e;\r\n    }\r\n    \r\n    @JsonProperty\r\n    public String a() {\r\n        return \"4\";\r\n    }\r\n}\r\n```\r\n...resulting in this issue.\r\n\r\nI'm really sorry about the inconvenience this caused you. Reminds me of an adage that one does not simply fix a bug - some \"bugs\" may be relied on as features.  \ud83d\ude2c\n\nComment by JooHyukKim:\noh no, @yihtserns \ud83d\udc4d\ud83c\udffb It's already good you feel responsible. I don't think you should be sorry because, the change thoroughly discussed (I really did read most part). I could have written more tests against record types. \n\nComment by cowtowncoder:\nAs unfortunate as unplanned behavior changes are, I will consider this \"works as intended\", so that one needs to disable:\r\n\r\n```\r\nMapperFeature.SORT_CREATOR_PROPERTIES_FIRST\r\n```\r\n\r\nto force sorting of all properties.\r\n\r\n\n\nComment by agavrilov76:\n@cowtowncoder Can you consider disabling SORT_CREATOR_PROPERTIES_FIRST by default by any chance?\r\n\r\nI think the fact that enabling one single SORT_PROPERTIES_ALPHABETICALLY feature doesn't automatically work for all the properties is not quite expected behavior. Not sure how many people would use SORT_PROPERTIES_ALPHABETICALLY with SORT_CREATOR_PROPERTIES_FIRST set as the default.\r\n\r\nJust for the context, my use case is testing. I compare generated JSON documents with data files stored in a canonical form sorting properties and map entries.\n\nComment by JooHyukKim:\n> I think the fact that enabling one single SORT_PROPERTIES_ALPHABETICALLY feature doesn't automatically work for all the properties is not quite expected behavior.\r\n\r\nI cannot disagree... \ud83d\udc40 \r\n\r\nIn fact, from a user's perspective,\r\n- `SORT_PROPERTIES_ALPHABETICALLY` intuitively sounds like superset of all(if not most) property sorting\r\n-  `SORT_CREATOR_PROPERTIES_FIRST` sounds like partial sorting\r\n\r\nMaybe you can file an issue regarding suggestion, @agavrilov76 ?\n\nComment by yawkat:\nthe problem with disabling SORT_CREATOR_PROPERTIES_FIRST is that putting creator properties first is more performant for deserialization. since all creator properties are required to create the instance, all properties before the last creator property in the input need to be buffered. SORT_CREATOR_PROPERTIES_FIRST ensures that there is as little buffering as possible.\n\nComment by JooHyukKim:\n> the problem with disabling SORT_CREATOR_PROPERTIES_FIRST is that putting creator properties first is more performant for deserialization. \r\n\r\nThis is quite informant...  putting a side the changing of default configuration, let's add this to the JavaDoc itself. \r\nThank you for your explanation! \ud83d\ude4f\ud83c\udffc\ud83d\ude4f\ud83c\udffc\r\n\r\nExplanation of @yawkat added to PR ([see](https://github.com/FasterXML/jackson-databind/pull/3917/files#r1185811042))\n\nComment by cowtowncoder:\nAs per @yawkat's pointing it out, there are non-trivial performance implications.\r\nChanging default setting would also change observed sorting order of existing users and could break some usage (ideally shoudn't as ordering of properties is conceptually undefined for JSON but... in practice...).\r\nSo I don't think I'd want to change defaults for 2.x.\r\nThis could be changed for 3.0 however; if so, please file a new issue.\r\n\n\nComment by yawkat:\nI just saw that if *neither* SORT_CREATOR_PROPERTIES_FIRST or SORT_PROPERTIES_ALPHABETICALLY is set, jackson will still put creator properties first. So it may be safe to disable SORT_CREATOR_PROPERTIES_FIRST by default since SORT_PROPERTIES_ALPHABETICALLY is also off by default, so with default settings the output would be unchanged.\n\nComment by cowtowncoder:\nOk but what is the specific upside of doing that? Would it make enabling `SORT_PROPERTIES_ALPHABETICALLY` work more logically wrt user expectations?",
                "source_code": null,
                "distance": 0.75,
                "title": "MapperFeature.SORT_PROPERTIES_ALPHABETICALLY is not respected for records",
                "name": "issue#3900",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3900"
                    }
                ],
                "similarity": 0.28158967921516154,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3724",
                "type": "issue",
                "content": "### New\r\n- Supports `@JsonCreator.mode=DISABLED` on canonical constructor.\r\n- Supports deserialization using \"implicit\" (i.e. without `@JsonCreator` annotation) non-canonical constructor when 1/more of its parameter is/are annotated with `@JsonProperty`.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating constructor.\r\n- Supports \"implicit\" (i.e. without `@JsonCreator` annotation) 1-arg delegating factory method.\r\n- Supports disabling \"implicit\" (i.e. without `@JsonCreator` annotation) constructor/factory method detection via `MapperFeature.AUTO_DETECT_CREATORS`.\r\n\r\nThis is a non-exhaustive list - I don't have full knowledge of existing JavaBeans deserialization capabilities.\r\n\r\n### Fixes\r\n- Fixes #2974\r\n- Fixes #2992\r\n- Resolves #3180 (via \"implicit\" 1-arg delegating constructor/factory method)\r\n- Fixes #3297\r\n- Fixes #3342\r\n\n\n\nComment by cowtowncoder:\nFirst of all, thank you for contributing this @yihtserns ! It sounds like solid improvement, potentially.\r\n\r\nI added some smaller notes on keeping existing API in some places, but there is one bigger request I have: this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14 -- patches are typically for smaller, less risky changes, and while I don't have specific issues here I feel there is potential for some breakage.\r\n\r\n\n\nComment by yihtserns:\n> ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n\r\nDo I put \"since 2.15\" in the deprecation notice?\r\n\r\nAnd yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter...  That doc needs to be updated?\n\nComment by cowtowncoder:\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n> \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\n\r\n\r\n> > ...this PR needs to be against `2.15` branch; I don't feel comfortable merging it in a patch to 2.14...\r\n> \r\n> Do I put \"since 2.15\" in the deprecation notice?\r\n\r\nYes.\r\n \r\n> And yeah I wasn't sure whether I should go with 2.14 or 2.15 since https://github.com/FasterXML/jackson/blob/master/CONTRIBUTING.md didn't mention the latter... That doc needs to be updated?\r\n\r\nThanks, I'll need to update that. There are some things that should go into earlier branches too -- generally earliest maintained, for safe enough fixes. So it is not easy to correctly guess what I think is the right branch :)\r\n(which is also why I don't mind pointing out what I think should be used).\r\n\r\n\r\n\n\nComment by cowtowncoder:\nOk, looks pretty good. I do need to go over it again with more thought, but I like how small changes are.\r\n\n\nComment by cowtowncoder:\n@yihtserns One more thing: I hope to be able to merge this soon. One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution. This only needs to be done once and then it is good for all future PRs for Jackson project.\r\n\r\nDocument is here:\r\n\r\nhttps://github.com/FasterXML/jackson/blob/master/contributor-agreement.pdf\r\n\r\nand the usual way is to print, fill & sign, scan/photo, email to `info` at fasterxml dot com.\r\nOnce I get the document I will be able to merge the PR (I will do one more code review but I assume we are very close).\r\n\r\nThank you again for providing this patch -- looking forward to merging it!\r\n\r\n\r\n\r\n\n\nComment by yihtserns:\nI'm currently re-reviewing if `@JsonIgnore` can be supported in a different way (else the explanation of the current approach will be a headache).\r\n\r\n**UPDATE**: Didn't manage to find a low-change way, so decided to stick with this approach (with some difference) + smothered it with docs.\n\nComment by yihtserns:\n> One last thing before that is that we need a Contributor License Agreement (CLA) before merging the first contribution\r\n\r\nCLA sent.\n\nComment by cowtowncoder:\nOk looks good, will merge! Will see how much trouble merging into `master` (3.0) will be....\n\nComment by cowtowncoder:\nUgh. Ok, so I was able to merge code. But now there are ~20 failures for Record-related tests in `master`.\r\n\r\nAlso: I think I may disagree with test\r\n\r\n        public void testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames() throws Exception\r\n\r\nwherein it is claimed there are 2 usable Creators (canonical, one with `@JsonProperty` annotation).\r\nIt seems to me that while constructor has no `@JsonCreator`, existence of `@JsonProperty` would make that explicit constructor, over canonical constructor.\r\n\r\nBut be that as it may, I think I will need help with `master`, failing tests. I think some calls are now missing so that even simplest of `Record` tests in `RecordsBasicTest` fail.\r\n\r\n\r\n\n\nComment by yihtserns:\n> But be that as it may, I think I will need help with master, failing tests.\r\n\r\nOK I'll look into them.\n\nComment by cowtowncoder:\nThank you @yihtserns! I am zeroing in on one issue: VisibilityChecker for Constructors is somehow claiming default record constructors are not visible. I'll try to see what gives...\n\nComment by cowtowncoder:\nOk, yes; there is something in minimum visibility needed; defaults are defined by `@JsonAutoDetect` annotation in `VisibilityChecker` and have changed to require `public` for 3.0.\r\n\r\nBut what seems odd to me is how canonical constructor is apparently not generated as `public` (looking at decompiled record classes) but as package default.\r\nSo I think one way to fix this would be to somehow use differently configured `VisibilityChecker` for records; similar to have \"all public\" variant is (by default) used for JDK types.\r\nLooks like logic could be injected from `getDefaultVisibilityChecker()` of `MapperConfigBase`; possibly checking if type is a record type (before even checking for \"is JDK class\").\r\n\r\n\n\nComment by yihtserns:\n> But what seems odd to me is how canonical constructor is apparently not generated as public\r\n\r\nThey aren't public because the `record` declarations weren't public.  Changing `record XXX` to `public record XXX` reduced test failures from 21 to 3.\r\n\r\n(For some of the records, although the declaration itself weren't `public`, their _declared_ constructors are `public` so they're not failing.)\n\nComment by yihtserns:\nI've created https://github.com/FasterXML/jackson-databind/pull/3733 (will remain in draft until all test failures are resolved) to deal with issues related to the 3.0 port - let's continue this conversation there.\n\nComment by yihtserns:\n@pjfanning @cowtowncoder thank you for taking the time to review this PR, I really appreciate it.\n\nComment by cowtowncoder:\nFWTW, I think this change may have also caused a regression of one Kotlin test:\r\n\r\nhttps://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\n\nComment by yihtserns:\n> FWTW, I think this change may have also caused a regression of one Kotlin test: https://github.com/FasterXML/jackson-module-kotlin/issues/396\r\n\r\nSo [Github396.kt](https://github.com/FasterXML/jackson-module-kotlin/blob/2.15/src/test/kotlin/com/fasterxml/jackson/module/kotlin/test/github/failing/Github396.kt) is a negative test that expects deserialization to fail with `MismatchedInputException`, but it is now by managing to deserialize `<product><stuff></stuff></product>` into `Product(stuff=Stuff(str=null))`.\r\n\r\nThat seems to have been caused by #3676.  When I change `BeanDeserializerBase.getEmptyValue(...)` from `_valueInstantiator.createUsingDefaultOrWithoutArguments(...)` back to `_valueInstantiator.createUsingDefault(...)`, that negative test is passing again.\n\nComment by cowtowncoder:\n@yihtserns Ok. So not these changes but earlier one; and unnoticed since there's no cascading CI builds across projects (that is, without changes to Kotlin module, no CI triggered when databind has changed -- something that'd be really nice to somehow resolve).\r\n\r\nBut this sounds like it would be a good thing? I am not big fan of negative tests because of this, although the main alternative (having failing tests under `failing/`) has the problem of \"hiding\" fixes.\r\n\r\n\n\nComment by cowtowncoder:\n@yihtserns Ok yes, thank you for pointing out the \"failing to fail\" part. This is indeed something fixed in `jackson-dataformat-xml` so I just had to change test. Looking how things work it's actually not a bad idea to verify \"is now fixed\" part... need to keep that in mind wrt other modules :)\n\nComment by yihtserns:\n> Also: I think I may disagree with test `testDeserializeMultipleConstructorsRecord_WithExplicitAndImplicitParameterNames()` wherein it is claimed there are 2 usable Creators (canonical, one with @JsonProperty annotation).\r\nIt seems to me that while constructor has no @JsonCreator, existence of @JsonProperty would make that explicit constructor, over canonical constructor.\r\n\r\n@cowtowncoder when I test the POJO equivalent:\r\n```\r\npublic static class BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator {\r\n\r\n    // Private fields\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(int id, String name, String email) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n    }\r\n\r\n    public BeanWithJsonPropertyAndImplicitPropertyWithoutJsonCreator(@JsonProperty(\"id_only\") int id, String email) {\r\n        this.id = id;\r\n        this.email = email;\r\n    }\r\n\r\n    // Public getters\r\n}\r\n```\r\n\r\nI get the same failure as Records':\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.github.yihtserns.records.jackson.RecordCanonicalVsJsonPropertyTest$RecordWithJsonPropertyAndImplicitPropertyWithoutJsonCreator` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n\r\nBug?  Although from a quick search in Issues, nobody is complaining about it anyway.  \ud83e\udd37\u200d\u2642\ufe0f \n\nComment by cowtowncoder:\n@yihtserns If there is no module for getting implicit constructor parameter names, I'd expect failure since partial use of `@JsonProperty` is not enough for detection. But if parameter name detection exists, I am not 100% sure if logic would only allow it if there are no competing constructors (ones with or without annotation).\r\n\r\nThe thing that further complications matters is that POJOs do not have canonical constructor to solve the case where nothing is annotated -- but there are always implicit names.\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nRenovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n\r\nThese are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\n\nComment by yihtserns:\n@leonardehrenfried that symptom sounds similar to the one describe in https://github.com/FasterXML/jackson-databind/issues/3628#issuecomment-1504892161 - let me test that.\n\nComment by yihtserns:\n@leonardehrenfried so I tested `OpenTripPlanner`:\r\n1. Changed `jackson.version` in `pom.xml` to `2.15.0`.\r\n2. Run `mvn test` to observe the test failures (there's 1 unrelated to Records, so I'm ignoring it).\r\n3. Create a local fork of `jackson-databind:2.15.0`, reverting [0a4cfc4](https://github.com/FasterXML/jackson-databind/commit/0a4cfc46bc491aed9eab83e13dcd65d415b10c64#diff-8a89bf8f93c483493c778cda25b2e31e2e89bd4b0a8a131e71bfd2ed5a199fff).\r\n4. Change `OpenTripPlanner/pom.xml`'s `jackson-databind` to refer to that local fork.\r\n5. Run `mvn test` again - no more test failures related to Records.\r\n\r\nI've confirmed that the issue you're facing is related to the broken workaround mentioned in #3628, unrelated to this change.\n\nComment by leonardehrenfried:\nI since checked and we seem to be using a custom object mapper in the test:\r\n\r\n```\r\n      objectMapper = new ObjectMapper();\r\n      objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);\r\n      objectMapper.enable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);\r\n      objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n      objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\r\n      objectMapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);\r\n      objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n      objectMapper.registerModule(new JavaTimeModule());\r\n      objectMapper.registerModule(new Jdk8Module());\r\n\r\n      objectMapper.setVisibility(\r\n        objectMapper\r\n          .getSerializationConfig()\r\n          .getDefaultVisibilityChecker()\r\n          .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n          .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n          .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n      );\r\n```\r\n\r\nhttps://github.com/opentripplanner/OpenTripPlanner/blob/dev-2.x/src/test/java/org/opentripplanner/routing/algorithm/mapping/SnapshotTestBase.java#L366-L384\r\n\r\nSo it appears that your analysis is totally correct.\r\n\r\nI'm still not clear if this is was an intentional change in Jackson or not - can you clarify this for me?\r\n\r\nAsked the other way around: is the old behaviour going to be restored and I should just wait for a new release or do I need to change the config of my object mapper?\n\nComment by yihtserns:\n> ...do I need to change the config of my object mapper?\r\n\r\nI think that config was used because you had the same problem as #3628, and I can't think of an alternative solution for that problem.\r\n\r\n> ...is the old behaviour going to be restored and I should just wait for a new release...\r\n\r\nI've helped create #3894 to support that type of config.\n\nComment by cowtowncoder:\n> Renovate [auto-updated our application](https://github.com/opentripplanner/OpenTripPlanner/pull/5065) to Jackson 2.15 tonight. Some tests which check that records can be serialized fail as records are always serialized to empty objects.\r\n> \r\n> These are plain records with no annotations or methods. Should that just work or do I need to configure/annotate something? In Jackson 2.14 it just worked.\r\n\r\nThis is why we publish release candidates -- 2.15.0-rc1, rc2, rc3 -- to try to get users to verify if they find any regressions beyond what our unit test suite catches. Nothing was reported for this.\r\n\r\nNow, I don't know what tests you have so I cannot say if behavior is expected or not: sometimes usage is based on undefined behavior, in which case change may be intended (typically due to a fix to some known problem, and change to unsupported case incidental).\r\n\r\nThank you for helping create a new issue. We'll see where that leads.\r\n\r\n\r\n\r\n\n\nComment by leonardehrenfried:\nI'm sorry and as an open source maintainer myself I feel you.\r\n\r\nI'm the last guy showing up on an issue making demands.\r\n\r\nI would love to help diagnose and test and don't expect you to make a potentially broken config work for my benefit.\n\nComment by cowtowncoder:\n@leonardehrenfried Oh and just to make sure: I did not mean to blame you or users at all. I appreciate your reaching out and reporting the issue. I think we can figure this out; PR submitted might be the way, although I have some reservations. But it's a tricky problem.\n\nComment by yihtserns:\n@leonardehrenfried I've spent a bit of time to study your codebase to understand why that config was used - seems like it was to prevent `ApiLeg.getDuration()` from being serialized.\r\n\r\nI assume that is to make assertion easier, since that method returns non-constant number?\r\n\r\nIf that's the case, here's my suggestion (tested with `2.15.0`):\r\n```java\r\npublic abstract class SnapshotTestBase {\r\n    ...\r\n\r\n    private static class SnapshotItinerarySerializer implements SnapshotSerializer {\r\n\r\n        private SnapshotItinerarySerializer() {\r\n            ...\r\n\r\n            // Remove this config:\r\n            //objectMapper.setVisibility(\r\n            //    objectMapper\r\n            //      .getSerializationConfig()\r\n            //      .getDefaultVisibilityChecker()\r\n            //      .withFieldVisibility(JsonAutoDetect.Visibility.ANY)\r\n            //      .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //      .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)\r\n            //);\r\n\r\n            // Add this:\r\n            objectMapper.addMixIn(ApiLeg.class, ApiLegMixin.class);\r\n            ...\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * To exclude {@link ApiLeg#getDuration()} from being deserialized because the returned number\r\n     * is non-constant making it impossible to assert.\r\n     */\r\n    private abstract static class ApiLegMixin {\r\n\r\n      @JsonIgnore\r\n      abstract double getDuration();\r\n    }\r\n}\r\n```\n\nComment by leonardehrenfried:\n@yihtserns thanks so much for this. It absolutely fixes the problems we are having. Fantastic work!\n\nComment by agavrilov76:\nRelated to https://github.com/FasterXML/jackson-databind/issues/3900\n\nComment by cowtowncoder:\nAnother breakage: #3938.\n\nComment by yihtserns:\nI used to think \"nobody would ever put a setter in a Record since nothing is mutable, right?\"\r\n\r\nNow I know how ignorant I was...\n\nComment by cowtowncoder:\nTo be honest, that use case is a bit \"Creative\" and just used to prevent deserialization of something without full ignoral.\r\nBut it is something I'd have used with regular POJOs and works very well for what is needed.\r\n\r\nIf someone else has shown that use case to me, I might have argued against it tho, with Records. Given that they are immutable.\r\n\r\nAnyway, was happy to figure out how to make it work again via fix for #3928.\r\n\n\nComment by yihtserns:\nCaused #3968.",
                "source_code": null,
                "distance": 0.75,
                "title": "Change Records deserialization to use the same mechanism as POJO deserialization.",
                "name": "pr#3724",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#3724"
                    }
                ],
                "similarity": 0.26160248189758184,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3",
                "type": "issue",
                "content": "As an example, `CollectionDeserializer` declares `createContextual` with the base return type of `JsonDeserializer<?>`, when it could legally and more accurately return `CollectionDeserializer`. This allows wrapper deserializers using CollectionDeserializer as a delegate to implement `createContextual` without an unnecessary cast.\n\n\n\nComment by cowtowncoder:\nAh. Yes, this does make sense. At first I read this to request that createContextual itself should be parametric (which it was in 1.x), which was bit of hassle. But co-variance on impls makes sense: will do this. Also feel free to send pull requests for specific cases.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Use covariant return types for createContextual methods in standard implementations when appropriate",
                "name": "issue#3",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3"
                    }
                ],
                "similarity": 0.26050853995030976,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "2974",
                "type": "issue",
                "content": "Looks like use of `@JsonSetter(nulls=...)` does not work with Records in 2.12.0.\r\n\r\nNote that earlier report (#2970) turned out to be valid, but since I closed it earlier decided to file a separate one.\r\n\n\n\nComment by cowtowncoder:\nOh boy. This gets deeper and deeper. But long and short of this is that there IS one specific work-around: name your constructor parameters and linkage works. For example:\r\n\r\n```\r\n    record RecordWithNonNullDefs(List<String> names,Map<String, Integer> agesByNames)\r\n    {\r\n        @JsonCreator\r\n        public RecordWithNonNullDefs(\r\n            @JsonProperty(\"name\") @JsonSetter(nulls=Nulls.AS_EMPTY) List<String> names,\r\n            @JsonProperty(\"agesByNames\") @JsonSetter(nulls=Nulls.FAIL) Map<String, Integer> agesByNames)\r\n        {\r\n            this.names = names;\r\n            this.agesByNames = agesByNames;\r\n        }\r\n    }\r\n```\r\n\r\nNot pretty but works. I'll see if this can be fixed more generally but this is the workaround for now.\r\n\r\n\n\nComment by cowtowncoder:\nOk so the problem is as follows:\r\n\r\n1. During initial  `POJOPropertiesCollector` scan, only explicitly-annotated constructor _parameters_ are located (no attention paid to Creator (constructor/factory) methods themselves, linked to method/field accessors\r\n2. `BasicBeanDescription` is constructed\r\n3. `BeanDeserializerFactory` (and/or `BasicDeserializerFactory`) goes over Creator candidates, selects what to included, but does not (can not?) link `CreatorProperty` instances found using this method; only ones that were already located are\r\n\r\nNow: there are couple of ways things could be improved. For example, either\r\n\r\n* Try to link not-explicitly-named properties from step (3), after the fact (also merging annotations)\r\n* Move Creator discovery to an earlier stage (POJOPropertiesCollector); at least explicitly located ones\r\n\r\nof these, first option seems more likely for 2.x; second better overall (and hence for 3.x).\r\nBut both are big enough changes that they probably should NOT be attempted for 2.12.x patch release; esp. since there are workarounds.\r\n\r\nSo marking this as 2.13, unlikely to be attempted for 2.12.x.\r\n\r\n\r\n\r\n\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Null coercion with `@JsonSetter` does not work with `java.lang.Record`",
                "name": "issue#2974",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#2974"
                    }
                ],
                "similarity": 0.2586307902185439,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4508",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nI have kotlin data class\r\n```@JsonTypeName(\"perform\")\r\ndata class Request(\r\n    @JsonProperty(\"header\")\r\n    override val header: String? = null,\r\n    @JsonIgnore\r\n    @JsonAnySetter\r\n    @JsonAnyGetter\r\n    val additionProperties: Map<String, Any?>? = null,\r\n) : Parent(header)\r\n```\r\nand json \r\n```\r\n      {\r\n            \"payloadType\": \"perform\",\r\n            \"data\":{\r\n              \"header\": \"lol\",\r\n              \"type\": \"sometype\",\r\n              \"any_other_data\": {\r\n                  \"field1\": \"1\",\r\n                  \"field2\": \"\",\r\n                  \"field3\": \"\",\r\n                  \"field4\": {\r\n                      \"field5\": \"\",\r\n                      \"field6\": \"\",\r\n                      \"field7\": \"anytext\"\r\n                  }\r\n              }\r\n            }\r\n        }\r\n```\r\n\r\nBefore jackson 2.17.0 the json deserialized into class correctly. any_other_data put to additionalProperties map.\r\nOn 2.17.0 version i have additionalProperties == null after the deserialization.\r\n\r\n### Version Information\r\n\r\n2.17.0\r\n\r\n\r\n### Expected behavior\r\n\r\ni expected that field annotated with @JsonAnySetter will be filled with all the undeclared fields \n\n\nComment by JooHyukKim:\nSince `additionalProperties` has default value of `null`, we can say either...\r\n\r\n- field is deserialized to null\r\n- field is not deserialized, so deafult to null\r\n\r\nCould you provide Java-only reproduction to make sure it is `jackson-databind` issue, @MaximValeev ?\r\nThere is separate [kotlin repo](https://github.com/FasterXML/jackson-module-kotlin) FYI.\n\nComment by cowtowncoder:\nRight; either this needs to move to `jackson-module-kotlin` (I can transfer if so), or reproduction should be in Java.\r\n\r\nBut I think there is probably already an issue wrt `@JsonAnySetter` not working with Creator properties -- and even PR to potentially fix that.\r\n\n\nComment by kotcrab:\nI also ran into this issue, it can be fixed by writing `@field:JsonAnySetter`. In 2.17.0 `ElementType.PARAMETER` was added to the `@Target` list of `JsonAnySetter`, this causes Kotlin to add this annotation to the constructor parameter instead of the field as [described here](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets) if you don't specify explicit use-site target.\n\nComment by JooHyukKim:\nAh, thank u for sharing @kotcrab !\n\nComment by JooHyukKim:\nSome background.\r\n\r\nAs @kotcrab described above, this is regression caused by [annotations module change](https://github.com/FasterXML/jackson-annotations/issues/242), the annotation change was meant to be pre-requisite for the databind-module's  [Allow 'JsonAnySetter' to flow through JsonCreator #562](https://github.com/FasterXML/jackson-databind/issues/562) issue.\r\n\r\nI started writing PR #4366 to support the databind-module change, but stopped to allow room for Property Introspection Rewrite in #4515.\r\n\r\nAs per solution, either....\r\n\r\n- revert adding `ElementType.PARAMETER` to `JsonAnySetter` or... \r\n- ask @k163377 if it's possible to make changes so that Kotlin module can discover `@JsonAnySetter` without `@field:` declaration. Or maybe @cowtowncoder knows the proper extension point for `JsonAnySetter` discovery?\n\nComment by cowtowncoder:\nWait, what is that `@JsonIgnore` doing here??!\r\n\r\n```\r\n    @JsonIgnore\r\n    @JsonAnySetter\r\n    @JsonAnyGetter\r\n    val additionProperties: Map<String, Any?>? = null,\r\n```\r\n\r\nwouldn't that mean \"ignore this any setter/getter\"? That should not be added there.\r\n\r\n\n\nComment by m-valeev:\n@cowtowncoder  No, it wouldn\u2019t. It means ignoring additionalProperties itself in serialization and deserialization. However, the other two annotations, @JsonAnySetter and @JsonAnyGetter, will be used for all unrecognized properties. All unrecognized properties will be added to the map for serialization and obtained from the map for deserialization.\n\nComment by yawkat:\nJsonAnyGetter/Setter will already not appear in the serialization/deserialization as its own property. The JsonIgnore is not necessary and should not be there\n\nComment by cowtowncoder:\n@MaximValeev it is possible `@JsonIgnore` does no harm, but in general it is to remove accessor (getter, setter, field, ctor parameter) from consideration (or if no inclusion, whole property).\r\nAnd as @yawkat pointed out, it should not be necessary as JsonAnyGetter/Setter has priority over regular property detection.\r\n\r\nBut as to proper fix: I think #562 would be that (maybe via #4558) -- to may `@JsonAnySetter` work via Constructor parameter (not just Field or Method).\r\n\r\nAlternatively, yes, Kotlin side should annotate Field to use.\r\n\r\n\n\nComment by k163377:\nI understood that there is nothing to do in `KotlinModule` as it is handled by #4558 .\n\nComment by cowtowncoder:\n@k163377 Yes, I think it's matter of getting #562 resolved (via #4558) and then Kotlin side probably wants to have a test to verify things work there as expected. But hopefully no other work needed (but you never know before testing :) ).\n\nComment by JooHyukKim:\nCaution : this is not about what has caused the change in behavior in 2.17. Instead, this is about making it work in 2.18.\r\n\r\nSo I found out that `StdValueInstantiator.createFromObjectWith(DeserializationContext, SettableBeanProperty[], PropertyValueBuffer)` method is overridden by `KotlinValueInstantiator`. I think we need some modification either on `kotlin-module` or `databind` to support this.\r\n\r\nMy intuition is that, below implementation in `PropertyValueBuffer.getParameters(SettableBeanProperty[])` method...\r\n\r\n```java\r\n        // [databind#562] since 2.18 : Respect @JsonAnySetter in @JsonCreator\r\n        if (_anyParamSetter != null) {\r\n            Object anySetterParameterObject = _anyParamSetter.createParameterObject();\r\n            for (PropertyValue pv = _anyParamBuffered; pv != null; pv = pv.next) {\r\n                pv.setValue(anySetterParameterObject);\r\n            }\r\n            _creatorParameters[_anyParamSetter.getParameterIndex()] = anySetterParameterObject;\r\n        }\r\n```\r\n... should be moved somewhere to make it work? \n\nComment by cowtowncoder:\nIdeally we should remove the need for KotlinValueInstantiator overrides. But on short term, yes, may need to update override in question.\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "deserialized JsonAnySetter field is null ",
                "name": "issue#4508",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4508"
                    }
                ],
                "similarity": 0.24754191884964843,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4175",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nWhen deserializing a record, jackson fails with\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of ... (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n```\r\nIt looks like jackson does not see default constructor.\r\n\r\n### Version Information\r\n\r\n2.16.0-rc1\r\n\r\n### Reproduction\r\n\r\n```java\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Tag;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nclass TestObjectTest {\r\n\r\n    @Test\r\n    public void shouldDeserialize() throws JsonProcessingException {\r\n        TestObject testObject = new ObjectMapper().readValue(\"{\\\"text\\\":\\\"anything\\\"}\", TestObject.class);\r\n        Assertions.assertEquals(\"anything\", testObject.text());\r\n    }\r\n\r\n    private record TestObject(String text) {}\r\n}\r\n```\r\n\r\nWhen I add compact constructor with `@JsonCreator` to TestObject, it works correctly:\r\n\r\n```java\r\n    private record TestObject(String text) {\r\n        @JsonCreator\r\n        private TestObject {\r\n        }\r\n    }\r\n```\r\n\r\n### Additional context\r\n\r\n- It works correctly in version 2.15.3\r\n- tested on java 21\r\n- May be related to https://github.com/FasterXML/jackson-databind/issues/4119\n\n\nComment by pjfanning:\n@janpachol we have tests with records like this. I think that this is most likely down to the record being `private` as opposed to the fact that jackson can't handle `public record TestObject(String text) {}`.\n\nComment by pjfanning:\nI created https://github.com/FasterXML/jackson-databind/pull/4176 as a reproducible test case.\n\nComment by janpachol:\nOh, you're correct, but it looks problem is not in private record, but in private constructor (when record is private, it looks that compilation creates also private constructor):\r\n\r\nThis doesn't work:\r\n```java\r\n    public record TestObject(String text) {\r\n        private TestObject {\r\n        }\r\n    }\r\n```\r\nThis works:\r\n```java\r\n    private record TestObject(String text) {\r\n        public TestObject {\r\n        }\r\n    }\r\n```\n\nComment by cowtowncoder:\nYes, it makes sense the issue is `private` constructor via Record being `private` (in the original case).\r\nGiven it is regression from 2.15, would be great to fix.\n\nComment by JooHyukKim:\nCreated a PR for #4178. The issue seems to link back to the fix for #3906 via https://github.com/FasterXML/jackson-databind/commit/75d0c46a4a773d1852ae2305cba9231d465940fc where sort of force setting of record constructor visibility. \n\nComment by cowtowncoder:\nCool. While I have am bit concerned about change causing some other regression, there isn't much that can be done without reproduction of such problem.\r\n\n\nComment by JooHyukKim:\n> Cool. While I have am bit concerned about change causing some other regression, there isn't much that can be done without reproduction of such problem.\r\n\r\nWrt regression, we may already have some tests against regression via https://github.com/FasterXML/jackson-databind/commit/228bc0ef4a59dd47422603a59812768153ddd1c8 --though indirectly covers.",
                "source_code": null,
                "distance": 1.0,
                "title": "Exception when deserialization of `private` record with default constructor",
                "name": "issue#4175",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    },
                    {
                        "start_node": "issue#4119",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4175"
                    }
                ],
                "similarity": 0.2400403470141115,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4558",
                "type": "issue",
                "content": "resolves #562 \r\n\r\nThis version is more adherent to existing call flow and simply extends existing implementations, such as....\r\n\r\n- Introduction of `SettableAnyProperty` subclasses `JsonNodeParameterAnyProperty` and `MapParameterAnyProperty`\r\n- Introduction of `SettableAnyProperty` methods `getParameterIndex()` `createParameterObject()` to streamline deserialization by `PropertyValueBuffer`\r\n\r\nAlso suggestions from PR #4366 have been followed \r\n\r\n- Added support for `JsonNode` and `ObjectNode`\r\n- Added tests for record also\r\n\n\n\nComment by cowtowncoder:\nExcellent progress! Hoping to review this in detail (had a quick look, much improved from what I already saw -- and not just wrt addressing things I mentioned but overall)\n\nComment by cowtowncoder:\nFWTW, this is part of one of two listed \"major design/implementation issues\" page:\r\n\r\nhttps://github.com/FasterXML/jackson-future-ideas/wiki/Major-Design---Implementation-Issues\r\n\r\nso not \"just\" one of top-voted Mostly Wanted features but also considered a significant design/implementation concern.\r\n\n\nComment by JooHyukKim:\nPhew, that was alot of work \ud83d\ude06 Hopefully, it won't be too hard merging into master.\r\nThank you for your help! @cowtowncoder\r\n\r\n\n\nComment by cowtowncoder:\n@JooHyukKim thank you for actually implementing it & going through all tiny things I wanted changed :)\r\n\r\nSurprisingly merge to master was quite straight-forward this time around.\r\n\r\nAnd with this, we are getting somewhat close to 2.18.0 minimum feature set, as far as I care.\r\nI do want this performance optimization: https://github.com/FasterXML/jackson-core/issues/1284 for streaming but otherwise not many must-haves.\r\n\r\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Allow `@JsonAnySetter` on Creators",
                "name": "pr#4558",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4508"
                    },
                    {
                        "start_node": "issue#4508",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4558"
                    }
                ],
                "similarity": 0.23142766059649905,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4119",
                "type": "issue",
                "content": "### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\r\n\r\n### Describe the bug\r\n\r\nWhen deserialization uses a record with a constructor property with `access=READ_ONLY`, the following exception is thrown:\r\n\r\n```\r\nCaused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type `com.company.common.vo.RuleVO`: Argument #1 of constructor [constructor for `com.company.common.vo.RuleVO` (4 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n at [Source: (BufferedReader); line: 1, column: 1]\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:62)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadTypeDefinition(DeserializationContext.java:1893)\r\n\tat com.fasterxml.jackson.databind.deser.BasicDeserializerFactory._addImplicitConstructorCreators(BasicDeserializerFactory.java:602)\r\n\tat com.fasterxml.jackson.databind.deser.BasicDeserializerFactory._constructDefaultValueInstantiator(BasicDeserializerFactory.java:301)\r\n\tat com.fasterxml.jackson.databind.deser.BasicDeserializerFactory.findValueInstantiator(BasicDeserializerFactory.java:222)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:262)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:151)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:415)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:350)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:621)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:188)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:28)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleSecondaryContextualization(DeserializationContext.java:867)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:659)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4956)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4826)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3801)\r\n\r\n```\r\n\r\nA sample record is provided bellow.\r\n\r\n### Version Information\r\n\r\n2.15.2\r\n\r\n### Reproduction\r\n\r\nSample record with the issue: \r\n\r\n```java\r\npublic record RuleVO(\r\n  @JsonIgnore\r\n  Integer id,\r\n\r\n  @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n  Integer order,\r\n\r\n  @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n  String name,\r\n\r\n  String description,\r\n) {}\r\n```\r\n\r\nIf I remove the `JsonProperty.Access.READ_ONLY` from order field, a new exception is thrown indicating the argument with the issue is `...: Argument #2 of constructor [constructor for...`, that is, the other field with READ_ONLY.\r\n\r\nThe object mapper is:\r\n\r\n```java\r\n  public static ObjectMapper customObjectMapper() {\r\n    return JsonMapper.builder()\r\n      .addModule(new JavaTimeModule())\r\n      .disable(MapperFeature.DEFAULT_VIEW_INCLUSION)\r\n      .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\r\n      .build();\r\n  }\r\n```\r\nI also tried with a plain object mapper `JsonMapper.builder().build()` without customizations and the error is still there.\r\n\r\n### Expected behavior\r\n\r\nIn 2.14.3, it works perfectly.\r\n\r\n### Additional context\r\n\r\nI have tested the application with 2.15.3-SNAPSHOT and 2.16.0-SNAPSHOT and the error is thrown too.\n\n\nComment by yawkat:\nyou probably need to define the name explicitly if you use `@JsonProperty`.\n\nComment by soc:\nOne of the benefits of `record` is that you have first-class support for getting the names (`Class#getRecordComponents`), so losing that feels kinda wrong.\n\nComment by yawkat:\noh duh, the issue is much more simple. since you define the property as READ_ONLY, it can't be deserialized. the error could be better but there is no functional change needed here imo.\n\nComment by Mochis:\nI tried to put a name explicitly, but didn't work. \r\n\r\n> since you define the property as READ_ONLY, it can't be deserialized\r\n\r\nBefore 2.15.x the result of deserialize or ignoring on deserialization a field with `access=READ_ONLY` was a null value, I don't understand why it should change to an exception.\r\n\r\nFor me this is a regression because with the previous version 2.14.3 it works, the change to 2.15.x is not a major change according semver and this is not compatible with previous versions if it was intended.\n\nComment by yawkat:\nI would not call it a regression, I would call it finally having the right behavior :)\r\n\r\nAIUI, the record implementation changed a lot 2.14->2.15. It now uses most of the existing bean infrastructure instead of its own special handling. That means aspects that were previously not implemented for records, now are. \r\n\r\nBut once again this is @cowtowncoder's call.\n\nComment by Mochis:\nThank you @yawkat for the explanation. \r\n\r\nI'm curious about your reasoning, how would you use the READ_ONLY property instead, only to throw an exception when the JSON input contains a field marked with it? \r\n\r\nMy use case is to use the same value object class to serialize and deserialize, but I want to ignore some JSON fields when deserializing, that's the reason why READ_ONLY is useful in my understanding.\n\nComment by cowtowncoder:\nHmmh. Semantics of `READ_ONLY` predate introduction of Records, and with POJOs things are bit simpler.\r\nBut I think that it is reasonable to expect Record to work same as a POJO with constrictor regarding this case. I am not 100% sure what that behavior is.\r\n\r\nBut I agree that at very least exception thrown is not good.\r\nSo I think there is a valid issue here. If anyone has time to see how POJO would behave, that'd be useful information.\r\n\n\nComment by yawkat:\nnormal beans behave the same way. this constructor:\r\n\r\n```java\r\n        @JsonCreator\r\n        public Bean(@JsonProperty(\"foo\") String foo, @JsonProperty(value = \"bar\", access = JsonProperty.Access.READ_ONLY) String bar) {\r\n```\r\n\r\nfails with\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type `com.fasterxml.jackson.databind.records.RecordImplicitName4119Test$Bean`: Argument #1 of constructor [constructor for `com.fasterxml.jackson.databind.records.RecordImplicitName4119Test$Bean` (2 args), annotations: {interface com.fasterxml.jackson.annotation.JsonCreator=@com.fasterxml.jackson.annotation.JsonCreator(mode=DEFAULT)} has no property name (and is not Injectable): can not use as property-based Creator\r\n at [Source: (String)\"{\"foo\":\"fizz\",\"bar\":\"buzz\"}\"; line: 1, column: 1]\r\n```\n\nComment by cowtowncoder:\nOk. So at least we know handling is the same. Questions would then be:\r\n\r\n1. Should READ_ONLY setting work via constructor -- and if so, would a `null` be passed?\r\n2. If failure should occur (this use case not allowed), how to improve exception message.\r\n\n\nComment by yawkat:\nimo it should still throw an exception, just a better one.\n\nComment by Mochis:\nThe `access` property is documented in this way in `JsonProperty` class:\r\n\r\n    /**\r\n     * Optional property that may be used to change the way visibility of\r\n     * accessors (getter, field-as-getter) and mutators (constructor parameter,\r\n     * setter, field-as-setter) is determined, either so that otherwise\r\n     * non-visible accessors (like private getters) may be used; or that\r\n     * otherwise visible accessors are ignored.\r\n     *<p>\r\n     * Default value os {@link Access#AUTO} which means that access is determined\r\n     * solely based on visibility and other annotations.\r\n     *\r\n     * @since 2.6\r\n     */\r\n    Access access() default Access.AUTO;\r\n\r\n> Optional property that may be used to change the way visibility of accessors (...) and mutators (constructor parameter, ...) is determined\r\n\r\nSo, should READ_ONLY be an exception to this statement?\n\nComment by yawkat:\nin my opinion, the docs read like mutators (including creators) that mutate READ_ONLY properties will not be called. and this leads to the exception you see.\n\nComment by Mochis:\nI have been debugging and the exception happens before the data to be parsed is known.\r\n\r\nIt is my first time inspecting the internals of jackson code, so I could probably be wrong, but when I call a method which need to deserialize a JSON data into a Java object the first action is try to get from the cache a proper deserializer for that VO or create it.\r\n\r\nThis exception happens during deserializer creation if a constructor argument contains a property like READ_ONLY no matters what the data input is.\n\nComment by yawkat:\nYes, it is not possible for jackson to deserialize an object if the creator/constructor would have to set a READ_ONLY property. That is reasonable behavior, it's just the error message that is awful.\n\nComment by saugion:\nAfter upgrading to 2.15 most of my records are broken, I used READ_ONLY a lot \ud83e\udd72\r\nWhich fix do you suggest?\n\nComment by cowtowncoder:\n@saulgiordani Please no piling on existing issues unless you have the same problem. Sounds like yours is different so please file a new issue with details.\n\nComment by saugion:\n@cowtowncoder Sorry, I receive the same exception using the Lombok builder. Something that didn't happen before upgrading. As the exception Is exclty the same I guessed this was the right thread. \n\nComment by cowtowncoder:\n@saulgiordani But you specifically said\r\n\r\n    I used write_only a lot\r\n\r\nand here issue is about `READ_ONLY`. Unless you meant \"I use READ_ONLY a lot\"?\r\n\r\nBe that as it may, if you are hitting the same problem then you need to stop using `READ_ONLY` as it cannot work when using Constructor for deserialization, as per @yawkat.\r\nRegardless of behavior in 2.14.x it will not be made to work in 2.15 or later as looking at semantics of `READ_ONLY` annotation it should not work; it not being reported as an error seems erroneous behavior in itself.\r\n\n\nComment by saugion:\nI'm sorry @cowtowncoder it was my mistake. Will edit the message!\n\nComment by Mochis:\nI understand that the error message is not the best one, but taking into account that versions < 2.14.x were working with READ_ONLY with much probability a lot of apps will break with 2.15.x, so what is the alternative to use READ_ONLY or something similar in records to not deserialize some fields? \n\nComment by cowtowncoder:\nDeciding factor is whether it SHOULD HAVE worked in a way it did -- or was that a bug wrt semantics. Just because earlier version behaves in certain way does not automatically mean it was how it should have. Even in cases where users found that behavior useful.\r\nIt is of course very unfortunate if this is the case -- what seems like useful Feature is seen by maintainers as a bug.\r\n\r\nAs to \"a lot of apps\", that is hard to estimate. I do not know, but I am bit surprised if it turns out `READ_ONLY` option is widely used. There have been some bug reports but I never it was a commonly used feature, fwtw.\r\nAnd we do not really have any usage metrics to check: rate of bug reports is not a strong indicator either.\r\n\r\nBut as to alternatives, plain `@JsonIgnore` on argument could work, but probably requires an explicit getter with `@JsonProperty` annotation.\r\n\r\nAnother, similarly awkward possibility would be to add a bogus setter that does nothing: it'd get called but value would be ignored. That setter might require `@JsonProperty` (or `@JsonSetter`).\r\n\r\nOr, come to think of it, an explicit constructor that calls `super()` with same arguments but not passing read-only argument?\r\n\r\nWriting all of this, I am starting to think maybe we should allow `READ_ONLY` to mean \"partial ignore\", given how awkward work-arounds are for Record types.\r\n\r\nSo I would consider PR to support it.\r\n\r\n\n\nComment by cowtowncoder:\nOk, looking at test for issue #1890 (`com.fasterxml.jackson.databind.deser.filter.ReadOnlyDeser1890Test`), it appears we do accept such case, passing `null` instead of value. I wonder if this is accidental wrt annotations from `Field` not being merged with those for Creator parameters. But regardless, I think the behavior to support would indeed be not to fail but to pass `null` (and with possibly value defaulting wrt null setting (SKIP and IGNORE not doing anything, but EMPTY providing empty value).\r\n \r\nAlso: as per earlier comments, not specific to Records: works the same way for regular POJOs (as of 2.16.1)\r\n\n\nComment by cowtowncoder:\nTwo places that seem relevant.\r\n\r\nFirst, in `POJOPropertyBuilder` (where details of a single logical property are combined for `POJOPropertiesCollector`), method `removeNonVisible` (line 942) has:\r\n\r\n```\r\n      switch (acc) {\r\n        case READ_ONLY:\r\n            ...\r\n            // Remove setters, creators for sure, but fields too if deserializing\r\n            _setters = null;\r\n            _ctorParameters = null;\r\n```\r\n\r\nwhich is where information will be dropped. Commenting this out will fail 2 tests for #1890 (where we retain property).\r\nIt would also pass actual value through to Constructor instead of `null`.\r\n\r\nSecond potential place would be in `BeanDeserializer` method `_deserializeUsingPropertyBased` (line 414 or so) where actual deserialization occurs -- if we do not creator property we get here and could potentially ignore value. Maybe.\r\n\r\n\n\nComment by cowtowncoder:\nLooks like this was working with 3.0 (`master`), fwtw.\r\n\r\n\n\nComment by cowtowncoder:\nFixed via #4515, will be in 2.18(.0).\r\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Exception when deserialization uses a record with a constructor property with `access=READ_ONLY`",
                "name": "issue#4119",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    }
                ],
                "similarity": 0.2291141971712959,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3988",
                "type": "issue",
                "content": "**Describe the bug**\r\n\r\nThe exception thrown for an incorrectly annotated record has changed.\r\n\r\n**Version information**\r\n2.15.2\r\n\r\n**To Reproduce**\r\n\r\nConsider these two examples:\r\n\r\n```\r\npublic record RecordWithSingleValueValue(@JsonValue String value) {}\r\n\r\npublic record RecordWithSingleValueCreatorDelegating(String value) {\r\n\r\n  @JsonCreator(mode = JsonCreator.Mode.DELEGATING)\r\n  public RecordWithSingleValueCreatorDelegating {}\r\n\r\n}\r\n\r\npublic class JacksonSerializationTest {\r\n\r\n  private static final ObjectMapper mapper = new ObjectMapper();\r\n\r\n  @Test\r\n  public void recordWithSingleValueValue() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueValue(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"\\\"foo\\\"\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, RecordWithSingleValue.class));\r\n  }\r\n\r\n  @Test\r\n  public void recordWithSingleValueCreatorDelegating() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueCreatorDelegating(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, RecordWithSingleValueCreatorDelegating.class));\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nIn 2.14.2 `InvalidDefinitionException` was thrown as shown above, with 2.15.3 this changed to `MismatchedInputException`.\r\nFrom my understanding `InvalidDefinitionException` was perhaps more \"correct\"?\r\n\r\n**Additional context**\r\nI tried to figure out whether this change was intentional or not, but couldn't find anything in the changelog or issues.\r\nI just wanted to let you know of this change \u2013 apologies if this was intentional and I missed it.\r\n\r\n(I also found some other behavioral changes in 2.15, but I assume they are intentional \u2013 things that weren't deserializing before are now deserializing.)\n\n\nComment by yihtserns:\nLooking at the javadoc:\r\n- `InvalidDefinitionException`: Something is wrong with the class to deserialize into.\r\n- `MismatchedInputException`: The wrong input has been provided.\r\n\r\nThe scenario is providing JSON String to a class that expects JSON Object, and providing JSON Object to a class that expects a JSON String.  Isn't that \"the wrong input has been provided\"? \n\nComment by yihtserns:\n>...things that weren't deserializing before are now deserializing.\r\n\r\nWhat's the scenarios for those? \n\nComment by soc:\n>  Isn't that \"the wrong input has been provided\"?\r\n\r\nGood point! Perhaps my confusion comes from things changing for `record`, but not for `class`. :thinking:\r\n(I basically have a small test suite that tests all possible combinations of Jackson annotations.)\n\nComment by soc:\nOoops, wait a minute, I copied the wrong record definitions above.\r\n\r\nEdit: Fixed, apologies. Both `records` in the original post were the wrong ones for the tests I showed.\n\nComment by soc:\n> What's the scenarios for those?\r\n\r\n```\r\npublic record RecordWithSingleValue(String value) {}\r\n\r\npublic record RecordWithSingleValueCreatorProperties(String value) {\r\n\r\n  @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\r\n  public RecordWithSingleValueCreatorProperties {}\r\n\r\n}\r\n```\r\n\r\nnow both round-trip, they failed with `InvalidDefinitionException` on 2.14.\r\n\r\n\n\nComment by yihtserns:\nI think you need to double check your scenarios, because when I tried using `2.14.0`:\r\n\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>recordWithSingleValueValue</th>\r\n<th>recordWithSingleValueCreatorDelegating</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>Failed with:\r\n<blockquote>\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Problem with definition of [AnnotedClass com.github.yihtserns.records.jackson.RecordWithSingleValueValue]: Multiple 'as-value' properties defined ([field com.github.yihtserns.records.jackson.RecordWithSingleValueValue#value] vs [method com.github.yihtserns.records.jackson.RecordWithSingleValueValue#value()])\r\n</blockquote>\r\nat:\r\n<pre>\r\n@Test\r\npublic void recordWithSingleValueValue() throws JsonProcessingException {\r\n    var instance = new RecordWithSingleValueValue(\"foo\");\r\n    var result = mapper.writeValueAsString(instance); <---- failed here\r\n    ...\r\n}\r\n</pre>\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n---\r\n> ```\r\n> public record RecordWithSingleValue(String value) {}\r\n> \r\n> public record RecordWithSingleValueCreatorProperties(String value) {\r\n>   @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\r\n>   public RecordWithSingleValueCreatorProperties {}\r\n> }\r\n> ```\r\n> now both round-trip, they failed with InvalidDefinitionException on 2.14.\r\n\r\nSorry I don't understand what that means, you'd have to explain more than that...  \ud83d\ude1e \n\nComment by soc:\n> I think you need to double check your scenarios, because when I tried using 2.14.0\r\n\r\n@yihtserns Did you see my edit regarding the class definitions above?\r\nPreviously I ran on 2.14.2, so perhaps your 2.14.0 does things differently?\r\n\r\n> Sorry I don't understand what that means, you'd have to explain more than that... disappointed\r\n\r\nEach of the examples can deserialize the value it serialized.\r\n\r\n---\r\n\r\nI'm reverting the whole thing, just got another failure about\r\n\r\n> Invalid type definition for type `...Dto`: Argument #5 of constructor [constructor for `...Dto` (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\nfor a record that is not annotated with `@JsonCreator`, and also has no property name annotations for args #1-#4 or #6 either.\n\nComment by yihtserns:\n<table>\r\n<thead>\r\n<tr>\r\n<th>Version \u2b07\ufe0f</th>\r\n<th>recordWithSingleValueValue</th>\r\n<th>recordWithSingleValueCreatorDelegating</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<th>2.14.2</th>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n<tr></tr>\r\n<tr>\r\n<th>2.15.3-SNAPSHOT</th>\r\n<td>\r\nSuccessfully deserializes because of new feature #3654 (+#3724).\r\n</td>\r\n<td>\r\n<pre>\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class com.fasterxml.jackson.databind.exc.InvalidDefinitionException\r\nActual   :class com.fasterxml.jackson.databind.exc.MismatchedInputException\r\n</pre>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\nI see there's no change for `recordWithSingleValueCreatorDelegating` between `2.14.2` & `2.15.3-SNAPSHOT` (**NOTE**: `2.15.3` is not released yet): they're both throwing `MismatchedInputException` in my machine.  \ud83e\udd14 \n\nComment by yihtserns:\n> I'm reverting the whole thing, just got another failure about\r\n>> Invalid type definition for type ...Dto: Argument https://github.com/FasterXML/jackson-databind/pull/5 of constructor [constructor for ...Dto (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n>\r\n> for a record that is not annotated with @JsonCreator, and also has no property name annotations for args https://github.com/FasterXML/jackson-databind/issues/1-https://github.com/FasterXML/jackson-databind/pull/4 or https://github.com/FasterXML/jackson-databind/pull/6 either.\r\n\r\nWithout direct access to your machine, it's basically impossible to know what you're talking about.  Maybe you can create a Github repository with all the (failing) test cases to describe the issue - that's the most effective way for us to be \"in-sync\" with each other.\n\nComment by cowtowncoder:\nI would suggest actually addressing a small number -- possibly just one -- fail at a time and not bundling together all cases.\r\n\r\nBut aside from that, the general idea would be that:\r\n\r\n1. Things that are wrong with definition -- regardless of input; that is, occurring during construction/initialization of deserializer -- should results in `InvalidDefinitionException`\r\n2. Things that could work (value/deserializer annotations valid) but do not work for encountered input should result in exceptions like `MismatchedInputException`\r\n\r\nWhether change in specific case is intentional, valid, or invalid depends on many things of course. Above is just the general guidance.\r\nWe try not to change exception types unless there was an incorrect one before; exceptions thrown are considered part of API definition. One exception to this (no pun intended) is that sometimes we may start using a more specific one (new subtype).\r\n\r\n\n\nComment by soc:\nIt appears as if Jackson behaves wildly different with and without a Java module-info file, even on 2.14.2.\r\nI believe this should not be the case.\r\n\r\n2.14.2 with module-info:\r\n![jackson-2 14 2-with-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/b254a44d-02b5-48ba-ba90-fa66da3c771b)\r\n\r\n\r\n2.14.2 without module-info:\r\n![jackson-2 14 2-without-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/38bb8b13-61ca-42a9-a021-b2acce2ef80f)\r\n\r\n\r\n2.15.2 with module-info:\r\n![jackson-2 15 2-with-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/575397e9-a1eb-4802-ad4f-e720b310cbce)\r\n\r\n2.15.2 without module-info:\r\n![jackson-2 15 2-without-module-info](https://github.com/FasterXML/jackson-databind/assets/42493/d0e86164-ebbf-4de8-936b-8c3b261792da)\r\n\r\nI'm not sure it makes sense to look at the behavioral changes between 2.14 and 2.15, if using the Java module system makes the results diverge that much.\r\n\r\nReproduction: https://github.com/soc/jackson-repro\n\nComment by soc:\nI added the reproduction for\r\n\r\n> Invalid type definition for type ...Dto: Argument https://github.com/FasterXML/jackson-databind/pull/5 of constructor [constructor for ...Dto (6 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\nin a second commit in the same repo.\n\nComment by yihtserns:\n@soc can you also commit a [Maven wrapper](https://maven.apache.org/wrapper/) into your repo, please?  Just want to ensure our environmental settings are close enough:\r\n\r\n- Running `mvn test` ignores all the test methods, I had to specifically specify a newer `maven-surefire-plugin` - this is likely because my personal Maven installation uses an older `maven-surefire-plugin` by default.\r\n- When I run `JacksonSerializationTest` directly in Intellij, the result WITH `module-info` is the same as your result for WITHOUT `module-info`:\r\n![image](https://github.com/FasterXML/jackson-databind/assets/3615932/7cfcf8d2-9ead-4d33-a7bc-b2eae4bfec26)\n\nComment by yihtserns:\nFor these test cases in `JacksonSerializationTest`:\r\n- `recordWithSingleValueCreatorProperties`\r\n- `recordWithSingleValue`\r\n- `recordWithSingleValueValue`\r\n- `recordWithSingleValueCreatorDelegating`\r\n\r\n...in 2.14.2 they failed with:\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type \\`<...snip>\\`: Failed to call \\`setAccess()\\` on Field '<...snip>' (of class \\`<...snip>\\`) due to \\`java.lang.reflect.InaccessibleObjectException\\`, problem: Unable to make field private final java.lang.String <...snip> accessible: module repro does not \"opens repro\" to module com.fasterxml.jackson.databind\r\n\r\nThat `InvalidDefinitionException` was a bug that has been fixed by #3352.  Which is why:\r\n- `recordWithSingleValueCreatorProperties`: can now deserialize the valid JSON\r\n- `recordWithSingleValue`: can now deserialize the valid JSON\r\n- `recordWithSingleValueValue`: can now fail with \"mismatched input\" error for the invalid JSON\r\n- `recordWithSingleValueCreatorDelegating`: can now fail with \"mismatched input\" error for the invalid JSON\r\n\r\n---\r\nAs for `JacksonSerialization2Test` failing with:\r\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type \\`repro2.RecordWithMultipleValuesAndOnePropertyAccessAnnotationDto\\`: Argument \\#&#8203;1 of constructor [constructor for \\`repro2.RecordWithMultipleValuesAndOnePropertyAccessAnnotationDto\\` (2 args), annotations: [null] has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\r\n\r\n...that is caused by #3724 not covering the scenario where deserialization uses a Record with a constructor property with `access=READ_ONLY` .\n\nComment by soc:\nOk, thanks! Then I'll wait for 2.15.3 and report back!\n\nComment by cowtowncoder:\nThis is too convoluted an issue, discussion, to be of much value (IMO), so I'll close it. Relevant, remaining pieces may be re-filed (with possible ref to this one), with clear explanation of intended correct outcome, and not so much on what has changed -- some changes are fine (fixes), others not: but it's perfectly fine to suggest that specific change is wrong (bug/regression). There is no need to ask \"why was this changed\" if change seems wrong: but there is clear need to clearly indicate both type of exception and message being reported -- latter likely explains how change came about (new validation, regression).\r\n\r\n\n\nComment by Mochis:\nI have some doubts, is the problem related to constructor property with access=READ_ONLY resolved in 2.15.3 or 2.16?\r\n\r\n> ...that is caused by https://github.com/FasterXML/jackson-databind/pull/3724 not covering the scenario where deserialization uses a Record with a constructor property with access=READ_ONLY .\n\nComment by cowtowncoder:\n@Mochis Read my note above. If you have remaining problem case that is not covered by an open issue, please file a new, targeted issue for specific problem.\n\nComment by Mochis:\nThank you @cowtowncoder. Reported here https://github.com/FasterXML/jackson-databind/issues/4119\n\nComment by soc:\nShort update: After I reported this issue, I adapted the test to the behavior on 2.15.2.\r\n\r\nNow, with the same Jackson version (2.15.2), but updated Java version (to 21) I get similar failures for classes as previously for records:\r\n\r\n```\r\nFailures: \r\n  JacksonSerializationTest.classWithSingleValueCreatorDelegating:31 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueCreatorDelegatingProperty:41 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueCreatorPropertiesProperty:61 Expected com.fasterxml.jackson.databind.exc.InvalidDefinitionException to be thrown, but nothing was thrown.\r\n  JacksonSerializationTest.classWithSingleValueGetConstructor:71 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n  JacksonSerializationTest.classWithSingleValueProperty:90 Unexpected exception type thrown, expected: <com.fasterxml.jackson.databind.exc.InvalidDefinitionException> but was: <com.fasterxml.jackson.databind.exc.MismatchedInputException>\r\n```\r\n\n\nComment by soc:\nJust checked with 2.16.0 and Java 21:\r\n\r\nExample `JacksonSerializationTest.classWithSingleValueProperty`:\r\n\r\n```\r\n  @Test\r\n  public void classWithSingleValueProperty() throws JsonProcessingException {\r\n    var instance = new ClassWithSingleValueProperty(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(result, ClassWithSingleValueProperty.class));\r\n  }\r\n```\r\n\r\n- Test green when running the test from the IDE.\r\n- Error message when running `mvn` from the CLI:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `ClassWithSingleValueProperty` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\r\n```\r\n\r\nIf I adjust the example to\r\n\r\n```\r\n  @Test\r\n  public void classWithSingleValueProperty() throws JsonProcessingException {\r\n    var instance = new ClassWithSingleValueProperty(\"foo\");\r\n    var result = mapper.writeValueAsString(instance);\r\n    assertEquals(\"{\\\"value\\\":\\\"foo\\\"}\", result);\r\n    // missing setter\r\n    assertThrows(InvalidDefinitionException.class,\r\n        () -> mapper.readValue(\"\\\"foo\\\"\", ClassWithSingleValueProperty.class));\r\n  }\r\n```\r\n\r\n- Test green when running the test from the IDE.\r\n- Error message when running `mvn` from the CLI (this is expected):\r\n```\r\nExpected com.fasterxml.jackson.databind.exc.InvalidDefinitionException to be thrown, but nothing was thrown\r\n```\n\nComment by JooHyukKim:\n> Test green when running the test from the IDE.\r\n> Error message when running mvn from the CLI:\r\n\r\nWhat is version IDE is configured with? @soc \r\nAlso, could you check mvn version? (stdout will have jdk version) \r\n\r\nAsking this because IDE, mvn usually not the problem but the JDK version they load. \n\nComment by cowtowncoder:\nThis is closed issue, fwtw.",
                "source_code": null,
                "distance": 1.0,
                "title": "Exception thrown for incorrectly annotated record changed from `InvalidDefinitionException` to `MismatchedInputException`",
                "name": "issue#3988",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    },
                    {
                        "start_node": "issue#4119",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3988"
                    }
                ],
                "similarity": 0.22544995207429977,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "72",
                "type": "issue",
                "content": "JAXB annotations have concept of wrapper name, which is typically used as extra container name for indexed properties (arrays, Lists). With Jackson 1.x this name was also used for renaming JSON properties; but with 2.0 this was removed (to allow for proper implementation of XML lists etc -- automatic renaming was conflicting with other features).\n\nBut it would be useful to allow use of wrapper name annotations (JAXB, or one Jackson XML module adds, `@JacksonXmlElementWraper`) for property renaming. To this end, we should add a feature like:\n\n  MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME\n\nwhich would allow using Jackson 1.x style handling; but default would be 'false' (i.e. no renaming).\n\n\n\nComment by cowtowncoder:\nImplemented.\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Add `MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME` to force use of wrapper name",
                "name": "issue#72",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#806"
                    },
                    {
                        "start_node": "issue#806",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#72"
                    }
                ],
                "similarity": 0.2232060946900321,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1920",
                "type": "issue",
                "content": "Hi,Is there a way for supporting $id , $ref and $values in jackson deserializing component?\n\n\nComment by cowtowncoder:\nPlease ask usage questions on mailing list in future:\r\n\r\nhttps://groups.google.com/group/jackson-user/\r\n\r\nBut guessing at what you are trying to ask I think what you want is `@JsonProperty` annotation to indicate name to use in JSON, to match to property in Java class.\r\n\r\n",
                "source_code": null,
                "distance": 1.0,
                "title": "supporting for $id , $ref and $values?",
                "name": "issue#1920",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4508"
                    },
                    {
                        "start_node": "issue#4508",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1920"
                    }
                ],
                "similarity": 0.21435697405872828,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3102",
                "type": "issue",
                "content": "**Describe the bug**\r\nJsonNaming does not seem to be applied to Java 16 record types for deserialization.\r\n\r\n**Version information**\r\n2.12.2\r\n\r\n**To Reproduce**\r\nSimple unit test:\r\n```java\r\npublic class RecordTest\r\n{\r\n    @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)\r\n    public record TestRecord(int id, String toSnakeCase) {}\r\n\r\n    @Test\r\n    public void testSerializeJsonTestRecord()\r\n            throws JsonProcessingException\r\n    {\r\n        JsonMapper jsonMapper = new JsonMapper();\r\n\r\n        TestRecord expectedRecord = new TestRecord(123, \"Bob\");\r\n\r\n        String actualJson = jsonMapper.writeValueAsString(expectedRecord);\r\n        assertEquals(\"{\\\"id\\\":123,\\\"to_snake_case\\\":\\\"Bob\\\"}\", actualJson);\r\n\r\n        TestRecord actualValue = jsonMapper.readValue(\"{\\\"id\\\":123,\\\"to_snake_case\\\":\\\"Bob\\\"}\", TestRecord.class);\r\n        assertEquals(new TestRecord(123, \"Bob\"), actualValue);\r\n    }\r\n}\r\n```\r\n\r\nFailure stack:\r\n```\r\n\r\ncom.fasterxml.jackson.databind.JsonMappingException: Can not set final java.lang.String field io.starburst.stargate.portal.security.client.RecordTest$TestRecord.toSnakeCase to java.lang.String\r\n\r\n\tat com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:274)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:623)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:611)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:634)\r\n\tat com.fasterxml.jackson.databind.deser.impl.FieldProperty.set(FieldProperty.java:193)\r\n\tat com.fasterxml.jackson.databind.deser.impl.PropertyValue$Regular.assign(PropertyValue.java:62)\r\n\tat com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator.build(PropertyBasedCreator.java:211)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:520)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1405)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:362)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:195)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:322)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4593)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3548)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3516)\r\n\tat io.starburst.stargate.portal.security.client.RecordTest.testSerializeJsonTestRecord(RecordTest.java:29)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:567)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:125)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:132)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:124)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:74)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:104)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:62)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:43)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:35)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:202)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:198)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)\r\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71)\r\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\r\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:221)\r\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)\r\nCaused by: java.lang.IllegalAccessException: Can not set final java.lang.String field io.starburst.stargate.portal.security.client.RecordTest$TestRecord.toSnakeCase to java.lang.String\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76)\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80)\r\n\tat java.base/jdk.internal.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:79)\r\n\tat java.base/java.lang.reflect.Field.set(Field.java:793)\r\n\tat com.fasterxml.jackson.databind.deser.impl.FieldProperty.set(FieldProperty.java:190)\r\n\t... 74 more\r\n```\n\n\nComment by cowtowncoder:\nYes, alas, I think this is same as #2992 (and probably #2974). The problem is that linking of constructor properties is failing for some reason and so only mutator attached to underlying `Field` gets properly renamed.\r\n\r\nI plan on finally tackling bigger property introspection change for 2.13 (to solve the root cause), although if someone can figure out a patch for 2.12.x (with more targeted fix) that would be great too.\r\n\n\nComment by dain:\nI tried following the code in a debugger, and I saw the record constructor being processed and registered, with the raw record field names (the constructor parameter names).  It looked like it was just missing the processing of the rename strategy.  I couldn't follow the rest of the code, but it appears that  it also registers the \"renamed\" the raw private fields inside the record class.  Then during deserialization, it sees a snake case field, and since the constructor parameters aren't processed, it tries to set the field directly, which fails.\n\nComment by cowtowncoder:\nCorrect. The problem is due to Creator methods (and properties that are found via them) are handled separately due to historical reasons. If I remember this correctly if (but only if) constructor is explicitly annotated with `@JsonCreator`, its parameters will be added early enough to be accessible for renaming purposes.\r\n\r\nSo I think one work around, until fix, would be to add explicit, otherwise unnecessary declaration of Record constructor.\r\n\r\nI guess if above is correct, then a smaller fix within Jackson 2.12 would be to indicate that the main Record constructor was explicitly annotated -- one reason this wasn't done is because of possibility that user might designate an alternate constructor. But maybe it'd be possible to detect the case of no explicit annotations.\r\n\n\nComment by dain:\nI tried adding an explicit constructor with `@JsonCreator` and that doesn't work (same error).  Think the issue it the new special method to discover the record constructor.  Maybe it messes up the explicit constructor.\r\n\r\nThe only workaround I could find was the obvjous to declare the property mapping manually:\r\n```\r\npublic record TestRecord(int id, @JsonProperty(\"to_snake_case\") String toSnakeCase) {}\r\n```\n\nComment by cowtowncoder:\nHmmh. Ok, I better add a new test for this fail, just in case. Explicit `@JsonCreator` should connect things.\n\nComment by cowtowncoder:\nYes, I can reproduce the issue. Also odd: exception message claims there are no known properties -- I get bit different one with JDK 14, will need to install JDK 16 to see if I can reproduce exception shown here.\n\nComment by cowtowncoder:\nOk. The odd \"0 properties\" was due to local changes (wrt attempt to prevent use of setters which has side effect of dropping properties); after removing that, I can reproduce the issue with JDK 16. `@JsonCreator` has no effect.\r\n\r\nI think I must have misremembered the logic: it must be that explicit naming of constructor properties is the only thing that establishes links, not constructor annotation itself. And obviously having to use that prevents any benefit of applying naming convention.\r\n\n\nComment by cowtowncoder:\nOdd. Trying to add a reproduction with regular POJO, it looks like combination of `@JsonCreator` and implicit names (from `jackson-module-parameter-names`) actually works. That is... unexpected.\r\n\r\nI think this is because Record handling short-circuits otherwise default implicit-name access (since we know how to access them more reliably). So it might be possible to inject implicit names. That would solve this particular issue, although would not help the main use case (of not requiring bogus constructor to add `@JsonCreator` to). But would perhaps be doable for 2.12.x.\r\n\r\n\n\nComment by spinscale:\nI just ran into this without using any annotations, by configuring the jackson mapper like this (suppose this is well known as the annotation is doing the same, but I figured I'll leave the test case here):\r\n\r\n```java\r\n    @Test\r\n    public void testSerializeDeserializeSnakeCaseRecord() throws JsonProcessingException {\r\n        final ObjectMapper mapper = new ObjectMapper()\r\n                .setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\r\n\r\n        User user = new User(\"Obama\", \"Barack\");\r\n\r\n        // serialization\r\n        final String output = mapper.writeValueAsString(user);\r\n        assertThat(output).contains(\"\\\"name\\\":\\\"Obama\\\"\");\r\n        assertThat(output).contains(\"\\\"first_name\\\":\\\"Barack\\\"\");\r\n\r\n        // deserialization\r\n        final User readUser = mapper.readValue(output, User.class);\r\n        assertThat(readUser.firstName()).isEqualTo(\"Barack\");\r\n        assertThat(readUser.name()).isEqualTo(\"Obama\");\r\n    }\r\n\r\n    public static record User(String name, /*@JsonProperty(\"first_name\")*/ String firstName) {\r\n    }\r\n```\r\n\r\nWorks fine, when using the `@JsonProperty` in the record, so a safe workaround.\n\nComment by pjfanning:\n@cowtowncoder would it be possible to consider the change in https://github.com/FasterXML/jackson-future-ideas/issues/61#issuecomment-1197029822 for v2.14?\n\nComment by cowtowncoder:\n@pjfanning Yes. I haven't had time to follow on those ideas but yes I'd be +1 for inclusion.\n\nComment by pjfanning:\nI think it might be possible to sort out the issue with Record deserialization when naming strategies are involved by treating Records as a special case and changing it so that the properties are evaluated before the Record constructor is called. When  there are no naming strategies, this already happens. When there is a naming strategy, the Record is constructed with null values and the code tries to use setters after the fact to set the right values (and refelction doesn't allow this for Records).\r\n\n\nComment by cowtowncoder:\n@pjfanning At the high level, yes. Records should be handled in (more) special way. But aside from logics there is an existing problem wherein Creator properties (constructor detection) and \"regular\" property detection are done in somewhat wrong order and that is the big thing I hope to rewrite. Smaller tweaks to the existing implementation are much more complicated unfortunately; but rewrite is not a trivial task either.\r\n\r\nRenaming, in particular, was (if I remember correctly) victim of Creator not being found and linked early enough to have the logical creator properties be renamed; thereby only leaving Field-based property accessors in use (unliked with wrongly named creator properties).\r\n\n\nComment by agentgt:\nHopefully this is related and might be helpful to others.\r\n\r\nThey only way I can reliably get records to work is by turning off all Auto Detection (`@JsonAutoDetect`) and manually doing the `@JsonProperty` for each component.\r\n\r\nLuckily you can make combined annotations that will turn off the auto detection.\r\n\r\n```\r\n@Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@JacksonAnnotationsInside\r\n@JsonAutoDetect(//\r\n\t\tgetterVisibility = JsonAutoDetect.Visibility.NONE, //\r\n\t\tisGetterVisibility = JsonAutoDetect.Visibility.NONE, //\r\n\t\tsetterVisibility = JsonAutoDetect.Visibility.NONE, //\r\n\t\tfieldVisibility = JsonAutoDetect.Visibility.NONE)\r\n@JsonInclude(Include.NON_DEFAULT)\r\npublic @interface MyJsonRecord {\r\n\r\n}\r\n```\r\n\r\nReally you just have to turn off `getterVisibility`. The problem with getterVisibility turned on is if your record implements interfaces and you have methods with the same getter name as an accessor (e.g. `name()` and `getName()` ) there is no way to ignore it. If you put say `@JsonIgnore` on say `getName()` then the `name()` record accessor will be ignored! If you do not ignore `getName()` Jackson will call it.\r\n\r\nI guess what I'm saying is OOB auto detect for records seems broken and there needs to be way to define accessors besides getters and fields.\r\n\r\nIt seems like out of the box for records jackson should only care about the record components. \r\nMaybe I'm missing something? Should I file this as a separate bug?\r\n\n\nComment by cowtowncoder:\n@agentgt Yes, there is one fundamental implementation problem that causes this -- it is not mismatch between non-getter and getter as much as missing linkage between \"Creator\" parameters and \"regular\" property accessors (getters, setters). This is probably why annotations do not get properly considered for all accessors of a single logical property.\r\n\r\nI am hoping to eventually fix this, but unfortunately the change is to rewrite property introspection and I just haven't had time to allocate for this work. On plus side we have tests to verify fix, as well as guard against various regressions.\r\n\r\nIn the meantime I appreciate your sharing of workarounds so others can use them too.\r\n\n\nComment by cowtowncoder:\nOk I am pretty sure this is same as #2992 and since that is earlier, will close this one as duplicate.\r\nSo the solution for same will be marked as fix for #2992 when we finally get there.",
                "source_code": null,
                "distance": 0.75,
                "title": "@JsonNaming does not work with Java 16 record types",
                "name": "issue#3102",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3102"
                    }
                ],
                "similarity": 0.2143263839841922,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "805",
                "type": "issue",
                "content": "I want `ObjectMapper` to be able to convert the following object to a `Map<String,Object>` (basically listing the properties):\n\n``` java\npublic class FooImpl implements Foo {\n  private Boolean enabled;\n\n  @Override\n  public boolean isEnabled() { ... }\n\n  public void setEnabled(Boolean enabled) { this.enabled = enabled; } \n}\n```\n\nThe `enabled` property is inconsistent as its getter returns a primitive `boolean` while the setter uses a `java.lang.Boolean` wrapper. \n\nIs there a way to configure the `ObjectMapper` to detect such special cases? Thanks!\n\n\n\nComment by cowtowncoder:\nPlease use mailing lists for questions. Issue tracker is for reporting issues and requesting new features.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Force support of inconsistent boolean property",
                "name": "issue#805",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4615"
                    },
                    {
                        "start_node": "pr#4615",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4584"
                    },
                    {
                        "start_node": "issue#4584",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#805"
                    }
                ],
                "similarity": 0.21080239553879385,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "2992",
                "type": "issue",
                "content": "Hello,\r\n\r\nWhen I try to use a `@JsonNaming`  annotation on a record, I cannot unmarshall json to an object because a mapping exception occurs. \r\n\r\nI use jackson 2.12.0 with JDK 15.\r\n\r\nA Test example can be something like: \r\n\r\n```\r\n    @Test\r\n    void tryJsonNamingOnRecord() throws Exception{\r\n        ObjectMapper mapper=new ObjectMapper();\r\n\r\n        @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)\r\n                record Test(String myId, String myValue){}\r\n\r\n        var src=new Test(\"id\", \"value\");\r\n        String json=mapper.writeValueAsString(src);\r\n        assertThat(json).contains(\"\\\"my_id\\\":\\\"id\\\"\", \"\\\"my_value\\\":\\\"value\\\"\");\r\n        var after=mapper.readValue(json, Test.class);\r\n        assertThat(after).isEqualTo(src);\r\n    }\r\n```\r\n\r\nThe json String is generated correctly, but when unmarshalling, I got an exception  \r\n\r\n```\r\ncom.fasterxml.jackson.databind.JsonMappingException: Can not set final java.lang.String field test.Tests$1Test.myValue to java.lang.String\r\n\tat com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:274)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:623)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:611)\r\n\tat com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:634)\r\n\tat com.fasterxml.jackson.databind.deser.impl.FieldProperty.set(FieldProperty.java:193)\r\n\tat com.fasterxml.jackson.databind.deser.impl.PropertyValue$Regular.assign(PropertyValue.java:62)\r\n\tat com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator.build(PropertyBasedCreator.java:211)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:520)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1390)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:362)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:195)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:322)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4591)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3546)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3514)\r\n\tat test.Tests.tryJsonNamingOnRecord(Tests.java:100)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\t...\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n...\r\nCaused by: java.lang.IllegalAccessException: Can not set final java.lang.String field test.Tests$1Test.myValue to java.lang.String\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76)\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80)\r\n\tat java.base/jdk.internal.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:79)\r\n\tat java.base/java.lang.reflect.Field.set(Field.java:793)\r\n\tat com.fasterxml.jackson.databind.deser.impl.FieldProperty.set(FieldProperty.java:190)\r\n\t... 76 more\r\n```\r\n\n\n\nComment by cowtowncoder:\nI cannot quite reproduce this with the current 2.12.1-SNAPSHOT, but I do get different error, if Record is declared as a method-local class like in your example: this is not usage that is or can be supported.\r\nReason being that you cannot deserialize non-static inner classes: they have that gnarly invisible \"this\" that needs to be passed: at least in case of regular POJOs and I don't think Records are different here.\r\n\r\n`PropertyNamingStrategy` itself is supported.\r\n\r\nSo you'd need to declare Record as regular inner class (they are always static, at least) or as stand-alone type.\r\n\r\n\n\nComment by GregoireW:\n\r\nPutting a record as stand alone type in is own file and setting `@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)` fail with the same exception as before.\r\n\r\nFrom what I read in the code, Jackson first create an object from the constructor, filling parameters with properties it can match by name (setting null if it can not), then apply the naming strategy which may override some attributes values (the default naming strategy which is based on property name means there is nothing to do in the second step in case of a record). \r\n\r\nRecord are immutable, the second phase will always fail if there is at least one attributes which name do not match the name in the json.\r\n\r\nYour test is success because there is a \"bug\" in jdk14 (record are not so immutable after all in JDK14). With JDK15 your test fail ( I use JDK15, and I was able to have a green if I use JDK14 and red if I use JDK15.\r\n\r\nTurns out there is a quote in the [JEP record second preview, JDK15](https://bugs.openjdk.java.net/browse/JDK-8242303)\r\n\r\n>  The implicitly declared fields corresponding to the record components of a record class are final and moreover are not modifiable via reflection (doing so will throw IllegalAccessException). These restrictions embody an immutable by default policy that is widely applicable for data-carrier classes.\r\n\r\nOn the [record JEP for JDK16 (Release version)](https://bugs.openjdk.java.net/browse/JDK-8246771) the quote become:\r\n\r\n> The fields derived from the record components are final. This restriction embodies an immutable by default policy that is widely applicable for data-carrier classes.\r\n\r\nEven if the \"IllegalAccessException\" is not mention, I think it means it will be kept that way (There is nothing about relaxing this in the 'refinement' section).\r\n\r\n\r\nOn a positive note, the record in method local is fine, this test is success for both JDK14 and JDK15.\r\n\r\n```java\r\n    @Test\r\n    void tryLocalMethodRecord() throws Exception{\r\n        ObjectMapper mapper=new ObjectMapper();\r\n\r\n        record Test(String myId, String myValue){}\r\n\r\n        var src=new Test(\"id\", \"value\");\r\n        String json=mapper.writeValueAsString(src);\r\n        assertThat(json).contains(\"\\\"myId\\\":\\\"id\\\"\", \"\\\"myValue\\\":\\\"value\\\"\");\r\n        var after=mapper.readValue(json, Test.class);\r\n        assertThat(after).isEqualTo(src);\r\n    }\r\n```\r\n\n\nComment by cowtowncoder:\n@GregoireW I don't think your explanation of how you think naming strategy works is quite accurate: naming strategy is used as part of constructing deserializer and modifies \"true\" names used and expected -- it is not used dynamically during deserialization itself (that would be rather inefficient)\r\nBut what is possible -- and compatible with your observations -- is that due to different issue (*), the names of underlying fields and names of constructor parameters might not get linked during initial introspection, leading to only former getting renamed according to naming strategy: this would essentially leave two sets of unrelated properties instead of one unified set.\r\n\r\n(sidenote: What is interesting, on method local Records, is that I do get actual failure: this is why I suggested it as likely root cause (it is something reported for POJOs every now and then -- but it does make sense Records differ a bit wrt static-ness) )\r\n\r\nAnyway. If above is true, this is unfortunately much much more difficult problem to solve, and probably something I cannot fix for 2.12.x at all (due to high risk of refactoring). But first things first... good things is that as per your comments, while I cannot reproduce this with JDK 14 (latest I have installed), I can then get 15 installed (even if it's not LTS at least it'd be ok for reproduction).\r\nAnd what might be possible to do would be to explicitly prevent use of fields for `Record`s.\r\n\r\n... although while removing Fields might be the right thing to do, for longer term, it would also immediately \"break\" existing users, use cases, for Records with JDK 14 and Preview option.\r\nSo multiple bad options.\r\n\r\n(*) See f.ex #2974 -- not specific to Records, but to creator method handling for POJOs as well -- due to creator parameters not being recognized unless explicit annotated with `@JsonProperty`\r\n\r\n\n\nComment by GregoireW:\nI only scratch the surface on how it works, so yes I more guess on what I saw than really drill down the code.\r\n\r\n>  So multiple bad options.\r\n\r\nI was guessing so... Unfortunately this one need a drill down to multiple aspect of this library, I will not have time to check what can be done. \n\nComment by cowtowncoder:\n@GregoireW thank you for reporting the issue and digging pretty deep actually -- constructor-handling part of property introspection is a mess. Apologies for lecturing on internal workings, your educated guess on behavior is pretty good considering symptoms. But more importantly I had completely missed the possibility that just because use cases seemed to work, they might have worked for the wrong reasons: that is, use of fields was intended to be completely avoided with 2.12.0. It sounds like this has not happened.\r\n\r\nThis is not completely unexpected, for what that is worth, and the specific part of functionality (discrepancy between initial POJOPropertiesCollector detection and later Basic/BeanDeserializerFactory gathering of Creator methods) has been known to be in need of rewrite for a while. 2.12 did some rewriting of latter part but I am bit afraid of full rewrite and was wondering if it could be only attempted for 3.0.\r\nBut now I am beginning to think it might be one big thing to do for 2.13 (along with increasing baseline to Java 8).\r\n\r\nSo that's a long of saying \"thank you very much for doing what you did already\". :)\r\nI can take it from here as necessary. Additional help obviously very welcome, but not expected.\r\n\r\n\r\n\n\nComment by GregoireW:\nbtw, I did a test with toolchains to check what was possible to do.\r\n\r\nIf you setup a `~/.m2/toolchains.xml ` file like (well update the JDK location to fit your setup):\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<toolchains xmlns=\"http://maven.apache.org/TOOLCHAINS/1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/TOOLCHAINS/1.1.0 http://maven.apache.org/xsd/toolchains-1.1.0.xsd\">\r\n\r\n  <toolchain>\r\n    <type>jdk</type>\r\n    <provides>\r\n      <version>1.8</version>\r\n      <vendor>sun</vendor>\r\n    </provides>\r\n    <configuration>\r\n      <jdkHome>/opt/java/jdk1.8.0_202</jdkHome>\r\n    </configuration>\r\n  </toolchain>\r\n\r\n  <toolchain>\r\n    <type>jdk</type>\r\n    <provides>\r\n      <version>14</version>\r\n      <vendor>openjdk</vendor>\r\n    </provides>\r\n    <configuration>\r\n      <jdkHome>/opt/java/jdk-14</jdkHome>\r\n    </configuration>\r\n  </toolchain>\r\n\r\n  <toolchain>\r\n    <type>jdk</type>\r\n    <provides>\r\n      <version>15</version>\r\n      <vendor>openjdk</vendor>\r\n    </provides>\r\n    <configuration>\r\n      <jdkHome>/opt/java/jdk-15</jdkHome>\r\n    </configuration>\r\n  </toolchain>\r\n  \r\n</toolchains>\r\n```\r\n\r\nyou can replace the `plugins` section of the `pom.xml` by:\r\n\r\n```xml\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.jacoco</groupId>\r\n        <artifactId>jacoco-maven-plugin</artifactId>\r\n        <version>0.8.6</version>\r\n        <executions>\r\n          <execution>\r\n            <goals>\r\n              <goal>prepare-agent</goal>\r\n            </goals>\r\n          </execution>\r\n          <execution>\r\n            <id>report</id>\r\n            <phase>verify</phase>\r\n            <goals>\r\n              <goal>report</goal>\r\n            </goals>\r\n          </execution>\r\n        </executions>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.codehaus.mojo</groupId>\r\n        <artifactId>build-helper-maven-plugin</artifactId>\r\n        <executions>\r\n          <execution>\r\n            <id>add-test-source</id>\r\n            <phase>generate-test-sources</phase>\r\n            <goals>\r\n              <goal>add-test-source</goal>\r\n            </goals>\r\n            <configuration>\r\n              <sources>\r\n                <source>src/test-jdk14/java</source>\r\n              </sources>\r\n            </configuration>\r\n          </execution>\r\n        </executions>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <artifactId>maven-compiler-plugin</artifactId>\r\n        <executions>\r\n          <execution>\r\n            <id>default-testCompile</id>\r\n            <goals>\r\n              <goal>testCompile</goal>\r\n            </goals>\r\n            <configuration>\r\n              <optimize>true</optimize>\r\n              <jdkToolchain>\r\n                <version>1.8</version>\r\n              </jdkToolchain>\r\n              <compileSourceRoots>\r\n                <compileSourceRoot>${project.basedir}/src/test/java</compileSourceRoot>\r\n              </compileSourceRoots>\r\n            </configuration>\r\n          </execution>\r\n          <execution>\r\n            <id>jdk-14</id>\r\n            <goals>\r\n              <goal>testCompile</goal>\r\n            </goals>\r\n            <configuration>\r\n              <optimize>true</optimize>\r\n              <jdkToolchain>\r\n                <version>14</version>\r\n              </jdkToolchain>\r\n              <compileSourceRoots>\r\n                <compileSourceRoot>${project.basedir}/src/test/java</compileSourceRoot>\r\n                <compileSourceRoot>${project.basedir}/src/test-jdk14/java</compileSourceRoot>\r\n              </compileSourceRoots>\r\n              <outputDirectory>${project.build.directory}/test-classes-jdk14</outputDirectory>\r\n              <testExcludes>\r\n                <testExclude>**/Java9ListsTest.java</testExclude>\r\n              </testExcludes>\r\n              <source>14</source>\r\n              <release>14</release>\r\n              <compilerArgs>\r\n                <arg>-parameters</arg>\r\n                <arg>--enable-preview</arg>\r\n              </compilerArgs>\r\n            </configuration>\r\n          </execution>\r\n          <execution>\r\n            <id>jdk-15</id>\r\n            <goals>\r\n              <goal>testCompile</goal>\r\n            </goals>\r\n            <configuration>\r\n              <optimize>true</optimize>\r\n              <jdkToolchain>\r\n                <version>15</version>\r\n              </jdkToolchain>\r\n              <compileSourceRoots>\r\n                <compileSourceRoot>${project.basedir}/src/test/java</compileSourceRoot>\r\n                <compileSourceRoot>${project.basedir}/src/test-jdk14/java</compileSourceRoot>\r\n              </compileSourceRoots>\r\n              <outputDirectory>${project.build.directory}/test-classes-jdk15</outputDirectory>\r\n              <testExcludes>\r\n                <testExclude>**/Java9ListsTest.java</testExclude>\r\n              </testExcludes>\r\n              <source>15</source>\r\n              <release>15</release>\r\n              <compilerArgs>\r\n                <arg>-parameters</arg>\r\n                <arg>--enable-preview</arg>\r\n              </compilerArgs>\r\n            </configuration>\r\n          </execution>\r\n        </executions>\r\n        <configuration>\r\n          <!-- 17-Sep-2017, tatu: With 3.0 need to ensure parameter names compiled in -->\r\n          <optimize>true</optimize>\r\n          <compilerArgs>\r\n            <arg>-parameters</arg>\r\n          </compilerArgs>\r\n        </configuration>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <artifactId>maven-resources-plugin</artifactId>\r\n        <version>3.2.0</version>\r\n        <executions>\r\n          <execution>\r\n            <id>resources-jdk14</id>\r\n            <goals>\r\n              <goal>testResources</goal>\r\n            </goals>\r\n            <configuration>\r\n              <outputDirectory>${project.build.directory}/test-classes-jdk14</outputDirectory>\r\n            </configuration>\r\n          </execution>\r\n          <execution>\r\n            <id>resources-jdk15</id>\r\n            <goals>\r\n              <goal>testResources</goal>\r\n            </goals>\r\n            <configuration>\r\n              <outputDirectory>${project.build.directory}/test-classes-jdk15</outputDirectory>\r\n            </configuration>\r\n          </execution>\r\n        </executions>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <version>3.0.0-M5</version>\r\n        <artifactId>maven-surefire-plugin</artifactId>\r\n        <executions>\r\n          <execution>\r\n            <id>default-test</id>\r\n            <goals>\r\n              <goal>test</goal>\r\n            </goals>\r\n            <configuration>\r\n              <jdkToolchain>\r\n                <version>1.8</version>\r\n              </jdkToolchain>\r\n              <excludes>\r\n                <exclude>com/fasterxml/jackson/failing/*.java</exclude>\r\n\r\n                <exclude>**/RecordBasicsTest.class</exclude>\r\n                <exclude>**/RecordCreatorsTest.class</exclude>\r\n                <exclude>**/Java9ListsTest.class</exclude>\r\n                <exclude>**/RecordWithJsonSetter2974Test.class</exclude>\r\n              </excludes>\r\n            </configuration>\r\n          </execution>\r\n          <execution>\r\n            <id>test-jdk14</id>\r\n            <goals>\r\n              <goal>test</goal>\r\n            </goals>\r\n            <configuration>\r\n              <jdkToolchain>\r\n                <version>14</version>\r\n              </jdkToolchain>\r\n              <testClassesDirectory>${project.build.directory}/test-classes-jdk14</testClassesDirectory>\r\n              <excludes>\r\n                <exclude>com/fasterxml/jackson/failing/*.java</exclude>\r\n\r\n                <exclude>**/RecordWithJsonSetter2974Test.class</exclude>\r\n              </excludes>\r\n              <argLine>@{argLine} --enable-preview -XX:+ShowCodeDetailsInExceptionMessages</argLine>\r\n            </configuration>\r\n          </execution>\r\n          <execution>\r\n            <id>test-jdk15</id>\r\n            <goals>\r\n              <goal>test</goal>\r\n            </goals>\r\n            <configuration>\r\n              <jdkToolchain>\r\n                <version>15</version>\r\n              </jdkToolchain>\r\n              <testClassesDirectory>${project.build.directory}/test-classes-jdk15</testClassesDirectory>\r\n              <excludes>\r\n                <exclude>com/fasterxml/jackson/failing/*.java</exclude>\r\n\r\n                <exclude>**/RecordWithJsonSetter2974Test.class</exclude>\r\n              </excludes>\r\n              <argLine>@{argLine} --enable-preview -XX:+ShowCodeDetailsInExceptionMessages</argLine>\r\n            </configuration>\r\n          </execution>\r\n        </executions>\r\n        <configuration>\r\n          <classpathDependencyExcludes>\r\n            <exclude>javax.measure:jsr-275</exclude>\r\n          </classpathDependencyExcludes>\r\n          <!-- 26-Nov-2019, tatu: moar parallelism! Per-class basis, safe, efficient enough\r\n                      ... although not 100% sure this makes much difference TBH\r\n                -->\r\n          <threadCount>4</threadCount>\r\n          <parallel>classes</parallel>\r\n        </configuration>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <artifactId>maven-javadoc-plugin</artifactId>\r\n        <configuration>\r\n          <links combine.children=\"append\">\r\n            <link>http://fasterxml.github.com/jackson-annotations/javadoc/3.0</link>\r\n            <link>http://fasterxml.github.com/jackson-core/javadoc/3.0</link>\r\n          </links>\r\n        </configuration>\r\n      </plugin>\r\n\r\n      <plugin> <!-- default settings are fine, just need to enable here -->\r\n        <!-- Inherited from oss-base. Generate PackageVersion.java.-->\r\n        <groupId>com.google.code.maven-replacer-plugin</groupId>\r\n        <artifactId>replacer</artifactId>\r\n        <executions>\r\n          <execution>\r\n            <id>generate-package-version-java</id>\r\n            <phase>prepare-package</phase>\r\n            <goals>\r\n              <goal>replace</goal>\r\n            </goals>\r\n          </execution>\r\n        </executions>\r\n      </plugin>\r\n\r\n      <plugin>\r\n        <groupId>org.moditect</groupId>\r\n        <artifactId>moditect-maven-plugin</artifactId>\r\n      </plugin>\r\n      <!-- 03-Nov-2020, tatu: Add LICENSE from main level -->\r\n\r\n      <plugin>\r\n        <groupId>de.jjohannes</groupId>\r\n        <artifactId>gradle-module-metadata-maven-plugin</artifactId>\r\n      </plugin>\r\n    </plugins>\r\n```\r\n\r\nyou can remove the `jdk14` profile, then running maven with a jdk 8, will compile source with this jdk, compile test 3 times (jdk8, jdk14 (preview mode) and jdk15 (preview mode) ),  and run all test 3 times, with jdk8, 14 and 15 (well jdk14 test are disabled when running on jdk8).\r\n\r\nThis approach is simpler to test all needed jdk in one time, but need the toolchains setup. \r\n\r\nThe not so good aspect is we need to compile 3 times all the tests as jdk14 compiled with preview cannot be run by jdk15.\r\nIt would theoricaly possible to filter test to run only some test with jdk14 or 15, but option are limited on compilation part and surefire part.\r\n\r\nJacoco plugin has to be bound to verify step to prevent run before all test, but I'm not sure how code coverage will be with the multiple test run. \r\n\r\nAnyway, this approach may not be the correct approach (what will be the jdk to test in march when jdk16 is released or in september with jdk17) , but as I did some test with this I share it if you want to test too.\r\n\n\nComment by cowtowncoder:\n@GregoireW thank you for sharing this! It is probably not something I'd consider at this point for databind repo (if it triples build time, requires use of later JDK), but sounds like something that could work well for projects like `jackson-integration-tests` (external testing package that can add cross-dependencies across Jackson components) and some individual repos.\r\n\n\nComment by cowtowncoder:\nFor what it is worth, I was able to replicate the failure by forcing removal of `Field` accessors for Records (in POJOPropertiesCollector); this fails naming-strategy case.\r\nHopign to address the issue for 2.13.\r\n\n\nComment by jedvardsson:\nWould the preferred way to fix this be to rewrite the property names when deriving the bean description? \r\nI guess I could add a beandeserializermodifier to fix this temporarily, right?\r\n\r\nEdit:\r\n```\r\npackage com.examaple.jackson;\r\n\r\nimport com.fasterxml.jackson.databind.BeanDescription;\r\nimport com.fasterxml.jackson.databind.DeserializationConfig;\r\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\r\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\r\nimport com.fasterxml.jackson.databind.deser.ValueInstantiators;\r\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\r\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\r\nimport com.fasterxml.jackson.databind.module.SimpleModule;\r\n\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class RecordNamingStrategyPatchModule extends SimpleModule {\r\n\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        context.addValueInstantiators(new ValueInstantiatorsModifier());\r\n        super.setupModule(context);\r\n    }\r\n\r\n    /**\r\n     * <a href=\"https://github.com/FasterXML/jackson-databind/issues/2992\">Properties naming strategy do not work with Record #2992</a>\r\n     */\r\n    private static class ValueInstantiatorsModifier extends ValueInstantiators.Base {\r\n        @Override\r\n        public ValueInstantiator findValueInstantiator(\r\n                DeserializationConfig config, BeanDescription beanDesc, ValueInstantiator defaultInstantiator\r\n        ) {\r\n            if (!beanDesc.getBeanClass().isRecord() || !(defaultInstantiator instanceof StdValueInstantiator) || !defaultInstantiator.canCreateFromObjectWith()) {\r\n                return defaultInstantiator;\r\n            }\r\n            // StdValueInstantiator can be modified in place\r\n            SettableBeanProperty[] fromObjectArguments = defaultInstantiator.getFromObjectArguments(config);\r\n            Map<String, BeanPropertyDefinition> map = beanDesc.findProperties().stream().collect(Collectors.toMap(p -> p.getInternalName(), Function.identity()));\r\n            for (int i = 0; i < fromObjectArguments.length; i++) {\r\n                SettableBeanProperty arg = fromObjectArguments[i];\r\n                BeanPropertyDefinition prop = map.get(arg.getName());\r\n                if (prop != null) {\r\n                    fromObjectArguments[i] = arg.withName(prop.getFullName());\r\n                }\r\n            }\r\n            return defaultInstantiator;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\npackage com.examaple.jackson;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonMappingException;\r\nimport com.fasterxml.jackson.databind.PropertyNamingStrategies;\r\nimport com.fasterxml.jackson.databind.json.JsonMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport static org.junit.jupiter.api.Assertions.assertThrows;\r\n\r\nclass RecordNamingStrategyPatchModuleTest {\r\n\r\n    private static final JsonMapper STANDARD_MAPPER = JsonMapper.builder()\r\n            .addModule(new ParameterNamesModule())\r\n            .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n            .build();\r\n\r\n    private static final JsonMapper PATCHED_MAPPER = JsonMapper.builder()\r\n            .addModule(new ParameterNamesModule())\r\n            .addModule(new RecordNamingStrategyPatchModule())\r\n            .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n            .build();\r\n\r\n    public record SampleItem(int itemId) {\r\n    }\r\n\r\n    @Test\r\n    void testNamingStrategyDeserializeRecordBug() throws JsonProcessingException {\r\n        assertThrows(JsonMappingException.class, () ->\r\n                STANDARD_MAPPER.readValue(\"\"\"\r\n                        {\"item_id\": 5}\r\n                        \"\"\", SampleItem.class), \"https://github.com/FasterXML/jackson-databind/issues/2992 has been fixed!\");\r\n\r\n        assertEquals(new SampleItem(5),\r\n                PATCHED_MAPPER.readValue(\"\"\"\r\n                        {\"item_id\": 5}\r\n                        \"\"\", SampleItem.class));\r\n    }\r\n}\r\n```\r\n\n\nComment by cowtowncoder:\nYes, I want to fix the problem by correctly linking constructor parameter -- something I am planning to achieve for 2.13.\r\n\r\nAs to fix... ability to modify the array is not part of API so I would not really recommend it as something that is likely to keep working (that is, this implementation detail could change, or might behave differently for some edge case). But if it works now it might work in future.\r\n\n\nComment by jedvardsson:\nGreat. I will only use my fix will until 2.13. Here is a version that does not modify in place:\r\n\r\n```\r\npackage com.examaple.jackson;\r\n\r\nimport com.fasterxml.jackson.databind.BeanDescription;\r\nimport com.fasterxml.jackson.databind.DeserializationConfig;\r\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\r\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\r\nimport com.fasterxml.jackson.databind.deser.ValueInstantiators;\r\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\r\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\r\nimport com.fasterxml.jackson.databind.module.SimpleModule;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class RecordNamingStrategyPatchModule extends SimpleModule {\r\n\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        context.addValueInstantiators(new ValueInstantiatorsModifier());\r\n        super.setupModule(context);\r\n    }\r\n\r\n    /**\r\n     * Remove when the following issue is resolved: \r\n     * <a href=\"https://github.com/FasterXML/jackson-databind/issues/2992\">Properties naming strategy do not work with Record #2992</a>\r\n     */\r\n    private static class ValueInstantiatorsModifier extends ValueInstantiators.Base {\r\n        @Override\r\n        public ValueInstantiator findValueInstantiator(\r\n                DeserializationConfig config, BeanDescription beanDesc, ValueInstantiator defaultInstantiator\r\n        ) {\r\n            if (!beanDesc.getBeanClass().isRecord() || !(defaultInstantiator instanceof StdValueInstantiator) || !defaultInstantiator.canCreateFromObjectWith()) {\r\n                return defaultInstantiator;\r\n            }\r\n            Map<String, BeanPropertyDefinition> map = beanDesc.findProperties().stream().collect(Collectors.toMap(p -> p.getInternalName(), Function.identity()));\r\n            SettableBeanProperty[] renamedConstructorArgs = Arrays.stream(defaultInstantiator.getFromObjectArguments(config))\r\n                    .map(p -> {\r\n                        BeanPropertyDefinition prop = map.get(p.getName());\r\n                        return prop != null ? p.withName(prop.getFullName()) : p;\r\n                    })\r\n                    .toArray(SettableBeanProperty[]::new);\r\n\r\n            return new PatchedValueInstantiator((StdValueInstantiator) defaultInstantiator, renamedConstructorArgs);\r\n        }\r\n    }\r\n\r\n    private static class PatchedValueInstantiator extends StdValueInstantiator {\r\n\r\n        protected PatchedValueInstantiator(StdValueInstantiator src, SettableBeanProperty[] constructorArguments) {\r\n            super(src);\r\n            _constructorArguments = constructorArguments;\r\n        }\r\n    }\r\n}\r\n```\n\nComment by cowtowncoder:\n@jedvardsson excellent -- thank you very much for sharing this solution!\r\n\n\nComment by MRamonLeon:\nDoes this workaroud work on every case?\r\nThis solution didn't work for me (a record with `SnakeCaseStrategy`). It still complains about `Can not set final java.lang.String field ...`.\r\n\r\n> Great. I will only use my fix will until 2.13. Here is a version that does not modify in place:\r\n> \r\n> ```\r\n> package com.examaple.jackson;\r\n> \r\n> import com.fasterxml.jackson.databind.BeanDescription;\r\n> import com.fasterxml.jackson.databind.DeserializationConfig;\r\n> import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\r\n> import com.fasterxml.jackson.databind.deser.ValueInstantiator;\r\n> import com.fasterxml.jackson.databind.deser.ValueInstantiators;\r\n> import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\r\n> import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\r\n> import com.fasterxml.jackson.databind.module.SimpleModule;\r\n> \r\n> import java.util.Arrays;\r\n> import java.util.Map;\r\n> import java.util.function.Function;\r\n> import java.util.stream.Collectors;\r\n> \r\n> public class RecordNamingStrategyPatchModule extends SimpleModule {\r\n> \r\n>     @Override\r\n>     public void setupModule(SetupContext context) {\r\n>         context.addValueInstantiators(new ValueInstantiatorsModifier());\r\n>         super.setupModule(context);\r\n>     }\r\n> \r\n>     /**\r\n>      * Remove when the following issue is resolved: \r\n>      * <a href=\"https://github.com/FasterXML/jackson-databind/issues/2992\">Properties naming strategy do not work with Record #2992</a>\r\n>      */\r\n>     private static class ValueInstantiatorsModifier extends ValueInstantiators.Base {\r\n>         @Override\r\n>         public ValueInstantiator findValueInstantiator(\r\n>                 DeserializationConfig config, BeanDescription beanDesc, ValueInstantiator defaultInstantiator\r\n>         ) {\r\n>             if (!beanDesc.getBeanClass().isRecord() || !(defaultInstantiator instanceof StdValueInstantiator) || !defaultInstantiator.canCreateFromObjectWith()) {\r\n>                 return defaultInstantiator;\r\n>             }\r\n>             Map<String, BeanPropertyDefinition> map = beanDesc.findProperties().stream().collect(Collectors.toMap(p -> p.getInternalName(), Function.identity()));\r\n>             SettableBeanProperty[] renamedConstructorArgs = Arrays.stream(defaultInstantiator.getFromObjectArguments(config))\r\n>                     .map(p -> {\r\n>                         BeanPropertyDefinition prop = map.get(p.getName());\r\n>                         return prop != null ? p.withName(prop.getFullName()) : p;\r\n>                     })\r\n>                     .toArray(SettableBeanProperty[]::new);\r\n> \r\n>             return new PatchedValueInstantiator((StdValueInstantiator) defaultInstantiator, renamedConstructorArgs);\r\n>         }\r\n>     }\r\n> \r\n>     private static class PatchedValueInstantiator extends StdValueInstantiator {\r\n> \r\n>         protected PatchedValueInstantiator(StdValueInstantiator src, SettableBeanProperty[] constructorArguments) {\r\n>             super(src);\r\n>             _constructorArguments = constructorArguments;\r\n>         }\r\n>     }\r\n> }\r\n> ```\r\n\n\nComment by jedvardsson:\n> Does this workaroud work on every case? This solution didn't work for me (a record with `SnakeCaseStrategy`). It still complains about `Can not set final java.lang.String field ...`.\r\n\r\n@MRamonLeon, am not sure how your JsonMapper is setup, but are you using the `ParameterNamesModule` (which relies metadata generated by the java compiler using the -parameters flag) . If not it might explain why Jackson tries to set the record fields instead of using the record constructor. Here is the junit test I am using to track the bug. \r\n\r\n```\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonMappingException;\r\nimport com.fasterxml.jackson.databind.PropertyNamingStrategies;\r\nimport com.fasterxml.jackson.databind.json.JsonMapper;\r\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport static org.junit.jupiter.api.Assertions.assertThrows;\r\n\r\nclass RecordNamingStrategyPatchModuleTest {\r\n\r\n    private static final JsonMapper STANDARD_MAPPER = JsonMapper.builder()\r\n            .addModule(new ParameterNamesModule())\r\n            .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n            .build();\r\n\r\n    private static final JsonMapper PATCHED_MAPPER = JsonMapper.builder()\r\n            .addModule(new ParameterNamesModule())\r\n            .addModule(new RecordNamingStrategyPatchModule())\r\n            .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\r\n            .build();\r\n\r\n    public record SampleItem(int itemId) {\r\n    }\r\n\r\n    @Test\r\n    void testNamingStrategyDeserializeRecordBug() throws JsonProcessingException {\r\n        assertThrows(JsonMappingException.class, () ->\r\n                STANDARD_MAPPER.readValue(\"\"\"\r\n                        {\"item_id\": 5}\r\n                        \"\"\", SampleItem.class), \"https://github.com/FasterXML/jackson-databind/issues/2992 has been fixed!\");\r\n\r\n        assertEquals(new SampleItem(5),\r\n                PATCHED_MAPPER.readValue(\"\"\"\r\n                        {\"item_id\": 5}\r\n                        \"\"\", SampleItem.class));\r\n    }\r\n}\r\n```\r\n\n\nComment by rmetzger:\nA poor man's workaround for this issue is to just manually annotate the fields with the wrong naming pattern with `@JsonProperty(\"user_id\") String userId`.\n\nComment by cgpassante:\nAny idea when this will be fixed? Considering moving to record for all DTOs but we use kebab case as a standard and having to annotate every field removes a big part of the advantage of reduced verbosity that record types provide. Right now this is a blocker to adopting record.\n\nComment by jedvardsson:\n@cgpassante you CSN just add the workaround I posted in a [comment](#issuecomment-799213433) No need for annotations. \r\n\r\nUse the test in [comment](#issuecomment-1043039439) to track the bug. \n\nComment by cowtowncoder:\n@cgpassante Unfortunately there is no concrete idea: problem is that it would be fixable as part of big rewrite of property introspection. But I have not found enough contiguous time to spend on  tackling this (I only work on Jackson during my spare time): it could be that I might be able to do that within next month if something opened up. And yet with all the other things going on, it may be that it won't happen this year.\r\n\r\nWhat I do not want to try is a one-off hack to work around just this problem since that tends to complicate eventual rewrite.\r\n\r\nI agree that this problem area -- proper support of Java Records -- is VERY important, and I try my best to find time to resolve it properly.\r\n\r\n\n\nComment by briangoetz:\nDr. Jackson -- if you have a candidate strategy in mind, you are welcome to preflight it at the amber-dev@openjdk.org list, to validate that you're not subtly stepping on the Record contract.  \n\nComment by cowtowncoder:\n@briangoetz Thank you for suggestion. I think at this point the issues are relatively well-known (basically Record support is a tweak on earlier code that does not consider there being module-system imposed access limits, nor Fields being off-limits). Once those are cleared if there are more subtle problems we can and will reach out as necessary.\n\nComment by yihtserns:\n@cgpassante how does your non-record setup (i.e. the DTO classes) looks like currently?  Bean class with getters & setters?\n\nComment by cgpassante:\n> @cgpassante how does your non-record setup (i.e. the DTO classes) looks like currently? Bean class with getters & setters?\r\n\r\nThey are standard Bean classes. The issue is really our use of PropertyNamingStrategies.KEBAB_CASE. It does not translate attribute names in records. So we must use @JsonProperty(\"tracking-id\") String trackingId, to explicitly name each record field. It removes the major benefit of records over beans...brevity.\n\nComment by M4urici0GM:\nany updates on this? \n\nComment by nazarii-klymok:\nGreetings! I love [jedvardsson](https://github.com/jedvardsson)'s solution. It would be great though to support this out of the box :) \n\nComment by cowtowncoder:\n@M4urici0GM if there were updates, there would be notes here. Hence, no.\r\n\r\n@nazarii-klymok the idea is to make all annotations work, but unfortunately there is no simple/easy fix: a complete overhaul of property introspection is needed. I haven't had time to dedicate for this due to may daytime job. I do hope to get there for 2.15 but it is difficult to predict if that happens or not.\r\n\n\nComment by gunnarmorling:\nHey @cowtowncoder, first of all, thank you so much for maintaining this project (in your spare time no less)! The community really stands on the shoulders of a giant here. Having been in that same position myself before, I relate to how you may be feel; at least I often felt overwhelmed and eventually lost the motivation to further work on the project (hence, a big boo to whoever gave that thumbs down to your comment above \ud83d\ude20).\r\n\r\nOn the issue itself, I don't mean to further add to your workload, so just in case: is there by any chance a description or design doc of what that complete overhaul would look like? Or asked differently, is there a way for folks in the community to help? Oftentimes there are people who may be willing to help out, but aren't able to do so (or don't dare) because there's not good enough of a description of the problem, its context and potential solution constraints which already are present in the mind of the core maintainers. I probably won't have the bandwidth myself (as much as I'd like to do it, as said, I feel the community owes you so much here), but perhaps having a more in-depth description could help finding others willing to step up. Anyways, just a thought, and thanks again for this amazing project!\n\nComment by cowtowncoder:\nHi @gunnarmorling! I REALLY appreciate your suggestion here. I will have to think of how I could do something along those lines. I have added some vague outlines in various issues, but nothing concrete enough to let others start from somewhere other than square 1. But maybe I can do some preparation work to dig out details that I'd need myself.\r\nAnd I am 110% certain that the community would be happy to help -- at this point majority of changes are done by someone other than myself, which is a new & great thing to have happened.\r\n\r\nI will add whatever I know, tho, as a separate comment in case that might help someone interested in maybe tackling the issue, or at least learn more about what it might take.\n\nComment by cowtowncoder:\nOk, so the issue is roughly as follows:\r\n\r\n1. Property introspection needed to eventually produce `BasicBeanDescription` starts by looking at Accessors -- Fields, Methods (getters, setters). This uses annotation-enhanced variants of accessors; some combining of annotations (from getters to setters or vice versa, to avoid having to add multiple annotations) is done now, as well as (I think?) renaming of combined properties\r\n2. After determining properties derived from accessors, Creators are introspected -- these are annotated or compatible Constructors and static (factory) methods\r\n3. Attempt is made to find Creator(s) to use; explicitly annotated ones tend to work well, but limited inference for non-annotated ones can fail to find expected one. If properties-style Creator is found, virtual \"accessors\" are created and linked to existing property (field, getter/setter) accessors (or creating new ones).\r\n4. Full merging of annotations is done at this point; but due to problems with (3) some annotations are not properly merged/propagated\r\n\r\nWhat should happen, instead, it that process should start with Creator discovery (step (3)) followed by accessor discovery. This would allow reliable linking of all accessors/properties as well as make it possible to prevent discovery of underlying fields Records have.\r\n\r\nI will need to trace through code again to remind myself of code flow: I think it:\r\n\r\n1. Starts with `BeanDeserializerFactory`/`BasicDeserializerFactory` (and -Serializer counterparts to a degree)\r\n2. factory calls `BasicClassIntrospector` which gets annotated class (`AnnotatedClass`) with `AnnotatedClassResolver.resolve` (this is fine)\r\n3. Introspector eventually creates `POJOPropertiesCollector` to perform non-Creator property discovery,\r\n4. introspector also calls some methods in `BasicBeanDescription` for construction\r\n5. After getting `BasicBeanDescription`, deserializer factory proceeds to Creator discovery; this uses properties collected previously for some of inference\r\n\r\nBut now I am bit confused wrt how `Bean/BasicSerializerFactory` does things since although Creators are not used for serialization, some annotations may be needed.\r\n\r\nAnyway, not sure above helps... I will need to go dig deeper. I will create a Discussion for this tho.\r\n\n\nComment by cowtowncoder:\nQuick update: Enabled Discussions and created #3719 \r\n",
                "source_code": null,
                "distance": 0.5,
                "title": "`@JsonNaming` does not work with Records",
                "name": "issue#2992",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    }
                ],
                "similarity": 0.20962262289896005,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4543",
                "type": "issue",
                "content": "\n\n\nComment by cowtowncoder:\nOk we are now down to 19 test failures (and none for Records), with much simpler `BasicDeserializerFactory` (although not yet removed obsolete code since some pieces may be needed).\r\n\r\nInterestingly enough looks like 3 \"failing\" tests might be passing now:\r\n\r\n* #806 \r\n* #2977 \r\n* #3241\r\n\r\nbut will not yet mark as resolved to see how they fare when all \"non-failing\" test failures are fixed.\r\n\n\nComment by cowtowncoder:\nOk: we are down to one and only one failure... and it's weird one, with mix-ins for Collection value instantiator. Hoping to solve that and then get to merge this whopper.",
                "source_code": null,
                "distance": 1.0,
                "title": "Finish `BasicDeserializerFactory` refactoring (complete #4515)",
                "name": "pr#4543",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3241"
                    },
                    {
                        "start_node": "issue#3241",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4543"
                    }
                ],
                "similarity": 0.20313372092016396,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4527",
                "type": "issue",
                "content": "Another necessary step towards #4515.\n\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Remove almost all deprecated methods from (Basic)BeanDescription",
                "name": "pr#4527",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4527"
                    }
                ],
                "similarity": 0.20013101999855645,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "562",
                "type": "issue",
                "content": "I could speed up some code if I could write:\n\n```\n@JsonCreator\npublic MyClass(@JsonProperty(\"a\") String a, @JsonAnySetter Map<String, Object> leftovers) {}\n```\n\n\n\nComment by whiskeysierra:\n:+1: Is this something that you already considered putting in?\n\n\nComment by cowtowncoder:\nConsidered, yes, had time to try to tackle, no. Would definitely be nice thing to support.\n\n\nComment by huhlig:\nAny likelihood this will land in 3.x?\n\nComment by davide-imbriaco:\nHi,\r\nI would also really like this (allows for immutable beans, and validation of data in constructor method).\n\nComment by cowtowncoder:\n@huhlig It would be nice to get it there, but I can not predict whether it will or not. I do think it would be great to get it to work but there are so many things to work on...\r\n\r\nI will keep this in mind as one of \"more/most wanted\" issues.\r\n\n\nComment by davidmoten:\nI'd also like to see this feature. As a workaround for the immutability enthusiasts, here's an example of using JsonAnySetter in an immutable class (swap out the Map/HashMap for an immutable equivalent as you like). The trick is that the JsonAnySetter method can be made private.\r\n\r\n```java\r\n@JsonAutoDetect(fieldVisibility = Visibility.ANY, creatorVisibility = Visibility.ANY, setterVisibility = Visibility.ANY)\r\npublic static final class WithMap {\r\n\r\n    @JsonProperty(\"name\")\r\n    private String name;\r\n\r\n    @JsonAnyGetter\r\n    private Map<String, String> map;\r\n\r\n    @JsonCreator\r\n    public WithMap(@JsonProperty(\"name\") String name) {\r\n        this.name = name;\r\n        this.map = new HashMap<>();\r\n    }\r\n    \r\n    public WithMap(String name, Map<String, String> map) {\r\n        this.name = name;\r\n        this.map = map;\r\n    }\r\n    \r\n    @JsonAnySetter\r\n    private void put(String key, String value) {\r\n        map.put(key, value);\r\n    }\r\n    \r\n    public String name() {\r\n        return name;\r\n    }\r\n\r\n    public Map<String, String> map() {\r\n        return Collections.unmodifiableMap(map);\r\n    }\r\n}\r\n```\n\nComment by cowtowncoder:\n@JooHyukKim I think we could use a \"failing\" test case for this, as pre-cursor to #3439.\r\n\r\nNote, too, that this is definitely one of Most-Wanted issues open.\r\n\n\nComment by cowtowncoder:\nAdded a failing test, as a minor help for anyone considering to try to implement.\r\n\r\nAlso, made `@JsonAnySetter` applicable to (constructor) parameters in `jackson-annotations` 2.17 (was not previously).\n\nComment by JooHyukKim:\n> Also, made `@JsonAnySetter` applicable to (constructor) parameters in `jackson-annotations` 2.17 (was not previously).\n\nThis is great. Thank you for taking care of things in advance.\n\nComment by cowtowncoder:\nNp. Needed that already for reproduction :)\r\n\n\nComment by cowtowncoder:\nQuick note: really hoping to get this resolved for 2.18 -- and I think there's a good chance this can happen.\r\n\n\nComment by cowtowncoder:\nThanks to PR by @JooHyukKim this is now FINALLY implemented, merged for inclusion in 2.18.0!!!",
                "source_code": null,
                "distance": 1.25,
                "title": "Allow `@JsonAnySetter` to flow through Creators",
                "name": "issue#562",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4508"
                    },
                    {
                        "start_node": "issue#4508",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#562"
                    }
                ],
                "similarity": 0.19477253923422905,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "5",
                "type": "issue",
                "content": "The current support for key deserializers causes issues when a Map has a key with a type of java.util.Locale.\n\nLocale has a single-argument string constructor that the delegating deserializer calls when it is used as the key for a map. This is not usually the correct constructor. The existing JdkDeserializer support for Locale is re-used in this patch. \n\nA test case is also included, and the javadoc for the method is updated to reflect the addition of locale support.\n\n\n\nComment by cowtowncoder:\nPerfect. One clerical thing I need before merging this in is to get a CLA (https://github.com/FasterXML/jackson-databind/blob/DEV/CLA/contributor-agreement.pdf) filled. It's a standard one-pager, and just needed because many corporations want to know that there is a process to track contributions (specifically, Eclipse foundation verifies these diligently).\nSo if possible, could you fill it in (most devs just list themselves, no company, for what it's worth), and scan and send (or attach it)? (can add to patch, or email me, 'tsaloranta' at gmail).\nApologies for the hassle, but this is a one-time thing to get through.\n\n\nComment by ryangardner:\nNo problem, here's a signed copy of the agreement. Let me know if you need\nanything else.\n\nRyan Gardner\n\nOn Sat, Mar 31, 2012 at 1:10 AM, Tatu Saloranta <\nreply@reply.github.com\n\n> wrote:\n> \n> Perfect. One clerical thing I need before merging this in is to get a CLA (\n> https://github.com/FasterXML/jackson-databind/blob/DEV/CLA/contributor-agreement.pdf)\n> filled. It's a standard one-pager, and just needed because many\n> corporations want to know that there is a process to track contributions\n> (specifically, Eclipse foundation verifies these diligently).\n> So if possible, could you fill it in (most devs just list themselves, no\n> company, for what it's worth), and scan and send (or attach it)? (can add\n> to patch, or email me, 'tsaloranta' at gmail).\n> Apologies for the hassle, but this is a one-time thing to get through.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/FasterXML/jackson-databind/pull/5#issuecomment-4856050\n\n\nComment by cowtowncoder:\nHmmh. I can't see the doc... I think GitHub might drop attachment from replies. :-/\n\n\nComment by ryangardner:\nOh, woops. I'll send it to you directly via gmail.\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Add support for maps with java.util.Locale keys to the set of StdKeyDeserializers",
                "name": "pr#5",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#3846"
                    },
                    {
                        "start_node": "issue#3846",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#5"
                    }
                ],
                "similarity": 0.1775405130438155,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3906",
                "type": "issue",
                "content": "**Describe the bug**\r\nThis code used to work with 2.14.2, but not with 2.15.0\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nRecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n```\r\n\r\n**Version information**\r\n2.15.0\r\n\r\n**To Reproduce**\r\n```java\r\n/**\r\n * This works fine with Jackson 2.14.2, but not with 2.15.0.\r\n */\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    record RecordTest(String string, int integer) {\r\n    }\r\n\r\n    @Test\r\n    public void emptyJsonToRecord() throws JsonProcessingException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n\r\n        mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n        // mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n        RecordTest recordTest_deserialized = mapper.readValue(\"{}\", RecordTest.class);\r\n\r\n\r\n        System.out.println(\"RecordTest deserialized: \" + recordTest_deserialized);\r\n        Assert.assertEquals(new RecordTest(null, 0), recordTest_deserialized);\r\n    }\r\n}\r\n```\r\nComment out the `mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)` and it works.\r\n\r\nNote that the commented-out `mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY)` is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nException is:\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `io.mats3.examples.jbang.Jackson_2_15_0_Regression$RecordTest` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\r\n at [Source: (String)\"{}\"; line: 1, column: 2]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1915)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:414)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1360)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1424)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:352)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:185)\r\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:323)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)\r\n\tat io.mats3.examples.jbang.Jackson_2_15_0_Regression.emptyJsonToRecord(Jackson_2_15_0_Regression.java:25)\r\n```\n\n\nComment by pjfanning:\nSeems to work if you don't change the mapper visibility setting - see #3907. Would it be possible for you to not set this value?\r\n\r\nThis issue will still be investigated. I'm just making the suggestion above as a workaround. I'm no expert on the benefits of setting the visibility to non-default values.\n\nComment by yihtserns:\n## Fix/workaround\r\nAllow visibility for `PropertyAccessor.CREATOR`:\r\n```\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.ANY);\r\n```\r\n\r\n## Explanation\r\nPreviously, Records deserialization is specially handled, resulting in some behavioural differences (mostly missing behaviours) compared to POJO deserialization.\r\n\r\n#3724 was done to address those differences, to close the gap between Records vs POJO de/serialization:\r\n1. This means now, Jackson looks for deserialization \"creators\" for Records the same way it looks for POJO's.\r\n2. `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` \"hides\" those \"creators\", because `PropertyAccessor.ALL` includes `PropertyAccessor.CREATOR`.\n\nComment by yihtserns:\n(Interesting to see the different config used to utilise Jackson as only a deserializer not serializer: here & #3897 \ud83e\udd14.)\n\nComment by stolsvik:\nThanks.\r\n\r\nThis is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records.\r\n\r\nI need this config to work both for 2.14.2 and 2.15. Will that new suggested configuration do that just the same? That is: I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the _data_ transferred. I guess I found that config somewhere sometime, and it have done exactly what I wanted for at least 6 years (used to be just classes, and then it also worked just as expected with records. Nice.)\r\n\r\n(PS: I cannot really \"test if it works\" with an alternate config, as this is a \"foundation lib\", there are at least 50 different random services that depend on this just working as it always has. I just wanted to upgrade to keep with the times! :-) That bit pretty hard, both this, and the 5M char limit for String: https://github.com/FasterXML/jackson-core/issues/863#issuecomment-1531090338 )\r\n\r\n(PPS: The bullet 2 where _\"setVisibility(PropertyAccessor.ALL, Visibility.NONE) \"hides\" those \"creators\", because PropertyAccessor.ALL includes PropertyAccessor.CREATOR\"_ on the face of it sounds like a clear bug to me. For a record, there is no other proper way to get this thing made, so they should probably not be included? At least not the canonical constructor?)\n\nComment by cowtowncoder:\nOne thing worth noting: Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side. Especially regarding access to Record Fields; something that will start failing on newer JDKs. It is not certain handling can be fully unified.\r\n\r\nI agree that it is important to be able to have value types, handling that works for both 2.14 and 2.15. But we really did not realize that there was Record usage that relied on explicit Visibility settings -- there's no testing so one can view at as unsupported use case, technically.\r\nAssumption rather was that usage wrt Records would use default visibility settings.\r\n\n\nComment by stolsvik:\n@cowtowncoder Thanks!\r\n\r\n> Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n\r\nyes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\n> Assumption rather was that usage wrt Records would use default visibility settings.\r\n\r\nThis is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\n\nComment by cowtowncoder:\n> > Records are technically very different from POJOs/Beans, so there are challenges from Jackson implementation side.\r\n> \r\n> yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\r\n\r\nRight... and which is why code originally was separate.\r\n\r\nI had plans to rewrite Introspection of POJOs, Records, but didn't have time so others had a chance to try out alternatives here.\r\n\r\n> > Assumption rather was that usage wrt Records would use default visibility settings.\r\n> \r\n> This is really not the point: The point is that I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. I feel it makes little sense to have to handle this differently? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\nSorry, I did not mean that as a justification for breaking things: but rather explanation of why this use case was not covered by tests. I understand it was used as a way to unify handling with 2.14 when there was no other way.\r\nI agree in that the same `ObjectMapper` should be usable.\r\n\r\nI'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?) and I think there's a way to change them separately as well. I just do not remember details.\r\n\r\n**EDIT**: I think I got confused with above: visibility checker defaults had to do with different defaults for JDK types, where we do NOT want to detect fields. Records (outside of JDK packages) not affected by that.\r\n\r\n\n\nComment by yihtserns:\n> This is used both for serialization and deserialization. It was the deserialization that failed - here the \"assert that this will actually work with an empty {} object\" boot-up verification - and it only failed with records...\r\n> ...I want ONLY fields evaluated, with any visibility, for both classes and records. No methods whatsoever. These are DTOs, if people slap methods on it, I don't care: I want the data transferred.\r\n\r\nTest result for `setVisibility(PropertyAccessor.ALL, Visibility.NONE)` with `2.14.2`:\r\n\r\n| Mechanism (without annotations) | Serialization | Deserialization with non-empty JSON object | Deserialization with empty JSON object |\r\n|---|---|---|---|\r\n| No-arg constructor with getters & setters | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"0 known properties\" | \u2714 Successful: created empty instance |\r\n| Constructor creator | \u274c Failed: \"no properties discovered to create BeanSerializer\" | \u274c Failed: \"no Creators exist\" | \u274c Failed: \"no Creators exist\"\r\n| Record class | \u274c Empty JSON Object | \u2714 Successful: created instance using the JSON fields | \u2714 Successful: created instance using default values |\r\n\r\nThe only way the failing tests above can work is when `@JsonCreator`/`@ConstructorProperties` & `@JsonProperty` annotations are used on the constructor & fields, respectively.  @stolsvik is that what was done in your codebase?\n\nComment by yihtserns:\n> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n> I think there's a way to change them separately as well...\r\n\r\nThe only way I know is this:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n### Alternatives\r\n1. Annotate the override directly on the Records:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n2. Annotate `@JsonCreator` on the canonical compact constructor:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n> I want to use the same ObjectMapper no matter what my users are choosing: POJOs (as they have for 8 years), or records (the new kid). There is thus a jumble of some POJOs here, and some records there, people now also migrating due to the extreme terse-ness and nice-ness of records. **I feel it makes little sense to have to handle this differently**? How should I even do that? A POJO could have a record inside it, and other way around.\r\n\r\n...which was the whole point of #3724's \"jamming records and POJOs into the same regime\", so that using Records is no (or not much) different from using POJO - the issue you're facing now is because Records & POJOs are handled similarly...\n\nComment by yihtserns:\n>> I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n\r\n>[3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n\r\n@cowtowncoder Do you think we should copy that to `2.15`?  E.g.:\r\n```\r\npublic abstract class MapperConfigBase ... {\r\n    ...\r\n    public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n        ...\r\n        if (ClassUtil.isJDKClass(baseType)) {\r\n            vc = VisibilityChecker.Std.allPublicInstance();\r\n        } else if (baseType.isRecord()) {\r\n            // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n            // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n            // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n\r\n            vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n        } else {\r\n            vc = getDefaultVisibilityChecker();\r\n        }\r\n        ...\r\n    }\r\n}\r\n```\n\nComment by stolsvik:\n@yihtserns:\r\n> is that what was done in your codebase?\r\n\r\nNo, as I said at top, I have both of:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\nThe full init is:\r\n```java\r\nObjectMapper mapper = new ObjectMapper();\r\n\r\n// Read and write any access modifier fields (e.g. private)\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n\r\n// Drop nulls\r\nmapper.setSerializationInclusion(Include.NON_NULL);\r\n\r\n// If props are in JSON that aren't in Java DTO, do not fail.\r\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n\r\n// Write e.g. Dates as \"1975-03-11\" instead of timestamp, and instead of array-of-ints [1975, 3, 11].\r\n// Uses ISO8601 with milliseconds and timezone (if present).\r\nmapper.registerModule(new JavaTimeModule());\r\nmapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\r\n\r\n// Handle Optional, OptionalLong, OptionalDouble\r\nmapper.registerModule(new Jdk8Module());\r\n```\r\nIt is here: https://github.com/centiservice/mats3/blob/main/mats-serial-json/src/main/java/io/mats3/serial/json/MatsSerializerJson.java#L120-L152 - now also with the attempt at handling the 5M chars-in-String limit.\r\n\r\n**Note: I had accepted that I always need a no-args constructor** (as opposed to GSON). (Note: If it is possible to support missing no-args constructor for a class, even with Java 17+, that would be *excellent*!)\r\n\r\n> the issue you're facing now is because Records & POJOs are handled similarly...\r\n\r\nExactly. Which is why I said: _\"yes, I agree, which makes me wonder a bit about this plan of jamming records and POJOs into the same regime, as seems suggested by @yihtserns?\"_\r\n\r\nMy point is that the construction of a Record and of a Class, and their population of fields, are rather different, so it sounds .. ambitious .. to do it with the same codebase/flow? Note, I do not try to dictate anything here, it is just an observation. But it would be nice if this - as seen from my side - _regression_ - was not present!\n\nComment by yihtserns:\n> No, as I said at top, I had both of:\r\n> ```\r\n> ObjectMapper mapper = new ObjectMapper();\r\n> mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\n> mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n> ```\r\n\r\nOK, was confused because it was commented out in the sample code.\r\n\r\nThat means you might actually have 2 problems:\r\n1. This issue for Records deserialization.\r\n2. #3895 for Records serialization.\n\nComment by stolsvik:\nYes, but I tried to mention:\r\n> Note that the commented-out mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY) is included in my actual code to get intended behaviour (i.e. only fields are serialized and deserialized, no methods involved), but this did not make any to or from for the problem.\r\n\r\nIt was an attempt to reduce the problem to the bare minimum.\n\nComment by yihtserns:\nTo summarize, there are 2 things broken when using this config:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\n```\r\n\r\n## 1. For Records deserialization\r\nCaused by #3724 to make Records de/serialization behaves just like POJO de/serialization - it sees:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n...similarly to:\r\n```\r\npublic class RecordTest {\r\n    private String string;\r\n    private int integer;\r\n\r\n    @ConstructorProperties({\"string\", \"integer\"})\r\n    public RecordTest(String string, int integer) {\r\n        this.string = string;\r\n        this.integer = integer\r\n    }\r\n\r\n    public String getString() {\r\n        return this.string;\r\n    }\r\n\r\n    public String getInteger() {\r\n        return this.integer;\r\n    }\r\n}\r\n```\r\n### Fixes/workarounds\r\n1. Make all classes' constructor/factory method Creators visible:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\r\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\r\nmapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NON_PRIVATE);\r\n```\r\n2. Make only Records' constructor/factory method Creators visible:\r\n```\r\nobjectMapper.registerModule(new SimpleModule() {\r\n    @Override\r\n    public void setupModule(SetupContext context) {\r\n        super.setupModule(context);\r\n        context.insertAnnotationIntrospector(new NopAnnotationIntrospector() {\r\n            @Override\r\n            public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n                return ac.getType().isRecordType()\r\n                        ? checker.withCreatorVisibility(JsonAutoDetect.Visibility.NON_PRIVATE)\r\n                        : checker;\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n3. Override visibility directly on the Record class:\r\n```\r\n@JsonAutoDetect(creatorVisibility = Visibility.NON_PRIVATE)\r\nrecord RecordTest(String string, int integer) {\r\n}\r\n```\r\n4. Override visibility of constructor Creator directly in the Record class:\r\n```\r\nrecord RecordTest(String string, int integer) {\r\n    @JsonCreator\r\n    RecordTest {\r\n    }\r\n}\r\n```\r\n\r\n## 2. For Records serialization\r\nBroken by #3737 - Records serialization will always result in empty JSON hash (i.e. `{}`).\r\n\r\n#3894 to fix that is pending review.\n\nComment by yihtserns:\nAs for [changing Jackson to make Records' creators always visibility regardless of config](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532803630), I can/will create a PR if the core maintainers think that's the way to go.\n\nComment by stolsvik:\n=1. Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\n1.: Will this work identical for 2.14 and 2.15?  Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a _creator_, if this is what we're talking about?)\r\n2.: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which _might_ have a bunch of constructors that I do not want the serialization to touch?\r\n3. and 3. is utterly out of the question. _(I .. well .. despise ... implementation-specific annotations for serialization. The serialization used for this Mats3 library should be completely opaque to the user, the use of Jackson is literally an implementation detail which should never be thought about. Provide the Request and Reply DTOs, and I will make them \"magically\" transported. I would rather put in code that refused to start if there was any sign of such annotations present)_\r\n\r\nHowever, I can't shake the feeling that this is a pretty clear regression.\r\n\r\n=2:\r\nGood, thanks!\n\nComment by pjfanning:\n@yihtserns thanks for looking at this this. Let's not rush things. We will need to tackle one problem at a time. Maybe getting #3894 progressed is the first priority. @stolsvik will just have to be patient while we resolve the issues. Please stick with Jackson 2.14 in the interim - or try another library, if you prefer.\n\nComment by stolsvik:\nWell, I pretty obviously prefer Jackson, as otherwise I would probably not try to report this.\n\nComment by yihtserns:\n> Do you mean that this won't be solved \"natively\"? I must change the code?\r\n\r\nNeed to wait for the [core maintainers to make the final decision](https://github.com/FasterXML/jackson-databind/issues/3906#issuecomment-1532869817).\r\n\r\n> 1: Will this work identical for 2.14 and 2.15? Why the Visibility.NON_PRIVATE? I want the no-args to be private if it needs be there. (Just curious: Why is a constructor called a creator, if this is what we're talking about?)\r\n\r\nCreators are constructors or factory methods (with name `valueOf`) that have parameters, that will be used for deserialization - they are typically either annotated with `@JsonCreator` or \"magically\" chosen.\r\n\r\nThey are not related to, and nor will that config affects no-arg constructor.\r\n\r\n> 2: Hmmm.. This needs to be different between 2.14 and 2.15? How will this affect standard class-based POJO DTOs, which might have a bunch of constructors that I do not want the serialization to touch?\r\n\r\nYou can use this with both `2.14` & `2.15`, but it basically does nothing for `2.14` (because again, deserialization was implemented differently).  This is basically like number 1, except it only targets Record classes:\r\n```\r\nreturn ac.getType().isRecordType()                          // if we're deserializing Record class...\r\n    ? checker.withCreatorVisibility(Visibility.NON_PRIVATE) // ...make the Creators visible\r\n    : checker;                                              // ...leave the visibility as NONE for POJO types\r\n```\n\nComment by cowtowncoder:\n> > > I'd have to dig up where it was done, but the visibility checker defaults were forked for 2.15 (or was it 2.14 already?)...\r\n> \r\n> > [3.x](https://github.com/FasterXML/jackson-databind/blob/930528637b3fdc51ed0499513e9580f21cef5e34/src/main/java/tools/jackson/databind/cfg/MapperConfigBase.java#L617)\r\n> \r\n> @cowtowncoder Do you think we should copy that to `2.15`? E.g.:\r\n> \r\n> ```\r\n> public abstract class MapperConfigBase ... {\r\n>     ...\r\n>     public final VisibilityChecker<?> getDefaultVisibilityChecker(Class<?> baseType, AnnotatedClass actualClass) {\r\n>         ...\r\n>         if (ClassUtil.isJDKClass(baseType)) {\r\n>             vc = VisibilityChecker.Std.allPublicInstance();\r\n>         } else if (baseType.isRecord()) {\r\n>             // For Records, ignore any config that hides constructor & factory method creators e.g. via\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE)\r\n>             // - ObjectMapper.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE)\r\n>             // - ObjectMapper.disable(MapperFeature.AUTO_DETECT_CREATORS)\r\n> \r\n>             vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);\r\n>         } else {\r\n>             vc = getDefaultVisibilityChecker();\r\n>         }\r\n>         ...\r\n>     }\r\n> }\r\n> ```\r\n\r\nHmmmh. I am bit hesitant wrt overriding users' explicit settings but it does make some sense -- esp. since that's in 3.0.\r\nThe main question would be whether to do that in 2.15.1 or 2.16(.0).\r\nIf (and only if) this would resolve issues we face wrt 2.14->2.15 changes, I'd say let's do it for 2.15(.1).\r\nAlso requires making sure we have good test coverage.\n\nComment by cowtowncoder:\nI merged #3894 fwtw; shouldn't (I think) affect this issue but just in case.\n\nComment by stolsvik:\nJust a comment from the side:\r\n\r\n>  I am bit hesitant wrt overriding users' explicit settings but it does make some sense\r\n\r\nI agree to the general idea that this seems just wrong, but somehow you need to get to those constructors to actually be able to make records! Another way could be a special-case \"if\" when about to create a record, that _effectively_ ignored the setting by just finding the canonical constructor in spite of the setting. However, you would at least not just \"overwrite\" the user-set setting?!\n\nComment by cowtowncoder:\n@stolsvik Yeah this is the challenge in using same logic, handling as with POJOs, when rules are bit different (Records having clear, well-defined rules of what constitutes canonical Constructor, what properties exist).\r\nI'll get #3910 merged and we'll see how far we might get.\r\n\r\n@yihtserns I think we should go with the patch you suggest to unblock remaining issues.\r\n\n\nComment by stolsvik:\nNote: I had to adjust the suggestion a bit to get the \"only adjust visibility for records\" to work: The `ac.getType()` could apparently return null.\r\n\r\n```java\r\npublic VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\r\n    if (ac.getType() == null) {\r\n        return checker;\r\n    }\r\n    if (!ac.getType().isRecordType()) {\r\n        return checker;\r\n    }\r\n    // If this is a Record, then increase the \"creator\" visibility again\r\n    return checker.withCreatorVisibility(Visibility.ANY);\r\n}\r\n```\n\nComment by stolsvik:\nAnother comment from the side: I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the NON_PRIVATE part. If I understand this correctly, it would then not find a private record with private constructor? (Visibility of a record's canonical constructor cannot be less than visibility of the record itself - but a record can be private?)\n\nComment by yihtserns:\n> ...a record can be private?\r\n\r\nYes:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private record RecordTest(String string, int integer) {\r\n    }\r\n}\r\n```\r\n...will be compiled into:\r\n```\r\npublic class Jackson_2_15_0_Regression {\r\n\r\n    private static record RecordTest(String string, int integer) {\r\n        private RecordTest(String string, int integer) {\r\n            this.string = string;\r\n            this.integer = integer;    \r\n        }\r\n\r\n        public String string() {\r\n            return this.string;\r\n        }\r\n\r\n        public String integer() {\r\n            return this.integer;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> ...I still don't get why the patch suggest `vc = getDefaultVisibilityChecker().withCreatorVisibility(Visibility.NON_PRIVATE);`, i.e. the `NON_PRIVATE` part...\r\n\r\nI just copied that directly from 3.x codebase.  In hindsight, I should've changed that to `Visibility.ANY` to make it simple (and practical).  \ud83d\ude1e\n\nComment by cowtowncoder:\nI do not remember details here, but it is possible the idea was to avoid exposing `private` constructors, thinking that they are private for reason (but that there are other non-private constructors). For regular POJOs only public constructors are auto-detected; although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?) and other constructors (use configured visibility) would make most sense.\r\nBut once that runs counter to trying to make Records work just like POJOs.\r\n\n\nComment by stolsvik:\n> .. although for Records I think that separate rule for canonical constructor (to be found regardless of visibility?)\r\n\r\nTotally agree. You need to create an instance. That I have chosen to make this DTO-record an inner private entity of whatever service class it resides in, shouldn't make any difference.\n\nComment by cowtowncoder:\n@yihtserns I think fix you suggested would be doable (just need to change check to use `ClassUtil.isRecordType(baseType)` since `Class.isRecord()` is not available on JDK 8).\r\nI think I'll create a PR.\n\nComment by cowtowncoder:\nNote: need to figure out what (if anything) to do with 3.0 (master); 2 failing tests left.\r\nThis due to `MapperFeature.AUTO_DETECT_CREATORS` being removed so specific workaround cannot be used.\r\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Regression: 2.15.0 breaks deserialization for records when mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);",
                "name": "issue#3906",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4452"
                    },
                    {
                        "start_node": "issue#4452",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3906"
                    }
                ],
                "similarity": 0.17691910033065084,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "583",
                "type": "issue",
                "content": "It does not reflect the latest version of the library. Examples might be outdated.\n\n\n\nComment by cowtowncoder:\nPull Requests welcome...\n\n\nComment by johnjohndoe:\nI can update the version number in the `README.md`. But I feel not competent enough to update the code example to reflect possible API updates.\n",
                "source_code": null,
                "distance": 0.75,
                "title": "Update README.md",
                "name": "issue#583",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#2992"
                    },
                    {
                        "start_node": "issue#2992",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#583"
                    }
                ],
                "similarity": 0.17360401609321224,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "2",
                "type": "issue",
                "content": "\n\n\nComment by tatu-at-salesforce:\nLet me read this with thought tonight (I have bit of free time), so I should be able to integrate it ASAP. Thanks!\n\n\nComment by cowtowncoder:\nOk, didnt get to read it then, but to make 100% sure I don't forget, created [http://jira.codehaus.org/browse/JACKSON-800], and will get this done for 2.0.0-RC2.\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Added deserialization problem handler config registration from module",
                "name": "pr#2",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    },
                    {
                        "start_node": "issue#4119",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#2"
                    }
                ],
                "similarity": 0.16415033368476853,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4396",
                "type": "issue",
                "content": "(For after **Property Introspection Rewrite**)\r\n\r\nThis PR resolves... \r\n\r\n1.. #4388 \r\n2.. part of #2592\r\n    - AnyGetter with JsonInclude + JsonFilter combo\r\n   \r\n### Modifications \r\n\r\nThis PR basically...\r\n\r\n- Starts to handle Any-Getter property as regular property (for serialization only).\r\n- Makes `AnyGetterWriter` extend `BeanPropertyWriter`.\r\n\r\n### notes\r\n\r\n1. If and only if direction is not off.... will clean up and refactor. Solution currently seems a bit of refactoring.\r\n2. This might allow \"ordering\" and \"ignoring\" within AnyGetter prop (I haven't found time to check yet tho)\r\n3. Change might be to big that maybe\r\n\r\n\n\n\nComment by cowtowncoder:\nOne quick note: I think ordering _within_ \"any-getter\" group can be out of scope as users can use specific `Map`s to enforce iteration order, and since it is probably more important to be able to locate group itself.\r\nBut I think that's what is being done here, just mentioning it.\r\n\r\nOtherwise, I'll have to read this couple of times. I guess it would make sense to try to make any-getter placeholder work similar to \"simple\" properties, so sorting works. But I wonder if there are complications wrt attempts to link/unlink, as well as ignoral. This because formerly \"name\" of any-getter hasn't had any effect and could not have accidentally ignored (for example) by a regular property with same name having `@JsonIgnore`.\r\n\n\nComment by JooHyukKim:\n> But I wonder if there are complications wrt attempts to link/unlink, as well as ignoral. This because formerly \"name\" of any-getter hasn't had any effect and could not have accidentally ignored (for example) by a regular property with same name having `@JsonIgnore`.\r\n\r\nValid point with respect to `@JsonIgnore` and stuff, so I added tests...\r\n\r\n- On working `@JsonIgnore` and `@JsonIgnoreProperties` via https://github.com/FasterXML/jackson-databind/pull/4396/commits/78eb9d59f5590586979568aa251c12ed2649cf0e. \r\n- On `@JsonPropertyOrder` explicitly on any-getter property works via https://github.com/FasterXML/jackson-databind/pull/4396/commits/8305a0b6e6ecc99995c30af37049152bce966370\r\n\r\nCould you explain a bit more on **link/unlink**?\n\nComment by cowtowncoder:\nLink/unlink: different getter/setter methods, fields, get \"linked\" if they have same logical name, either implicit (default) or explicit (rename), into a single logical property.\r\nSo if such name that an any-getter happens to have matches a regular property, regular property might be annotated with `@JsonIgnore` (or maybe any-getter) -- and so the whole property is ignored (none of accessors used).\r\n\r\nSo all I am wondering is if there was a case like:\r\n\r\n```\r\nclass Stuff {\r\n  @JsonAnyGetter\r\n  Map<String, Object> metadata;\r\n\r\n  @JsonIgnore\r\n  public String getMetadata() { // unrelated to any-setter\r\n     ...\r\n  }\r\n}\r\n\r\n```\r\n\r\nwhere any-setter would be ignored due to name match. Or something similar related to accidentally matching names.\r\n\r\n\r\n\n\nComment by JooHyukKim:\nFortunately, seems to work wrt link/unlink-ed properties \ud83d\udc4d\ud83c\udffc. Added more tests via https://github.com/FasterXML/jackson-databind/pull/4396/commits/85ae52e277bf64b813c90d7fc54869f544ca3b24.\n\nComment by JooHyukKim:\nWould this still be considered for 2.18, @cowtowncoder? \n\nComment by cowtowncoder:\n@JooHyukKim potentially yes.",
                "source_code": null,
                "distance": 1.25,
                "title": "Allow using `@JsonPropertyOrder` with any-property (`@JsonAnyGetter`) ",
                "name": "pr#4396",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4366"
                    },
                    {
                        "start_node": "pr#4366",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4396"
                    }
                ],
                "similarity": 0.16120953256522463,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4546",
                "type": "issue",
                "content": "\n\n\nComment by cowtowncoder:\nClose in favor of #4547.",
                "source_code": null,
                "distance": 0.75,
                "title": "Try to merge #4515 into master -- some issues to resolve",
                "name": "pr#4546",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "pr#4546"
                    }
                ],
                "similarity": 0.142407799178963,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "18",
                "type": "issue",
                "content": "Would it be possible to make JsonNode `java.io.Serializable`?\n\n\n\nComment by cowtowncoder:\nI'll have to think about this. In theory, probably. Someone would just need to go ahead and test that it all actually works.\nI would not make it serialize as JSON, but just using standard method, which means that it'd be necessary to mark fields as transient (etc) as appropriate.\n\nOne possible problem is that of reference to `JsonNodeFactory`, which may be problematic (or possibly not).\n\nSo I guess I would accept contributions for such feature, yes.\n\n\nComment by jakajancar:\nWhy wouldn't you make is serialize to JSON, given that it's faster, more compact, etc.?\n\n\nComment by cowtowncoder:\nOne problem is that there isn't enough contextual information (no ObjectMapper). I guess one could just use default settings to overcome that; but a JsonFactory is still needed. And it would be wasteful and slow to construct one for one time serialization. For that it would be possible to perhaps use Weak- or SoftReference cached copy.\n\nSo I am open to contibutions as long as they work well and are clean -- you may try to do JSON back serialization if you want. That would most likely use Externalizable interface.\n\n\nComment by tryabin:\nIs it possible to create a class that extends ObjectNode and implements Serializable to have a JsonNode-like class that supports Serializable functionality?\n\n\nComment by cowtowncoder:\nDepending on what you are trying to achieve, it's probably better to just use aggregation: create your own class, have ObjectNode as member, do it that way.\n\nUsing Jackson for replacing JDK serialization, this might be useful: http://www.cowtowncoder.com/blog/archives/2012/08/entry_477.html\n\n\nComment by tryabin:\nIf I used aggregation would I have to create readObject and writeObject methods in order to serialize and de-serialize the ObjectNode member?\n\n\nComment by cowtowncoder:\nYes, the root object would need to implement Externalizable, and from that point you can use custom serialization/deserialization, such as just using JSON output.\n\n\nComment by cowtowncoder:\nI don't think I will work on this -- if anybody else wants to tackle it, feel free to re-open, but only if you actually work on it (not just wish to do that).\n\n\nComment by jwgmeligmeyling:\nI'd love to see this feature and would be willing to pick it up.\r\n\r\nFrom this thread there seem to be two options:\r\n\r\n- Implement it as `java.io.Serializable`, mark the `JsonNodeFactory` as `transient`, and possibly define a `readObject` that instantiates this   `JsonNodeFactory` with a default instance.\r\n- Implement it as `java.io.Externalizable`, using the JSON representation as data.  Use a default JsonNodeFactory here as well?\r\n\r\nI have two questions:\r\n1) Does `JsonNode` still depend on the `JsonNodeFactory` in the current situation?\r\n2) Wouldn't it be an option to serialize the `JsonNodeFactory` with the `JsonNode`?\r\n\r\n\r\nBTW, I think commit 92223fe is wrongly pointed to this issue #18 , perhaps it references an issue from core?\n\nComment by cowtowncoder:\n@JWGmeligMeyling ok. Just a quick question: what is the use case you are thinking of?\r\n\r\nOn implementation itself: this would be a bit easier with Jackson 3.0 because of #2176.\r\nThat would solve a few issues... \r\n\r\nBut if you really want to work on this for 2.10, I am ok with it. I'd probably just go with throw-away `JsonFactory`, if possible; otherwise code must create default `ObjectMapper` and that's guaranteed to make this rather wasteful operation.\r\n\r\n\r\n\n\nComment by jwgmeligmeyling:\nMy JPA entities need to be serializable in order for my EntityManager to passivate into a stateful session bean. Some of my entities map a JsonNode from JSONB columns, if the data type foe the JSON input is not fixed for that entity. Now I\u2019m required to implement custom serialization for all entity classes that reference such a JsonNode. Even more tedious is that I cant call defaultSerialization in my custom serializer, because transient fields will always be ignored by JPA and there is apparently no way to work around that. So for JPA entities that means you have to manually searialize/deserialize every field which is tedious and error prone. So Id rather make JsonNode serializable in one way or another :)\n\nComment by demetrio812:\nHello, same problem for me, I'm trying to use EhCache with some Entities containing JsonNode and it's not working because of this issue\n\nComment by cowtowncoder:\nActually. Now with 2.10 and #2187 I wonder... \r\n\r\nThere would be some limitations, of course:\r\n\r\n1. Only `json` would be supported as serialization format (but it's JDK serialization so no one sees it anyway)\r\n2. On deserialization, no configuration of `JsonNode` (via custom `JsonNodeFactory`, or, in future, with `NodeConfig` or such) could be applied; you would get stock vanilla `JsonNode` back\r\n3. `POJONode` would probably lose its identity (although maybe not...)\r\n\r\nSo... I'll re-consider this issue.\r\n\r\n\r\n\r\n\n\nComment by demetrio812:\nHello @cowtowncoder thanks for reconsidering, I think the limitations are fine and understandable but this basic support will help a lot for use cases like the caching one.\r\n\r\nThanks,\r\nDem",
                "source_code": null,
                "distance": 1.0,
                "title": "Make `JsonNode` serializable?",
                "name": "issue#18",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#806"
                    },
                    {
                        "start_node": "issue#806",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#18"
                    }
                ],
                "similarity": 0.14161202630700137,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1",
                "type": "issue",
                "content": "I'm struggling with a problem that is probably common for people that extensively use @JsonView. Since only one view can be active at any one time, and jsonview classes are singly-inherited, the facility is very tightly constrained. There are a lot of cases where I need to define multiple views: \"Show me the properties relevant to green administrators and the fields relevant to blue administrators\", where these are not perfect subsets.\n\nFrom an API perspective, one solution would be to allow json views to be defined by interfaces and thus enable multiple inheritance. Alternatively, just allow multiple views to be specified - although this raises the question of AND vs OR.\n\nThis has been moved from https://github.com/FasterXML/jackson-core/issues/3\n\n\n\nComment by cowtowncoder:\nForgot to add a comment: interfaces can be used to represent views just fine already (since beginning), and the reason is exactly the ability to compose more complicated view definitions. So at least that part should already work, if I understand request correctly.\n\n\nComment by cowtowncoder:\nNot sure if there is anything to do here: one can use interfaces as JsonView values already.\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Improve @JsonView flexibility",
                "name": "issue#1",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    },
                    {
                        "start_node": "issue#4119",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1"
                    }
                ],
                "similarity": 0.1308357045493273,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "67",
                "type": "issue",
                "content": "For more details see [issue#65](https://github.com/FasterXML/jackson-databind/issues/65).\n\n\n",
                "source_code": null,
                "distance": 1.0,
                "title": "Added getters (issue#65)",
                "name": "pr#67",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#806"
                    },
                    {
                        "start_node": "issue#806",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#67"
                    }
                ],
                "similarity": 0.12620513686583787,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "4477",
                "type": "issue",
                "content": "reproduces #4452\n\n",
                "source_code": null,
                "distance": 1.25,
                "title": "Add failing test #4452",
                "name": "pr#4477",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4452"
                    },
                    {
                        "start_node": "issue#4452",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4477"
                    }
                ],
                "similarity": 0.11925338023875269,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "1890",
                "type": "issue",
                "content": "hi\r\nI can't well english. please your understand.\r\n\r\nuntil 2.9.0 successful. but fail from 2.9.1.\r\n2.9.3 will still fail\r\nHas changed spec for access option in JsonProperty? or bug?\r\nI attach test code\r\n\r\nTest Class\r\n```\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\n\r\nimport static org.hamcrest.CoreMatchers.is;\r\nimport static org.hamcrest.CoreMatchers.nullValue;\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\n\r\npublic class DeserializeTest {\r\n    private ObjectMapper objectMapper;\r\n\r\n    @Before\r\n    public void setUp(){\r\n        this.objectMapper = new ObjectMapper();\r\n    }\r\n\r\n    @Test\r\n    public void test() throws IOException {\r\n        String json = \"{\\\"pubtrans\\\":\\\"\\\",\\\"name\\\":\\\"changyong\\\"}\";\r\n\r\n        TestClass result = this.objectMapper.readValue(json, TestClass.class);\r\n\r\n        // jackson 2.9.0 is success, 2.9.1~2.9.3 is fail\r\n        assertThat(result.getPubtrans(), is(nullValue()));\r\n    }\r\n\r\n    @Data\r\n    @AllArgsConstructor\r\n    @NoArgsConstructor\r\n    public static class TestClass{\r\n        @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n        private Pubtrans pubtrans;\r\n        private String name;\r\n    }\r\n\r\n    enum Pubtrans{\r\n        SUBWAY, BUS\r\n    }\r\n}\r\n```\n\n\nComment by cowtowncoder:\n@LichKing-lee It seems like you may be using Lombok library. Because of this, it is not possible for me to know what happens exactly -- Lombok modifies bytecode in certain ways, adding annotations, constructors and so on.\r\n\r\nIf you can reproduce the problem without Lombok, I can help, but with Lombok issues you will have to reach out to Lombok team or issue tracker.\r\nI do not take Lombok based tests because use of Lombok requires additions to classpath and can not be added simply by adding dependency in Maven definitions.\r\n\r\n\n\nComment by LichKing-lee:\n@cowtowncoder \r\nI tested without lombok, i found a few case.\r\n\r\ncase1. 2.8.10/2.9.3 all success\r\n* TestClass has only one enum field\r\n* Json pubtrans field is empty string\r\n```\r\npublic class DeserializeTest {\r\n    private ObjectMapper objectMapper;\r\n\r\n    @Before\r\n    public void setUp(){\r\n        this.objectMapper = new ObjectMapper();\r\n    }\r\n\r\n    @Test\r\n    public void test() throws IOException {\r\n        String json = \"{\\\"pubtrans\\\":\\\"\\\"}\";\r\n\r\n        TestClass result = this.objectMapper.readValue(json, TestClass.class);\r\n\r\n        assertThat(result.getPubtrans(), is(nullValue()));\r\n    }\r\n\r\n    public static class TestClass{\r\n        @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n        private Pubtrans pubtrans;\r\n\r\n        public TestClass(){\r\n\r\n        }\r\n\r\n        public TestClass(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n\r\n        public Pubtrans getPubtrans() {\r\n            return pubtrans;\r\n        }\r\n\r\n        public void setPubtrans(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n    }\r\n\r\n    enum Pubtrans{\r\n        SUBWAY, BUS\r\n    }\r\n}\r\n```\r\n\r\ncase2. 2.8.10/2.9.3 all fail\r\n* TestClass has only one enum field\r\n* Json pubtrans field is empty string\r\n* Diff is add ConstructorProperties annotation\r\n```\r\npublic class DeserializeTest {\r\n    private ObjectMapper objectMapper;\r\n\r\n    @Before\r\n    public void setUp(){\r\n        this.objectMapper = new ObjectMapper();\r\n    }\r\n\r\n    @Test\r\n    public void test() throws IOException {\r\n        String json = \"{\\\"pubtrans\\\":\\\"\\\"}\";\r\n\r\n        TestClass result = this.objectMapper.readValue(json, TestClass.class);\r\n\r\n        Assert.assertThat(result.getPubtrans(), is(nullValue()));\r\n    }\r\n\r\n    public static class TestClass{\r\n        @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n        private Pubtrans pubtrans;\r\n\r\n        public TestClass(){\r\n\r\n        }\r\n\r\n        // Only different\r\n        @ConstructorProperties(\"pubtrans\")\r\n        public TestClass(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n\r\n        public Pubtrans getPubtrans() {\r\n            return pubtrans;\r\n        }\r\n\r\n        public void setPubtrans(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n    }\r\n\r\n    enum Pubtrans{\r\n        SUBWAY, BUS\r\n    }\r\n}\r\n```\r\n\r\ncase3. 2.8.10 is success. 2.9.3 is fail\r\n* TestClass has one enum field, one String field.\r\n* TestClass has no arg constructor, all arg constructor\r\n* all arg constructor has ConstructorProperties annotation.\r\n* Json pubtrans field is empty string\r\n\r\n```\r\n@Test\r\n    public void test() throws IOException {\r\n        String json = \"{\\\"pubtrans\\\":\\\"\\\",\\\"name\\\":\\\"changyong\\\"}\";\r\n\r\n        TestClass result = this.objectMapper.readValue(json, TestClass.class);\r\n\r\n        assertThat(result.getPubtrans(), is(nullValue()));\r\n    }\r\n\r\n    public static class TestClass{\r\n        @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n        private Pubtrans pubtrans;\r\n        private String name;\r\n\r\n        public TestClass(){\r\n\r\n        }\r\n\r\n        @ConstructorProperties({\"pubtrans\", \"name\"})\r\n        public TestClass(Pubtrans pubtrans, String name) {\r\n            this.pubtrans = pubtrans;\r\n            this.name = name;\r\n        }\r\n\r\n        public Pubtrans getPubtrans() {\r\n            return pubtrans;\r\n        }\r\n\r\n        public void setPubtrans(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n\r\n        public String getName() {\r\n            return name;\r\n        }\r\n\r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    }\r\n```\r\n\r\ncase4. 2.8.10/2.9.3 all success\r\n* all arg constructor remove ConstructorProperties from case3\r\n```\r\n@Test\r\n    public void test() throws IOException {\r\n        String json = \"{\\\"pubtrans\\\":\\\"\\\",\\\"name\\\":\\\"changyong\\\"}\";\r\n\r\n        TestClass result = this.objectMapper.readValue(json, TestClass.class);\r\n\r\n        assertThat(result.getPubtrans(), is(nullValue()));\r\n    }\r\n\r\n    public static class TestClass{\r\n        @JsonProperty(access = JsonProperty.Access.READ_ONLY)\r\n        private Pubtrans pubtrans;\r\n        private String name;\r\n\r\n        public TestClass(){\r\n\r\n        }\r\n\r\n        public TestClass(Pubtrans pubtrans, String name) {\r\n            this.pubtrans = pubtrans;\r\n            this.name = name;\r\n        }\r\n\r\n\r\n        public Pubtrans getPubtrans() {\r\n            return pubtrans;\r\n        }\r\n\r\n        public void setPubtrans(Pubtrans pubtrans) {\r\n            this.pubtrans = pubtrans;\r\n        }\r\n\r\n        public String getName() {\r\n            return name;\r\n        }\r\n\r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    }\r\n```\r\n\r\nI think one field and multiple field are different.\r\nAnd ConstructorProperties annotation has or has not.\r\nplease check.\r\n\r\nthank you\n\nComment by cowtowncoder:\nThank you very much for additional information and fix proposal! I hope to verify it soon.\n\nComment by cowtowncoder:\nTest added, as per merge, but I will try to get fix that does not require extra lookup for every property passed via constructor property, if possible.\r\n\n\nComment by cowtowncoder:\nLooks like `READ_ONLY` is properly detected, added for Creator-property too. Not yet sure why it is still found -- probably since creator property lookup is bit different in property-based approach, so maybe just need to add another pass over those. And then decide how to change behavior (remove entry in secondary lookup, change handler to no-operation).\n\nComment by MonkeyDAntoine:\nHello,\r\n\r\nI tested the DeserializeTest given by @LichKing-lee and it's worked with version 2.9.6.\r\n\r\nBut if I set a value to the JsonProperty :\r\n`@JsonProperty(value = \"pub_trans\",access = JsonProperty.Access.READ_ONLY)`\r\n\r\nand of course change the json in the test :\r\n`String json = \"{\\\"pub_trans\\\":\\\"A\\\",\\\"name\\\":\\\"changyong\\\"}\";`\r\n\r\nThe unit test fails with the exception\r\n`com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"pub_trans\"`\r\n\r\nIt's seems that I cannot combine access and value.\r\nI still found a workaround by adding \r\n  `@JsonIgnoreProperties(value=\"pub_trans\", allowGetters=true)`\r\nat class-level of the TestClass",
                "source_code": null,
                "distance": 1.25,
                "title": "When deserializing, `JsonProperty.Access.READ_ONLY` not working in all cases",
                "name": "issue#1890",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4119"
                    },
                    {
                        "start_node": "issue#4119",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#1890"
                    }
                ],
                "similarity": 0.11845254222851666,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "25",
                "type": "issue",
                "content": "```\nscala> MissingNode.getInstance().asText()\nres12: java.lang.String = \"\"\n\nscala> NullNode.instance.asText()\nres13: java.lang.String = null\n```\n\nIs it expected that MissingNode returns \"\"?\n\n\n\nComment by cowtowncoder:\nSee [http://jira.codehaus.org/browse/JACKSON-775]; it was decided that \"\" makes more sense.\n\n\nComment by jakajancar:\nOk, then the other way around, is it expected that NullNode returns null?\n\nDocs say:\n\n```\nasText() \n      Method that will return a valid String representation of the container value, if the node is a value node (method JsonNode.isValueNode() returns true), otherwise empty String.\n\npublic boolean isValueNode()\nMethod that returns true for all value nodes: ones that are not containers, and that do not represent \"missing\" nodes in the path. Such value nodes represent String, Number, Boolean and null values from JSON.\n```\n\nSo NullNode is a value node. Therefore, asText() should return \"a valid String representation\". I would hardly say null is a valid string representation.\n\n\nComment by cowtowncoder:\nIt's a bit tough call, but I could see why expectation would be to get String \"null\", instead of actual null.\n\nThe practical problem is that at this point existing code must assume null value, so I don't know whether this can be changed. For 2.0 it needs to be documented, at least. And perhaps could be only changed for 3.x.\n\n\nComment by cowtowncoder:\nAnyone reading this issue: if you would prefer to see a String value (most likely either \"\" or \"null\"), please file a new issue with the request for change. Such could be considered for Jackson 3.0.\n",
                "source_code": null,
                "distance": 1.0,
                "title": "asText(): NullNode vs. MissingNode",
                "name": "issue#25",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#806"
                    },
                    {
                        "start_node": "issue#806",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#25"
                    }
                ],
                "similarity": 0.11505058027350701,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "3992",
                "type": "issue",
                "content": "**Describe the bug**\r\nWith v 2.15.x I run into `com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError)`. The code works with 2.14.2\r\n\r\n\r\n**To Reproduce**\r\nRun the unit test below, see comments in the code\r\n\r\n```\r\npackage org.acme.json.error;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonIgnore;\r\nimport com.fasterxml.jackson.annotation.JsonInclude;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.io.Serial;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nclass SerializationTest {\r\n\r\n    private ObjectMapper objectMapper;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        objectMapper = new ObjectMapper();\r\n    }\r\n\r\n    @Test\r\n    public void greeting() throws JsonProcessingException {\r\n        var beanWithRecursion = new Recursion();\r\n        beanWithRecursion.add(beanWithRecursion);\r\n        var gr = new GreetingWithTransientRecursion(\"hello\", beanWithRecursion);\r\n        var json = objectMapper.writer().writeValueAsString(gr);\r\n        System.out.println(json);\r\n    }\r\n\r\n    @Test\r\n    public void hello() throws JsonProcessingException {\r\n        var beanWithRecursion = new Recursion();\r\n        beanWithRecursion.add(beanWithRecursion);\r\n        var hello = new HelloWithoutTransientRecursion(\"hello\", beanWithRecursion);\r\n        var json = objectMapper.writer().writeValueAsString(hello);\r\n        System.out.println(json);\r\n    }\r\n\r\n    @Test\r\n    public void hellorecord() throws JsonProcessingException {\r\n        var beanWithRecursion = new Recursion();\r\n        beanWithRecursion.add(beanWithRecursion);\r\n        var hello = new HelloRecord(\"hello\", beanWithRecursion);\r\n        var json = objectMapper.writer().writeValueAsString(hello);\r\n        System.out.println(json);\r\n    }\r\n\r\n    //works fine as the class but not if converted to record\r\n    @JsonInclude(JsonInclude.Include.NON_NULL)\r\n    public static class HelloWithoutTransientRecursion implements Serializable {\r\n        @Serial\r\n        private static final long serialVersionUID = 1L;\r\n        private final String text;\r\n        @JsonIgnore\r\n        private final Recursion hidden;\r\n\r\n        public HelloWithoutTransientRecursion(String text, Recursion hidden) {\r\n            this.text = text;\r\n            this.hidden = hidden;\r\n        }\r\n\r\n        public String getText() {\r\n            return text;\r\n        }\r\n\r\n        public Recursion getHidden() {\r\n            return hidden;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"GreetingWithTransientRecursion{\" +\r\n                    \"text='\" + text + '\\'' +\r\n                    \", hidden='\" + hidden + '\\'' +\r\n                    '}';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Infinite recursion (StackOverflowError)\r\n     */\r\n    @JsonInclude(JsonInclude.Include.NON_NULL)\r\n    public record HelloRecord(String text, @JsonIgnore Recursion hidden) {\r\n\r\n        /**\r\n         * when the method is not overriden it works\r\n         */\r\n        @Override\r\n        public Recursion hidden() {\r\n            return hidden;\r\n        }\r\n\r\n    }\r\n\r\n    @JsonInclude(JsonInclude.Include.NON_NULL)\r\n    public static final class GreetingWithTransientRecursion implements Serializable {\r\n        @Serial\r\n        private static final long serialVersionUID = 1L;\r\n        private String text;\r\n        @JsonIgnore\r\n        private transient Recursion hidden; //transient keyword causes Infinite recursion (StackOverflowError)\r\n\r\n        public GreetingWithTransientRecursion(String text, Recursion hidden) {\r\n            this.text = text;\r\n            this.hidden = hidden;\r\n        }\r\n\r\n        public void setText(String text) {\r\n            this.text = text;\r\n        }\r\n\r\n        public void setHidden(Recursion hidden) {\r\n            this.hidden = hidden;\r\n        }\r\n\r\n        public String getText() {\r\n            return text;\r\n        }\r\n\r\n        public Recursion getHidden() {\r\n            return hidden;\r\n        }\r\n    }\r\n\r\n    public static class Recursion {\r\n        private final List<Recursion> all = new ArrayList<>();\r\n\r\n        void add(Recursion recursion) {\r\n            all.add(recursion);\r\n        }\r\n\r\n        public List<Recursion> getAll() {\r\n            return all;\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n\nComment by pjfanning:\ncan't you work around it by not doing this?\r\n\r\n```\r\n        /**\r\n         * when the method is not overriden it works\r\n         */\r\n        @Override\r\n        public Recursion hidden() {\r\n            return hidden;\r\n        }\r\n```\r\n\r\nHave you tried add a `@JsonIgnore` to this if you really need this method?\n\nComment by ennishol:\n@pjfanning In general I can change the code, but I thought it worth reporting since it has worked before\n\nComment by cowtowncoder:\nSounds like a bug indeed if `@JsonIgnore` behavior is different here: annotations should be merged in a way to make `@JsonIgnore` work as expected for records as well as POJOs.\r\n\r\nI would recommend using work-around @pjfanning suggests in the mean time.\r\n\r\n\n\nComment by pjfanning:\nException looks like:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError) (through reference chain: java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"]->java.util.ArrayList[0]->com.fasterxml.jackson.databind.failing.RecordDeserialization3992Test$Recursion[\"all\"])\r\n\r\n\tat com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:787)\r\n\tat com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18)\r\n\tat com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:732)\r\n\tat com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:772)\r\n\tat com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79)\r\n\tat com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18)\r\n\tat com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:732)\r\n\tat com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:772)\r\n....\r\n```\r\n\r\nThe Stackoverflow wouldn't happen if https://github.com/FasterXML/jackson-core/pull/1055 is merged (you would get a StreamConstraintsException instead). There is a still the issue of why the JsonIgnore is not working properly.\n\nComment by yihtserns:\nThere are 2 issues here?:\r\n1. Record + `@JsonIgnore` + overridden accessor method for the ignored property\r\n2. Non-record + `@JsonIgnore` + transient field\r\n\r\n2nd issue is same as #3948?\n\nComment by cowtowncoder:\nYeah I wonder if we should try to see if transient Fields removal really needs to happen at a later point, so that `@JsonIgnore` may be contributed.\r\n\r\nAlthough tbh there may be other problems this would cause wrt some users NOT wanting `@JsonIgnore` to be propagated.\r\n\r\nStill, due to existence of `MapperFeature.PROPAGATE_TRANSIENT_MARKER` I'll only consider (1) to be the issue covered here -- that is, `@JsonIgnore` should prevent serialization of a field for Records.\r\n\n\nComment by cowtowncoder:\nI think the question of propagation of `transient` values is key here, covered by #3948; closing this issue.\r\n\n\nComment by cowtowncoder:\nI have proposed fix (#4048) for #3948. Realized I could probably use verification test from here to see if Record handling changed -- I suspect it might not. But will check after merging \"other\" POJO-related fix.\r\n\n\nComment by cowtowncoder:\nLooks @yihtserns is right: case (2) is now resolved (that is, #3948 solved).\r\nI can reproduce the remaining part, (1). Will see if that can be fixed easily.\r\n",
                "source_code": null,
                "distance": 1.25,
                "title": "`@JsonIgnore` on Record property ignored if there is getter override",
                "name": "issue#3992",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4452"
                    },
                    {
                        "start_node": "issue#4452",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#3992"
                    }
                ],
                "similarity": 0.09528944289116426,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "773",
                "type": "issue",
                "content": "So in one of projects I use Spring MVC + Jackson. I annotate my controller method with JsonView annotation. The code looks something like this:\n\n``` java\ninterface BWithAlistView {\n}\n\n@Entity\npublic class A {\n ....\n}\n\n@Entity\npublic class B {\n  ...\n    @JsonView(BWithAlistView.class)\n    @OneToMany    \n    private List<A> alist;\n    public List<A> getAlist() {\n        return alist;\n    }\n    public void setAlist(List<A> alist) {\n        this.alist = alist;\n    }\n}\n\n@Controller\npublic class Controller {\n\n    @JsonView(BWithAlistView.class)\n    @ResponseBody\n    public List<B> getAlist(){\n       //returns arraylist of objects B\n    }\n}\n```\n\nWith this configuration the \"alist\" field from class \"B\" never gets serialized. It was never even included into final json. \nBut when I changed the code to this\n\n``` java\npublic class B {\n  ...\n    private List<A> alist;\n    @JsonView(BWithAlistView.class)\n    public List<A> getAlist() {\n        return alist;\n    }\n    public void setAlist(List<A> alist) {\n        this.alist = alist;\n    }\n}\n```\n\nsuddenly it worked as intended.\n\nI will make the minimal project with maven to demonstrate this behavior if required. \n\n\n\nComment by cowtowncoder:\nJust make sure it is stand-alone and does not use Spring MVC. Handling of `@JsonView` for resource methods is not controlled by databind. It is most likely passed via `ObjectWriter`.\n\n\nComment by cowtowncoder:\nSounds like integration issue wrt Spring MVC, but this is either controlled by Spring.\nClosing; may be re-opened it can be demonstrated using only Jackson components.\n",
                "source_code": null,
                "distance": 1.0,
                "title": "@JsonView is not consistent with Lists?",
                "name": "issue#773",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#4515"
                    },
                    {
                        "start_node": "issue#4515",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4513"
                    },
                    {
                        "start_node": "issue#4513",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#773"
                    }
                ],
                "similarity": 0.051750259092584856,
                "end_line": null,
                "signature": null
            },
            {
                "start_line": null,
                "file_path": null,
                "issue_id": "2929",
                "type": "issue",
                "content": "This makes the code easier for humans to read, and allows the jvm\r\nto optimize more code around method size inlining limits.\r\n\r\nUnsure which branch is the best target for this sort of thing, feel free to\r\nclose out the PR if you'd rather avoid code churn. Just some cleanup\r\nI noticed while contributing in other areas.\n\n\nComment by cowtowncoder:\nOk, curious as to inline limits part? How would that work.\r\n\r\nBut sounds reasonable; partly this is leftover from older versions, when Java 5 compatibility was needed (isEmpty() was added in Java 6) :).\r\nSo happy to merge.\r\n\r\nWould it be easy enough to rebase for 2.12 however? Trying to limit changes for 2.11 -- this is not a risky change by any means, but just as general practice on maintenance branches.\r\n\r\n\n\nComment by carterkozak:\n> Ok, curious as to inline limits part? How would that work.\r\n\r\nThe idea is the jvm will quickly inline and optimize methods that are 35 bytes or fewer (`-XX:MaxInlineSize=35` by default), so more concise code is rewarded. I don't think anything I modified fell below the 35 byte limit, but it's one of those things that allows the code to be simpler so there's not really a downside.\r\n\r\n> Would it be easy enough to rebase for 2.12 however? Trying to limit changes for 2.11 -- this is not a risky change by any means, but just as general practice on maintenance branches.\r\n\r\nOf course, happy to do so.",
                "source_code": null,
                "distance": 1.0,
                "title": "Replace `str.length() == 0` with `str.isEmpty()` where possible",
                "name": "pr#2929",
                "documentation": null,
                "path": [
                    {
                        "start_node": "root",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#4615"
                    },
                    {
                        "start_node": "pr#4615",
                        "description": "referenced by issue",
                        "type": "RELATED",
                        "end_node": "issue#4584"
                    },
                    {
                        "start_node": "issue#4584",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "issue#805"
                    },
                    {
                        "start_node": "issue#805",
                        "description": "points to issue",
                        "type": "RELATED",
                        "end_node": "pr#2929"
                    }
                ],
                "similarity": 0.045860462245519075,
                "end_line": null,
                "signature": null
            }
        ]
    },
    "artifact_stats": {
        "skipped_due_to_time": 43,
        "valid_related_items": 503
    }
}