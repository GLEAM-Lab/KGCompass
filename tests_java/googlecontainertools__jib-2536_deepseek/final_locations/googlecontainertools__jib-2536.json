{
  "related_entities": {
    "methods": [
      {
        "start_line": 59,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    checkJibVersion();\n    if (MojoCommon.shouldSkipJibExecution(this)) {\n      return;\n    }\n\n    // Validates 'format'.\n    if (Arrays.stream(ImageFormat.values()).noneMatch(value -> value.name().equals(getFormat()))) {\n      throw new MojoFailureException(\n          \"<format> parameter is configured with value '\"\n              + getFormat()\n              + \"', but the only valid configuration options are '\"\n              + ImageFormat.Docker\n              + \"' and '\"\n              + ImageFormat.OCI\n              + \"'.\");\n    }\n\n    // Parses 'to' into image reference.\n    if (Strings.isNullOrEmpty(getTargetImage())) {\n      throw new MojoFailureException(\n          HelpfulSuggestions.forToNotConfigured(\n              \"Missing target image parameter\",\n              \"<to><image>\",\n              \"pom.xml\",\n              \"mvn compile jib:build -Dimage=<your image name>\"));\n    }\n\n    MavenSettingsProxyProvider.activateHttpAndHttpsProxies(\n        getSession().getSettings(), getSettingsDecrypter());\n\n    TempDirectoryProvider tempDirectoryProvider = new TempDirectoryProvider();\n    MavenProjectProperties projectProperties =\n        MavenProjectProperties.getForProject(\n            Preconditions.checkNotNull(descriptor),\n            getProject(),\n            getSession(),\n            getLog(),\n            tempDirectoryProvider);\n    Future<Optional<String>> updateCheckFuture =\n        MojoCommon.newUpdateChecker(projectProperties, getLog());\n    try {\n      PluginConfigurationProcessor.createJibBuildRunnerForRegistryImage(\n              new MavenRawConfiguration(this),\n              new MavenSettingsServerCredentials(\n                  getSession().getSettings(), getSettingsDecrypter()),\n              projectProperties,\n              new MavenHelpfulSuggestions(HELPFUL_SUGGESTIONS_PREFIX))\n          .runBuild();\n\n    } catch (InvalidAppRootException ex) {\n      throw new MojoExecutionException(\n          \"<container><appRoot> is not an absolute Unix-style path: \" + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerizingModeException ex) {\n      throw new MojoExecutionException(\n          \"invalid value for <containerizingMode>: \" + ex.getInvalidContainerizingMode(), ex);\n\n    } catch (InvalidWorkingDirectoryException ex) {\n      throw new MojoExecutionException(\n          \"<container><workingDirectory> is not an absolute Unix-style path: \"\n              + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerVolumeException ex) {\n      throw new MojoExecutionException(\n          \"<container><volumes> is not an absolute Unix-style path: \" + ex.getInvalidVolume(), ex);\n\n    } catch (InvalidFilesModificationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><filesModificationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or special keyword \\\"EPOCH_PLUS_SECOND\\\": \"\n              + ex.getInvalidFilesModificationTime(),\n          ex);\n\n    } catch (InvalidCreationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><creationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or a special keyword (\\\"EPOCH\\\", \"\n              + \"\\\"USE_CURRENT_TIMESTAMP\\\"): \"\n              + ex.getInvalidCreationTime(),\n          ex);\n\n    } catch (JibPluginExtensionException ex) {\n      String extensionName = ex.getExtensionClass().getName();\n      throw new MojoExecutionException(\n          \"error running extension '\" + extensionName + \"': \" + ex.getMessage(), ex);\n\n    } catch (IncompatibleBaseImageJavaVersionException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forIncompatibleBaseImageJavaVersionForMaven(\n              ex.getBaseImageMajorJavaVersion(), ex.getProjectMajorJavaVersion()),\n          ex);\n\n    } catch (InvalidImageReferenceException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forInvalidImageReference(ex.getInvalidReference()), ex);\n\n    } catch (IOException | CacheDirectoryCreationException | MainClassInferenceException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex);\n\n    } catch (BuildStepsExecutionException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex.getCause());\n\n    } finally {\n      tempDirectoryProvider.close();\n      MojoCommon.finishUpdateChecker(projectProperties, updateCheckFuture);\n      projectProperties.waitForLoggingThread();\n      getLog().info(\"\");\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.19653328605385506,
        "end_line": 170,
        "signature": "com.google.cloud.tools.jib.maven.BuildImageMojo.execute(): void"
      },
      {
        "start_line": 57,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildDockerMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    checkJibVersion();\n    if (MojoCommon.shouldSkipJibExecution(this)) {\n      return;\n    }\n\n    Path dockerExecutable = getDockerClientExecutable();\n    boolean isDockerInstalled =\n        dockerExecutable == null\n            ? DockerClient.isDefaultDockerInstalled()\n            : DockerClient.isDockerInstalled(dockerExecutable);\n    if (!isDockerInstalled) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forDockerNotInstalled(HELPFUL_SUGGESTIONS_PREFIX));\n    }\n\n    MavenSettingsProxyProvider.activateHttpAndHttpsProxies(\n        getSession().getSettings(), getSettingsDecrypter());\n\n    TempDirectoryProvider tempDirectoryProvider = new TempDirectoryProvider();\n    MavenProjectProperties projectProperties =\n        MavenProjectProperties.getForProject(\n            Preconditions.checkNotNull(descriptor),\n            getProject(),\n            getSession(),\n            getLog(),\n            tempDirectoryProvider);\n    Future<Optional<String>> updateCheckFuture =\n        MojoCommon.newUpdateChecker(projectProperties, getLog());\n    try {\n      PluginConfigurationProcessor.createJibBuildRunnerForDockerDaemonImage(\n              new MavenRawConfiguration(this),\n              new MavenSettingsServerCredentials(\n                  getSession().getSettings(), getSettingsDecrypter()),\n              projectProperties,\n              new MavenHelpfulSuggestions(HELPFUL_SUGGESTIONS_PREFIX))\n          .runBuild();\n\n    } catch (InvalidAppRootException ex) {\n      throw new MojoExecutionException(\n          \"<container><appRoot> is not an absolute Unix-style path: \" + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerizingModeException ex) {\n      throw new MojoExecutionException(\n          \"invalid value for <containerizingMode>: \" + ex.getInvalidContainerizingMode(), ex);\n\n    } catch (InvalidWorkingDirectoryException ex) {\n      throw new MojoExecutionException(\n          \"<container><workingDirectory> is not an absolute Unix-style path: \"\n              + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerVolumeException ex) {\n      throw new MojoExecutionException(\n          \"<container><volumes> is not an absolute Unix-style path: \" + ex.getInvalidVolume(), ex);\n\n    } catch (InvalidFilesModificationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><filesModificationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or special keyword \\\"EPOCH_PLUS_SECOND\\\": \"\n              + ex.getInvalidFilesModificationTime(),\n          ex);\n\n    } catch (InvalidCreationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><creationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or a special keyword (\\\"EPOCH\\\", \"\n              + \"\\\"USE_CURRENT_TIMESTAMP\\\"): \"\n              + ex.getInvalidCreationTime(),\n          ex);\n\n    } catch (JibPluginExtensionException ex) {\n      String extensionName = ex.getExtensionClass().getName();\n      throw new MojoExecutionException(\n          \"error running extension '\" + extensionName + \"': \" + ex.getMessage(), ex);\n\n    } catch (IncompatibleBaseImageJavaVersionException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forIncompatibleBaseImageJavaVersionForMaven(\n              ex.getBaseImageMajorJavaVersion(), ex.getProjectMajorJavaVersion()),\n          ex);\n\n    } catch (InvalidImageReferenceException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forInvalidImageReference(ex.getInvalidReference()), ex);\n\n    } catch (IOException | CacheDirectoryCreationException | MainClassInferenceException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex);\n\n    } catch (BuildStepsExecutionException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex.getCause());\n\n    } finally {\n      tempDirectoryProvider.close();\n      MojoCommon.finishUpdateChecker(projectProperties, updateCheckFuture);\n      projectProperties.waitForLoggingThread();\n      getLog().info(\"\");\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.19351238769925277,
        "end_line": 156,
        "signature": "com.google.cloud.tools.jib.maven.BuildDockerMojo.execute(): void"
      },
      {
        "start_line": 59,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildTarMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    checkJibVersion();\n    if (MojoCommon.shouldSkipJibExecution(this)) {\n      return;\n    }\n\n    MavenSettingsProxyProvider.activateHttpAndHttpsProxies(\n        getSession().getSettings(), getSettingsDecrypter());\n\n    TempDirectoryProvider tempDirectoryProvider = new TempDirectoryProvider();\n    MavenProjectProperties projectProperties =\n        MavenProjectProperties.getForProject(\n            Preconditions.checkNotNull(descriptor),\n            getProject(),\n            getSession(),\n            getLog(),\n            tempDirectoryProvider);\n    Future<Optional<String>> updateCheckFuture =\n        MojoCommon.newUpdateChecker(projectProperties, getLog());\n    try {\n      PluginConfigurationProcessor.createJibBuildRunnerForTarImage(\n              new MavenRawConfiguration(this),\n              new MavenSettingsServerCredentials(\n                  getSession().getSettings(), getSettingsDecrypter()),\n              projectProperties,\n              new MavenHelpfulSuggestions(HELPFUL_SUGGESTIONS_PREFIX))\n          .runBuild();\n\n    } catch (InvalidAppRootException ex) {\n      throw new MojoExecutionException(\n          \"<container><appRoot> is not an absolute Unix-style path: \" + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerizingModeException ex) {\n      throw new MojoExecutionException(\n          \"invalid value for <containerizingMode>: \" + ex.getInvalidContainerizingMode(), ex);\n\n    } catch (InvalidWorkingDirectoryException ex) {\n      throw new MojoExecutionException(\n          \"<container><workingDirectory> is not an absolute Unix-style path: \"\n              + ex.getInvalidPathValue(),\n          ex);\n\n    } catch (InvalidContainerVolumeException ex) {\n      throw new MojoExecutionException(\n          \"<container><volumes> is not an absolute Unix-style path: \" + ex.getInvalidVolume(), ex);\n\n    } catch (InvalidFilesModificationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><filesModificationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or special keyword \\\"EPOCH_PLUS_SECOND\\\": \"\n              + ex.getInvalidFilesModificationTime(),\n          ex);\n\n    } catch (InvalidCreationTimeException ex) {\n      throw new MojoExecutionException(\n          \"<container><creationTime> should be an ISO 8601 date-time (see \"\n              + \"DateTimeFormatter.ISO_DATE_TIME) or a special keyword (\\\"EPOCH\\\", \"\n              + \"\\\"USE_CURRENT_TIMESTAMP\\\"): \"\n              + ex.getInvalidCreationTime(),\n          ex);\n\n    } catch (JibPluginExtensionException ex) {\n      String extensionName = ex.getExtensionClass().getName();\n      throw new MojoExecutionException(\n          \"error running extension '\" + extensionName + \"': \" + ex.getMessage(), ex);\n\n    } catch (IncompatibleBaseImageJavaVersionException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forIncompatibleBaseImageJavaVersionForMaven(\n              ex.getBaseImageMajorJavaVersion(), ex.getProjectMajorJavaVersion()),\n          ex);\n\n    } catch (InvalidImageReferenceException ex) {\n      throw new MojoExecutionException(\n          HelpfulSuggestions.forInvalidImageReference(ex.getInvalidReference()), ex);\n\n    } catch (IOException | CacheDirectoryCreationException | MainClassInferenceException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex);\n\n    } catch (BuildStepsExecutionException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex.getCause());\n\n    } finally {\n      tempDirectoryProvider.close();\n      MojoCommon.finishUpdateChecker(projectProperties, updateCheckFuture);\n      projectProperties.waitForLoggingThread();\n      getLog().info(\"\");\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.19085277363710093,
        "end_line": 148,
        "signature": "com.google.cloud.tools.jib.maven.BuildTarMojo.execute(): void"
      },
      {
        "start_line": 129,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/FilesMojoV2.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    Preconditions.checkNotNull(projects);\n    Preconditions.checkNotNull(session);\n    Preconditions.checkNotNull(projectDependenciesResolver);\n    checkJibVersion();\n\n    for (MavenProject project : projects) {\n      // Add pom configuration files\n      skaffoldFilesOutput.addBuild(project.getFile().toPath());\n      if (\"pom\".equals(project.getPackaging())) {\n        // done if <packaging>pom</packaging>\n        continue;\n      }\n\n      // Add sources directory (resolved by maven to be an absolute path)\n      skaffoldFilesOutput.addInput(Paths.get(project.getBuild().getSourceDirectory()));\n\n      for (Path directory : getKotlinSourceDirectories(project)) {\n        skaffoldFilesOutput.addInput(directory);\n      }\n\n      // Add resources directory (resolved by maven to be an absolute path)\n      project\n          .getBuild()\n          .getResources()\n          .stream()\n          .map(FileSet::getDirectory)\n          .map(Paths::get)\n          .forEach(skaffoldFilesOutput::addInput);\n\n      // This seems weird, but we will only print out the jib \"extraFiles\" directory on projects\n      // where the plugin is explicitly configured (even though _skaffold-files-v2 is a\n      // jib-maven-plugin goal and is expected to run on all projects irrespective of their\n      // configuring of the jib plugin).\n      if (project.getPlugin(MavenProjectProperties.PLUGIN_KEY) != null) {\n        // Add extra directory\n        resolveExtraDirectories(project).forEach(skaffoldFilesOutput::addInput);\n      }\n\n      // See above note on \"extraFiles\"\n      SkaffoldConfiguration.Watch watch = collectWatchParameters(project);\n      resolveFiles(watch.buildIncludes, project).forEach(skaffoldFilesOutput::addBuild);\n      resolveFiles(watch.includes, project).forEach(skaffoldFilesOutput::addInput);\n      // we don't do any special pre-processing for ignore (input and ignore can overlap with exact\n      // matches)\n      resolveFiles(watch.excludes, project).forEach(skaffoldFilesOutput::addIgnore);\n\n      // Grab non-project SNAPSHOT dependencies for this project\n      // TODO: this whole sections relies on internal maven API, it could break. We need to explore\n      // TODO: better ways to resolve dependencies using the public maven API.\n      Set<String> projectArtifacts =\n          projects\n              .stream()\n              .map(MavenProject::getArtifact)\n              .map(Artifact::toString)\n              .collect(Collectors.toSet());\n\n      DependencyFilter ignoreProjectDependenciesFilter =\n          (node, parents) -> {\n            if (node == null || node.getDependency() == null) {\n              // if nothing, then ignore\n              return false;\n            }\n            if (projectArtifacts.contains(node.getArtifact().toString())) {\n              // ignore project dependency artifacts\n              return false;\n            }\n            // we only want compile/runtime deps\n            return Artifact.SCOPE_COMPILE_PLUS_RUNTIME.contains(node.getDependency().getScope());\n          };\n\n      try {\n        DependencyResolutionResult resolutionResult =\n            projectDependenciesResolver.resolve(\n                new DefaultDependencyResolutionRequest(project, session.getRepositorySession())\n                    .setResolutionFilter(ignoreProjectDependenciesFilter));\n        resolutionResult\n            .getDependencies()\n            .stream()\n            .map(org.eclipse.aether.graph.Dependency::getArtifact)\n            .filter(org.eclipse.aether.artifact.Artifact::isSnapshot)\n            .map(org.eclipse.aether.artifact.Artifact::getFile)\n            .map(File::toPath)\n            .forEach(skaffoldFilesOutput::addInput);\n\n      } catch (DependencyResolutionException ex) {\n        throw new MojoExecutionException(\"Failed to resolve dependencies\", ex);\n      }\n    }\n\n    try {\n      // Print JSON string\n      System.out.println();\n      System.out.println(\"BEGIN JIB JSON\");\n      System.out.println(skaffoldFilesOutput.getJsonString());\n    } catch (IOException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex);\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.1652107484960197,
        "end_line": 227,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.FilesMojoV2.execute(): void"
      },
      {
        "start_line": 93,
        "file_path": "playground/googlecontainertools__jib/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/Build.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public Integer call() throws Exception {\n    Consumer<LogEvent> logger = System.out::println;\n    JibContainerBuilder builder = Jib.from(parent.toCredentialedImage(baseImage, logger));\n    verbose(\"FROM \" + baseImage);\n    if (creationTime != null) {\n      builder.setCreationTime(creationTime);\n    }\n    if (entrypoint != null) {\n      verbose(\"ENTRYPOINT [\" + Joiner.on(\",\").join(entrypoint) + \"]\");\n      builder.setEntrypoint(entrypoint);\n    }\n    if (arguments != null) {\n      verbose(\"CMD [\" + Joiner.on(\",\").join(arguments) + \"]\");\n      builder.setProgramArguments(arguments);\n    }\n    if (environment != null) {\n      for (Entry<String, String> pair : environment.entrySet()) {\n        verbose(\"ENV \" + pair.getKey() + \"=\" + pair.getValue());\n        builder.addEnvironmentVariable(pair.getKey(), pair.getValue());\n      }\n    }\n    if (labels != null) {\n      for (Entry<String, String> pair : labels.entrySet()) {\n        verbose(\"LABEL \" + pair.getKey() + \"=\" + pair.getValue());\n        builder.addLabel(pair.getKey(), pair.getValue());\n      }\n    }\n    if (ports != null) {\n      for (Port port : ports) {\n        verbose(\"EXPOSE \" + port);\n        builder.addExposedPort(port);\n      }\n    }\n    if (volumes != null) {\n      for (AbsoluteUnixPath volume : volumes) {\n        verbose(\"VOLUME \" + volume);\n        builder.addVolume(volume);\n      }\n    }\n    if (user != null) {\n      verbose(\"USER \" + user);\n      builder.setUser(user);\n    }\n    if (layers != null) {\n      for (FileEntriesLayer layer : layers) {\n        builder.addFileEntriesLayer(layer);\n      }\n    }\n    Containerizer containerizer =\n        pushMode.toDocker\n            ? Containerizer.to(DockerDaemonImage.named(destinationImage))\n            : Containerizer.to(parent.toCredentialedImage(destinationImage, logger));\n    containerizer.setAllowInsecureRegistries(parent.insecure);\n    containerizer.setToolName(\"jib\");\n    containerizer.addEventHandler(LogEvent.class, logger);\n\n    ExecutorService executor = Executors.newCachedThreadPool();\n    try {\n      containerizer.setExecutorService(executor);\n\n      JibContainer result = builder.containerize(containerizer);\n      System.out.printf(\"Containerized to %s (%s)\\n\", destinationImage, result.getDigest());\n      return 0;\n    } finally {\n      executor.shutdown();\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.155334170603078,
        "end_line": 159,
        "signature": "com.google.cloud.tools.jib.cli.Build.call(): Integer"
      },
      {
        "start_line": 47,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/SyncMapMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException {\n    checkJibVersion();\n    if (MojoCommon.shouldSkipJibExecution(this)) {\n      return;\n    }\n\n    // TODO: move these shared checks with SyncMapTask into plugins-common\n    // add check that means this is only for jars\n    if (!\"jar\".equals(getProject().getPackaging())) {\n      throw new MojoExecutionException(\n          \"Skaffold sync is currently only available for 'jar' style Jib projects, but the packaging of \"\n              + getProject().getArtifactId()\n              + \" is '\"\n              + getProject().getPackaging()\n              + \"'\");\n    }\n    // add check for exploded containerization\n    try {\n      if (!ContainerizingMode.EXPLODED.equals(ContainerizingMode.from(getContainerizingMode()))) {\n        throw new MojoExecutionException(\n            \"Skaffold sync is currently only available for Jib projects in 'exploded' containerizing mode, but the containerizing mode of \"\n                + getProject().getArtifactId()\n                + \" is '\"\n                + getContainerizingMode()\n                + \"'\");\n      }\n    } catch (InvalidContainerizingModeException ex) {\n      throw new MojoExecutionException(\"Invalid containerizing mode\", ex);\n    }\n\n    try (TempDirectoryProvider tempDirectoryProvider = new TempDirectoryProvider()) {\n      MavenProjectProperties projectProperties =\n          MavenProjectProperties.getForProject(\n              Preconditions.checkNotNull(descriptor),\n              getProject(),\n              getSession(),\n              getLog(),\n              tempDirectoryProvider);\n\n      MavenRawConfiguration configuration = new MavenRawConfiguration(this);\n\n      try {\n        String syncMapJson =\n            PluginConfigurationProcessor.getSkaffoldSyncMap(\n                configuration,\n                projectProperties,\n                skaffold\n                    .sync\n                    .excludes\n                    .stream()\n                    .map(File::toPath)\n                    .map(Path::toAbsolutePath)\n                    .collect(Collectors.toSet()));\n\n        System.out.println();\n        System.out.println(\"BEGIN JIB JSON: SYNCMAP/1\");\n        System.out.println(syncMapJson);\n\n      } catch (Exception ex) {\n        throw new MojoExecutionException(\n            \"Failed to generate a Jib file map for sync with Skaffold\", ex);\n      }\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.13671838162220595,
        "end_line": 110,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.SyncMapMojo.execute(): void"
      },
      {
        "start_line": 58,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/BuildImageStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public Image call() throws LayerPropertyNotFoundException {\n    try (ProgressEventDispatcher ignored =\n            progressEventDispatcherFactory.create(\"building image format\", 1);\n        TimerEventDispatcher ignored2 =\n            new TimerEventDispatcher(buildContext.getEventHandlers(), DESCRIPTION)) {\n      // Constructs the image.\n      Image.Builder imageBuilder = Image.builder(buildContext.getTargetFormat());\n      ContainerConfiguration containerConfiguration = buildContext.getContainerConfiguration();\n\n      // Base image layers\n      baseImageLayers.forEach(imageBuilder::addLayer);\n\n      // Passthrough config and count non-empty history entries\n      int nonEmptyLayerCount = 0;\n      for (HistoryEntry historyObject : baseImage.getHistory()) {\n        imageBuilder.addHistory(historyObject);\n        if (!historyObject.hasCorrespondingLayer()) {\n          nonEmptyLayerCount++;\n        }\n      }\n      imageBuilder\n          .setArchitecture(baseImage.getArchitecture())\n          .setOs(baseImage.getOs())\n          .addEnvironment(baseImage.getEnvironment())\n          .addLabels(baseImage.getLabels())\n          .setHealthCheck(baseImage.getHealthCheck())\n          .addExposedPorts(baseImage.getExposedPorts())\n          .addVolumes(baseImage.getVolumes())\n          .setUser(baseImage.getUser())\n          .setWorkingDirectory(baseImage.getWorkingDirectory());\n\n      // Add history elements for non-empty layers that don't have one yet\n      Instant layerCreationTime =\n          containerConfiguration == null\n              ? ContainerConfiguration.DEFAULT_CREATION_TIME\n              : containerConfiguration.getCreationTime();\n      for (int count = 0; count < baseImageLayers.size() - nonEmptyLayerCount; count++) {\n        imageBuilder.addHistory(\n            HistoryEntry.builder()\n                .setCreationTimestamp(layerCreationTime)\n                .setComment(\"auto-generated by Jib\")\n                .build());\n      }\n\n      // Add built layers/configuration\n      for (PreparedLayer applicationLayer : applicationLayers) {\n        imageBuilder\n            .addLayer(applicationLayer)\n            .addHistory(\n                HistoryEntry.builder()\n                    .setCreationTimestamp(layerCreationTime)\n                    .setAuthor(\"Jib\")\n                    .setCreatedBy(buildContext.getToolName() + \":\" + buildContext.getToolVersion())\n                    .setComment(applicationLayer.getName())\n                    .build());\n      }\n      if (containerConfiguration != null) {\n        imageBuilder\n            .addEnvironment(containerConfiguration.getEnvironmentMap())\n            .setCreated(containerConfiguration.getCreationTime())\n            .setEntrypoint(computeEntrypoint(baseImage, containerConfiguration))\n            .setProgramArguments(computeProgramArguments(baseImage, containerConfiguration))\n            .addExposedPorts(containerConfiguration.getExposedPorts())\n            .addVolumes(containerConfiguration.getVolumes())\n            .addLabels(containerConfiguration.getLabels());\n        if (containerConfiguration.getUser() != null) {\n          imageBuilder.setUser(containerConfiguration.getUser());\n        }\n        if (containerConfiguration.getWorkingDirectory() != null) {\n          imageBuilder.setWorkingDirectory(containerConfiguration.getWorkingDirectory().toString());\n        }\n      }\n\n      // Gets the container configuration content descriptor.\n      return imageBuilder.build();\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.1365534151558801,
        "end_line": 134,
        "signature": "com.google.cloud.tools.jib.builder.steps.BuildImageStep.call(): Image"
      },
      {
        "start_line": 134,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/ObtainBaseImageLayerStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public PreparedLayer call() throws IOException, CacheCorruptedException, RegistryException {\n    EventHandlers eventHandlers = buildContext.getEventHandlers();\n    DescriptorDigest layerDigest = layer.getBlobDescriptor().getDigest();\n    try (ProgressEventDispatcher progressEventDispatcher =\n            progressEventDispatcherFactory.create(\"checking base image layer \" + layerDigest, 1);\n        TimerEventDispatcher ignored =\n            new TimerEventDispatcher(eventHandlers, String.format(DESCRIPTION, layerDigest))) {\n\n      StateInTarget stateInTarget = blobExistenceChecker.check(layerDigest);\n      if (stateInTarget == StateInTarget.EXISTING) {\n        eventHandlers.dispatch(\n            LogEvent.info(\n                \"Skipping pull; BLOB already exists on target registry : \"\n                    + layer.getBlobDescriptor()));\n        return new PreparedLayer.Builder(layer).setStateInTarget(stateInTarget).build();\n      }\n\n      Cache cache = buildContext.getBaseImageLayersCache();\n\n      // Checks if the layer already exists in the cache.\n      Optional<CachedLayer> optionalCachedLayer = cache.retrieve(layerDigest);\n      if (optionalCachedLayer.isPresent()) {\n        CachedLayer cachedLayer = optionalCachedLayer.get();\n        return new PreparedLayer.Builder(cachedLayer).setStateInTarget(stateInTarget).build();\n      } else if (buildContext.isOffline()) {\n        throw new IOException(\n            \"Cannot run Jib in offline mode; local Jib cache for base image is missing image layer \"\n                + layerDigest\n                + \". Rerun Jib in online mode with \\\"-Djib.alwaysCacheBaseImage=true\\\" to \"\n                + \"re-download the base image layers.\");\n      }\n\n      try (ThrottledProgressEventDispatcherWrapper progressEventDispatcherWrapper =\n          new ThrottledProgressEventDispatcherWrapper(\n              progressEventDispatcher.newChildProducer(),\n              \"pulling base image layer \" + layerDigest)) {\n        CachedLayer cachedLayer =\n            cache.writeCompressedLayer(\n                Verify.verifyNotNull(registryClient)\n                    .pullBlob(\n                        layerDigest,\n                        progressEventDispatcherWrapper::setProgressTarget,\n                        progressEventDispatcherWrapper::dispatchProgress));\n        return new PreparedLayer.Builder(cachedLayer).setStateInTarget(stateInTarget).build();\n      }\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.12659408615449075,
        "end_line": 180,
        "signature": "com.google.cloud.tools.jib.builder.steps.ObtainBaseImageLayerStep.call(): PreparedLayer"
      },
      {
        "start_line": 116,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/credentials/DockerConfigCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  Optional<Credential> retrieve(DockerConfig dockerConfig, Consumer<LogEvent> logger) {\n    for (String registryAlias : RegistryAliasGroup.getAliasesGroup(registry)) {\n      // First, find a credential helper from \"credentialHelpers\" and \"credsStore\" in order.\n      DockerCredentialHelper dockerCredentialHelper =\n          dockerConfig.getCredentialHelperFor(registryAlias);\n      if (dockerCredentialHelper != null) {\n        try {\n          Path helperPath = dockerCredentialHelper.getCredentialHelper();\n          logger.accept(LogEvent.info(\"trying \" + helperPath + \" for \" + registryAlias));\n          // Tries with the given registry alias (may be the original registry).\n          return Optional.of(dockerCredentialHelper.retrieve());\n\n        } catch (IOException\n            | CredentialHelperUnhandledServerUrlException\n            | CredentialHelperNotFoundException ex) {\n          // Warns the user that the specified credential helper cannot be used.\n          if (ex.getMessage() != null) {\n            logger.accept(LogEvent.warn(ex.getMessage()));\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n              logger.accept(LogEvent.warn(\"  Caused by: \" + ex.getCause().getMessage()));\n            }\n          }\n        }\n      }\n\n      // Lastly, find defined auth.\n      AuthTemplate auth = dockerConfig.getAuthFor(registryAlias);\n      if (auth != null) {\n        // 'auth' is a basic authentication token that should be parsed back into credentials\n        String usernameColonPassword =\n            new String(Base64.decodeBase64(auth.getAuth()), StandardCharsets.UTF_8);\n        String username = usernameColonPassword.substring(0, usernameColonPassword.indexOf(\":\"));\n        String password = usernameColonPassword.substring(usernameColonPassword.indexOf(\":\") + 1);\n        logger.accept(\n            LogEvent.info(\"Docker config auths section defines credentials for \" + registryAlias));\n        if (auth.getIdentityToken() != null\n            // These username and password checks may be unnecessary, but doing so to restrict the\n            // scope only to the Azure behavior to maintain maximum backward-compatibilty.\n            && username.equals(\"00000000-0000-0000-0000-000000000000\")\n            && password.isEmpty()) {\n          logger.accept(\n              LogEvent.info(\"Using 'identityToken' in Docker config auth for \" + registryAlias));\n          return Optional.of(\n              Credential.from(Credential.OAUTH2_TOKEN_USER_NAME, auth.getIdentityToken()));\n        }\n        return Optional.of(Credential.from(username, password));\n      }\n    }\n    return Optional.empty();\n  }",
        "distance": 1.0,
        "title": null,
        "name": "retrieve",
        "documentation": "/**\n   * Retrieves credentials for a registry alias from a {@link DockerConfig}.\n   *\n   * @param dockerConfig the {@link DockerConfig} to retrieve from\n   * @param logger a consumer for handling log events\n   * @return the retrieved credentials, or {@code Optional#empty} if none are found\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          }
        ],
        "similarity": 0.12596400140178668,
        "end_line": 165,
        "signature": "com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve(DockerConfig dockerConfig, Consumer logger): Optional"
      },
      {
        "start_line": 51,
        "file_path": "playground/googlecontainertools__jib/examples/dropwizard/.mvn/wrapper/MavenWrapperDownloader.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "    public static void main(String args[]) {\n        System.out.println(\"- Downloader started\");\n        File baseDirectory = new File(args[0]);\n        System.out.println(\"- Using base directory: \" + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if(mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n            } finally {\n                try {\n                    if(mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println(\"- Downloading from: : \" + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n        if(!outputFile.getParentFile().exists()) {\n            if(!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        \"- ERROR creating output direcrory '\" + outputFile.getParentFile().getAbsolutePath() + \"'\");\n            }\n        }\n        System.out.println(\"- Downloading to: \" + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println(\"Done\");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println(\"- Error downloading\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }",
        "distance": 1.0,
        "title": null,
        "name": "main",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "main"
          }
        ],
        "similarity": 0.12147653488179382,
        "end_line": 98,
        "signature": "MavenWrapperDownloader.main(String[] args): void"
      },
      {
        "start_line": 52,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/LoadDockerStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public BuildResult call() throws InterruptedException, IOException {\n    EventHandlers eventHandlers = buildContext.getEventHandlers();\n    try (TimerEventDispatcher ignored =\n        new TimerEventDispatcher(eventHandlers, \"Loading to Docker daemon\")) {\n      eventHandlers.dispatch(LogEvent.progress(\"Loading to Docker daemon...\"));\n      ImageTarball imageTarball =\n          new ImageTarball(\n              builtImage,\n              buildContext.getTargetImageConfiguration().getImage(),\n              buildContext.getAllTargetImageTags());\n\n      // Note: The progress reported here is not entirely accurate. The total allocation units is\n      // the size of the layers, but the progress being reported includes the config and manifest\n      // as well, so we will always go over the total progress allocation here.\n      // See https://github.com/GoogleContainerTools/jib/pull/1960#discussion_r321898390\n      try (ProgressEventDispatcher progressEventDispatcher =\n              progressEventDispatcherFactory.create(\n                  \"loading to Docker daemon\", imageTarball.getTotalLayerSize());\n          ThrottledAccumulatingConsumer throttledProgressReporter =\n              new ThrottledAccumulatingConsumer(progressEventDispatcher::dispatchProgress)) {\n        // Load the image to docker daemon.\n        eventHandlers.dispatch(\n            LogEvent.debug(dockerClient.load(imageTarball, throttledProgressReporter)));\n\n        return BuildResult.fromImage(builtImage, buildContext.getTargetFormat());\n      }\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.11033633081451481,
        "end_line": 79,
        "signature": "com.google.cloud.tools.jib.builder.steps.LoadDockerStep.call(): BuildResult"
      },
      {
        "start_line": 126,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryEndpointCaller.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private T call(URL url) throws IOException, RegistryException {\n    String serverUrl = registryEndpointRequestProperties.getServerUrl();\n    String imageName = registryEndpointRequestProperties.getImageName();\n\n    Request.Builder requestBuilder =\n        Request.builder()\n            .setUserAgent(userAgent)\n            .setHttpTimeout(JibSystemProperties.getHttpTimeout())\n            .setAccept(registryEndpointProvider.getAccept())\n            .setBody(registryEndpointProvider.getContent())\n            .setAuthorization(authorization);\n\n    try (Response response =\n        httpClient.call(registryEndpointProvider.getHttpMethod(), url, requestBuilder.build())) {\n\n      return registryEndpointProvider.handleResponse(response);\n\n    } catch (ResponseException ex) {\n      // First, see if the endpoint provider handles an exception as an expected response.\n      try {\n        return registryEndpointProvider.handleHttpResponseException(ex);\n\n      } catch (ResponseException responseException) {\n        if (responseException.getStatusCode() == HttpStatusCodes.STATUS_CODE_BAD_REQUEST\n            || responseException.getStatusCode() == HttpStatusCodes.STATUS_CODE_NOT_FOUND\n            || responseException.getStatusCode()\n                == HttpStatusCodes.STATUS_CODE_METHOD_NOT_ALLOWED) {\n          // The name or reference was invalid.\n          throw newRegistryErrorException(responseException);\n\n        } else if (responseException.getStatusCode() == HttpStatusCodes.STATUS_CODE_FORBIDDEN) {\n          throw new RegistryUnauthorizedException(serverUrl, imageName, responseException);\n\n        } else if (responseException.getStatusCode() == HttpStatusCodes.STATUS_CODE_UNAUTHORIZED) {\n          if (responseException.requestAuthorizationCleared()) {\n            throw new RegistryCredentialsNotSentException(serverUrl, imageName);\n          } else {\n            // Credentials are either missing or wrong.\n            throw new RegistryUnauthorizedException(serverUrl, imageName, responseException);\n          }\n\n        } else {\n          // Unknown\n          throw responseException;\n        }\n      }\n\n    } catch (IOException ex) {\n      logError(\"I/O error for image [\" + serverUrl + \"/\" + imageName + \"]:\");\n      logError(\"    \" + ex.getClass().getName());\n      logError(\"    \" + (ex.getMessage() == null ? \"(null exception message)\" : ex.getMessage()));\n      logErrorIfBrokenPipe(ex);\n\n      if (ex instanceof SSLException) {\n        throw new InsecureRegistryException(url, ex);\n      }\n      throw ex;\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "/**\n   * Calls the registry endpoint with a certain {@link URL}.\n   *\n   * @param url the endpoint URL to call\n   * @return an object representing the response\n   * @throws IOException for most I/O exceptions when making the request\n   * @throws RegistryException for known exceptions when interacting with the registry\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.10889664856151389,
        "end_line": 184,
        "signature": "com.google.cloud.tools.jib.registry.RegistryEndpointCaller.call(URL url): T"
      },
      {
        "start_line": 62,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushBlobStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public BlobDescriptor call() throws IOException, RegistryException {\n    EventHandlers eventHandlers = buildContext.getEventHandlers();\n    DescriptorDigest blobDigest = blobDescriptor.getDigest();\n    try (ProgressEventDispatcher progressEventDispatcher =\n            progressEventDispatcherFactory.create(\n                \"pushing blob \" + blobDigest, blobDescriptor.getSize());\n        TimerEventDispatcher ignored =\n            new TimerEventDispatcher(eventHandlers, DESCRIPTION + blobDescriptor);\n        ThrottledAccumulatingConsumer throttledProgressReporter =\n            new ThrottledAccumulatingConsumer(progressEventDispatcher::dispatchProgress)) {\n\n      // check if the BLOB is available\n      if (!forcePush && registryClient.checkBlob(blobDigest).isPresent()) {\n        eventHandlers.dispatch(\n            LogEvent.info(\n                \"Skipping push; BLOB already exists on target registry : \" + blobDescriptor));\n        return blobDescriptor;\n      }\n\n      // If base and target images are in the same registry, then use mount/from to try mounting the\n      // BLOB from the base image repository to the target image repository and possibly avoid\n      // having to push the BLOB. See\n      // https://docs.docker.com/registry/spec/api/#cross-repository-blob-mount for details.\n      String baseRegistry = buildContext.getBaseImageConfiguration().getImageRegistry();\n      String baseRepository = buildContext.getBaseImageConfiguration().getImageRepository();\n      String targetRegistry = buildContext.getTargetImageConfiguration().getImageRegistry();\n      String sourceRepository = targetRegistry.equals(baseRegistry) ? baseRepository : null;\n      registryClient.pushBlob(blobDigest, blob, sourceRepository, throttledProgressReporter);\n      return blobDescriptor;\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.10270562607721065,
        "end_line": 92,
        "signature": "com.google.cloud.tools.jib.builder.steps.PushBlobStep.call(): BlobDescriptor"
      },
      {
        "start_line": 39,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/InitMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException {\n    checkJibVersion();\n    MavenProject project = getProject();\n    // Ignore pom projects\n    if (\"pom\".equals(project.getPackaging())) {\n      return;\n    }\n\n    SkaffoldInitOutput skaffoldInitOutput = new SkaffoldInitOutput();\n    skaffoldInitOutput.setImage(getTargetImage());\n    skaffoldInitOutput.setProject(project.getGroupId() + \":\" + project.getArtifactId());\n    System.out.println();\n    System.out.println(\"BEGIN JIB JSON\");\n    try {\n      System.out.println(skaffoldInitOutput.getJsonString());\n    } catch (IOException ex) {\n      throw new MojoExecutionException(ex.getMessage(), ex);\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.10266145571057543,
        "end_line": 57,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.InitMojo.execute(): void"
      },
      {
        "start_line": 56,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushContainerConfigurationStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public BlobDescriptor call() throws IOException, RegistryException {\n    try (ProgressEventDispatcher progressEventDispatcher =\n            progressEventDispatcherFactory.create(\"pushing container configuration\", 1);\n        TimerEventDispatcher ignored =\n            new TimerEventDispatcher(buildContext.getEventHandlers(), DESCRIPTION)) {\n      JsonTemplate containerConfiguration =\n          new ImageToJsonTranslator(builtImage).getContainerConfiguration();\n\n      return new PushBlobStep(\n              buildContext,\n              progressEventDispatcher.newChildProducer(),\n              registryClient,\n              Digests.computeDigest(containerConfiguration),\n              Blobs.from(containerConfiguration),\n              false)\n          .call();\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "call",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.09072435585441231,
        "end_line": 73,
        "signature": "com.google.cloud.tools.jib.builder.steps.PushContainerConfigurationStep.call(): BlobDescriptor"
      },
      {
        "start_line": 236,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/FilesMojoV2.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private List<Path> collectExtraDirectories(MavenProject project) {\n    // Try getting extra directory from project/session properties\n    String property =\n        MavenProjectProperties.getProperty(PropertyNames.EXTRA_DIRECTORIES_PATHS, project, session);\n    if (property != null) {\n      List<String> paths = ConfigurationPropertyValidator.parseListProperty(property);\n      return paths.stream().map(Paths::get).collect(Collectors.toList());\n    }\n\n    // Try getting extra directory from project pom\n    Plugin jibMavenPlugin = project.getPlugin(MavenProjectProperties.PLUGIN_KEY);\n    if (jibMavenPlugin != null) {\n      Xpp3Dom pluginConfiguration = (Xpp3Dom) jibMavenPlugin.getConfiguration();\n      if (pluginConfiguration != null) {\n        Xpp3Dom extraDirectoriesConfiguration = pluginConfiguration.getChild(\"extraDirectories\");\n        if (extraDirectoriesConfiguration != null) {\n          Xpp3Dom paths = extraDirectoriesConfiguration.getChild(\"paths\");\n          if (paths != null) {\n            // <extraDirectories><paths><path>...</path><path>...</path></paths></extraDirectories>\n            // paths can contain either strings or ExtraDirectory objects\n            List<Path> pathList = new ArrayList<>();\n            for (Xpp3Dom path : paths.getChildren()) {\n              Xpp3Dom from = path.getChild(\"from\");\n              if (from != null) {\n                pathList.add(Paths.get(from.getValue()));\n              } else {\n                pathList.add(Paths.get(path.getValue()));\n              }\n            }\n            return Collections.unmodifiableList(pathList);\n          }\n        }\n      }\n    }\n\n    // Return default if not found\n    Path projectBase = Preconditions.checkNotNull(project).getBasedir().getAbsoluteFile().toPath();\n    Path srcMainJib = Paths.get(\"src\", \"main\", \"jib\");\n    return Collections.singletonList(projectBase.resolve(srcMainJib));\n  }",
        "distance": 1.5,
        "title": null,
        "name": "collectExtraDirectories",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "FilesMojoV2"
          },
          {
            "start_node": "FilesMojoV2",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "collectExtraDirectories"
          }
        ],
        "similarity": 0.08977794185117229,
        "end_line": 275,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.FilesMojoV2.collectExtraDirectories(MavenProject project): List"
      },
      {
        "start_line": 57,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/PackageGoalsMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    Preconditions.checkNotNull(lifecycleExecutor);\n    Preconditions.checkNotNull(session);\n    checkJibVersion();\n\n    MavenExecutionPlan mavenExecutionPlan;\n    try {\n      mavenExecutionPlan = lifecycleExecutor.calculateExecutionPlan(session, \"package\");\n    } catch (Exception ex) {\n      throw new MojoExecutionException(\"failed to calculate execution plan\", ex);\n    }\n\n    mavenExecutionPlan\n        .getMojoExecutions()\n        .stream()\n        .filter(mojoExecution -> \"package\".equals(mojoExecution.getLifecyclePhase()))\n        .filter(\n            mojoExecution ->\n                MavenProjectProperties.PLUGIN_NAME.equals(\n                    mojoExecution.getPlugin().getArtifactId()))\n        .map(MojoExecution::getGoal)\n        .forEach(System.out::println);\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.08711385832579199,
        "end_line": 79,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.PackageGoalsMojo.execute(): void"
      },
      {
        "start_line": 264,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/configuration/BuildContext.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "    public BuildContext build() throws CacheDirectoryCreationException {\n      // Validates the parameters.\n      List<String> missingFields = new ArrayList<>();\n      if (baseImageConfiguration == null) {\n        missingFields.add(\"base image configuration\");\n      }\n      if (targetImageConfiguration == null) {\n        missingFields.add(\"target image configuration\");\n      }\n      if (baseImageLayersCacheDirectory == null) {\n        missingFields.add(\"base image layers cache directory\");\n      }\n      if (applicationLayersCacheDirectory == null) {\n        missingFields.add(\"application layers cache directory\");\n      }\n\n      switch (missingFields.size()) {\n        case 0: // No errors\n          Preconditions.checkNotNull(baseImageConfiguration);\n          if (!baseImageConfiguration.getImage().getDigest().isPresent()\n              && !baseImageConfiguration.getImage().isScratch()) {\n            eventHandlers.dispatch(\n                LogEvent.warn(\n                    \"Base image '\"\n                        + baseImageConfiguration.getImage()\n                        + \"' does not use a specific image digest - build may not be reproducible\"));\n          }\n\n          return new BuildContext(\n              baseImageConfiguration,\n              Preconditions.checkNotNull(targetImageConfiguration),\n              additionalTargetImageTags,\n              containerConfiguration,\n              Cache.withDirectory(Preconditions.checkNotNull(baseImageLayersCacheDirectory)),\n              Cache.withDirectory(Preconditions.checkNotNull(applicationLayersCacheDirectory)),\n              targetFormat,\n              offline,\n              layerConfigurations,\n              toolName,\n              toolVersion,\n              eventHandlers,\n              // TODO: try setting global User-Agent: here\n              new FailoverHttpClient(\n                  allowInsecureRegistries,\n                  JibSystemProperties.sendCredentialsOverHttp(),\n                  eventHandlers::dispatch),\n              executorService == null ? Executors.newCachedThreadPool() : executorService,\n              executorService == null, // shutDownExecutorService\n              alwaysCacheBaseImage);\n\n        case 1:\n          throw new IllegalStateException(missingFields.get(0) + \" is required but not set\");\n\n        case 2:\n          throw new IllegalStateException(\n              missingFields.get(0) + \" and \" + missingFields.get(1) + \" are required but not set\");\n\n        default:\n          missingFields.add(\"and \" + missingFields.remove(missingFields.size() - 1));\n          StringJoiner errorMessage = new StringJoiner(\", \", \"\", \" are required but not set\");\n          for (String missingField : missingFields) {\n            errorMessage.add(missingField);\n          }\n          throw new IllegalStateException(errorMessage.toString());\n      }\n    }",
        "distance": 2.0,
        "title": null,
        "name": "build",
        "documentation": "/**\n     * Builds a new {@link BuildContext} using the parameters passed into the builder.\n     *\n     * @return the corresponding build context\n     * @throws CacheDirectoryCreationException if I/O exception occurs when creating cache directory\n     */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "build"
          }
        ],
        "similarity": 0.08405981293139216,
        "end_line": 329,
        "signature": "com.google.cloud.tools.jib.configuration.BuildContext.Builder.build(): BuildContext"
      },
      {
        "start_line": 85,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/credentials/DockerConfigCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public Optional<Credential> retrieve(Consumer<LogEvent> logger) throws IOException {\n    if (!Files.exists(dockerConfigFile)) {\n      return Optional.empty();\n    }\n\n    ObjectMapper objectMapper =\n        new ObjectMapper().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n    try (InputStream fileIn = Files.newInputStream(dockerConfigFile)) {\n      if (legacyConfigFormat) {\n        // legacy config format is the value of the \"auths\":{ <map> } block of the new config (i.e.,\n        // the <map> of string -> DockerConfigTemplate.AuthTemplate).\n        Map<String, AuthTemplate> auths =\n            objectMapper.readValue(fileIn, new TypeReference<Map<String, AuthTemplate>>() {});\n        DockerConfig dockerConfig = new DockerConfig(new DockerConfigTemplate(auths));\n        return retrieve(dockerConfig, logger);\n      }\n\n      DockerConfig dockerConfig =\n          new DockerConfig(objectMapper.readValue(fileIn, DockerConfigTemplate.class));\n      return retrieve(dockerConfig, logger);\n    }\n  }",
        "distance": 1.0,
        "title": null,
        "name": "retrieve",
        "documentation": "/**\n   * Retrieves credentials for a registry. Tries all possible known aliases.\n   *\n   * @param logger a consumer for handling log events\n   * @return {@link Credential} found for {@code registry}, or {@link Optional#empty} if not found\n   * @throws IOException if failed to parse the config JSON\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          }
        ],
        "similarity": 0.08147084424221365,
        "end_line": 106,
        "signature": "com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve(Consumer logger): Optional"
      },
      {
        "start_line": 47,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/CheckJibVersionMojo.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void execute() throws MojoExecutionException, MojoFailureException {\n    if (Strings.isNullOrEmpty(System.getProperty(MojoCommon.REQUIRED_VERSION_PROPERTY_NAME))) {\n      throw new MojoExecutionException(\n          GOAL_NAME + \" requires \" + MojoCommon.REQUIRED_VERSION_PROPERTY_NAME + \" to be set\");\n    }\n    checkJibVersion();\n  }",
        "distance": 1.0,
        "title": null,
        "name": "execute",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          }
        ],
        "similarity": 0.07842841041575217,
        "end_line": 53,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.CheckJibVersionMojo.execute(): void"
      },
      {
        "start_line": 118,
        "file_path": "playground/googlecontainertools__jib/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/JibCli.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  RegistryImage toCredentialedImage(ImageReference reference, Consumer<LogEvent> logger) {\n    RegistryImage registryImage = RegistryImage.named(reference);\n\n    // first add any explicitly specified credential helpers\n    CredentialRetrieverFactory factory = CredentialRetrieverFactory.forImage(reference, logger);\n    for (String credentialHelper : credentialHelpers) {\n      Path path = Paths.get(credentialHelper);\n      if (Files.exists(path)) {\n        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n      } else {\n        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(credentialHelper));\n      }\n    }\n    // then add any other known helpers\n    registryImage.addCredentialRetriever(factory.dockerConfig());\n    registryImage.addCredentialRetriever(factory.wellKnownCredentialHelpers());\n    registryImage.addCredentialRetriever(factory.googleApplicationDefaultCredentials());\n\n    return registryImage;\n  }",
        "distance": 1.5,
        "title": null,
        "name": "toCredentialedImage",
        "documentation": "/** Create a {@link RegistryImage} with credential retrievers. */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "main"
          },
          {
            "start_node": "main",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "JibCli"
          },
          {
            "start_node": "JibCli",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "toCredentialedImage"
          }
        ],
        "similarity": 0.07658866057568797,
        "end_line": 137,
        "signature": "com.google.cloud.tools.jib.cli.JibCli.toCredentialedImage(ImageReference reference, Consumer logger): RegistryImage"
      },
      {
        "start_line": 116,
        "file_path": "playground/googlecontainertools__jib/jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibPlugin.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void apply(Project project) {\n    checkGradleVersion();\n    checkJibVersion();\n\n    JibExtension jibExtension =\n        project.getExtensions().create(JIB_EXTENSION_NAME, JibExtension.class, project);\n\n    TaskContainer tasks = project.getTasks();\n    TaskProvider<BuildImageTask> buildImageTask =\n        tasks.register(\n            BUILD_IMAGE_TASK_NAME,\n            BuildImageTask.class,\n            task -> {\n              task.setGroup(\"Jib\");\n              task.setDescription(\"Builds a container image to a registry.\");\n              task.setJibExtension(jibExtension);\n            });\n\n    TaskProvider<BuildDockerTask> buildDockerTask =\n        tasks.register(\n            BUILD_DOCKER_TASK_NAME,\n            BuildDockerTask.class,\n            task -> {\n              task.setGroup(\"Jib\");\n              task.setDescription(\"Builds a container image to a Docker daemon.\");\n              task.setJibExtension(jibExtension);\n            });\n\n    TaskProvider<BuildTarTask> buildTarTask =\n        tasks.register(\n            BUILD_TAR_TASK_NAME,\n            BuildTarTask.class,\n            task -> {\n              task.setGroup(\"Jib\");\n              task.setDescription(\"Builds a container image to a tarball.\");\n              task.setJibExtension(jibExtension);\n            });\n\n    tasks\n        .register(SKAFFOLD_FILES_TASK_V2_NAME, FilesTaskV2.class)\n        .configure(task -> task.setJibExtension(jibExtension));\n    tasks\n        .register(SKAFFOLD_INIT_TASK_NAME, InitTask.class)\n        .configure(task -> task.setJibExtension(jibExtension));\n    TaskProvider<SyncMapTask> syncMapTask =\n        tasks.register(\n            SKAFFOLD_SYNC_MAP_TASK_NAME,\n            SyncMapTask.class,\n            task -> task.setJibExtension(jibExtension));\n\n    // A check to catch older versions of Jib.  This can be removed once we are certain people\n    // are using Jib 1.3.1 or later.\n    tasks.register(SKAFFOLD_CHECK_REQUIRED_VERSION_TASK_NAME, CheckJibVersionTask.class);\n\n    project.afterEvaluate(\n        projectAfterEvaluation -> {\n          TaskProvider<Task> warTask = TaskCommon.getWarTaskProvider(projectAfterEvaluation);\n          TaskProvider<Task> bootWarTask =\n              TaskCommon.getBootWarTaskProvider(projectAfterEvaluation);\n          List<Object> jibDependencies = new ArrayList<>();\n          if (warTask != null || bootWarTask != null) {\n            // Have all tasks depend on the 'war' and/or 'bootWar' task.\n            if (warTask != null) {\n              jibDependencies.add(warTask);\n            }\n            if (bootWarTask != null) {\n              jibDependencies.add(bootWarTask);\n            }\n          } else if (\"packaged\".equals(jibExtension.getContainerizingMode())) {\n            // Have all tasks depend on the 'jar' task.\n            TaskProvider<Task> jarTask = projectAfterEvaluation.getTasks().named(\"jar\");\n            jibDependencies.add(jarTask);\n\n            if (projectAfterEvaluation.getPlugins().hasPlugin(\"org.springframework.boot\")) {\n              Task bootJarTask = projectAfterEvaluation.getTasks().getByName(\"bootJar\");\n\n              if (bootJarTask.getEnabled()) {\n                String bootJarPath = bootJarTask.getOutputs().getFiles().getAsPath();\n                String jarPath = jarTask.get().getOutputs().getFiles().getAsPath();\n                if (bootJarPath.equals(jarPath)) {\n                  if (!jarTask.get().getEnabled()) {\n                    ((Jar) jarTask.get()).getArchiveClassifier().set(\"original\");\n                  } else {\n                    throw new GradleException(\n                        \"Both 'bootJar' and 'jar' tasks are enabled, but they write their jar file \"\n                            + \"into the same location at \"\n                            + jarPath\n                            + \". Did you forget to set 'archiveClassifier' on either task?\");\n                  }\n                }\n              }\n              jarTask.get().setEnabled(true);\n            }\n          }\n\n          SourceSet mainSourceSet =\n              project\n                  .getConvention()\n                  .getPlugin(JavaPluginConvention.class)\n                  .getSourceSets()\n                  .getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n          jibDependencies.add(mainSourceSet.getRuntimeClasspath());\n\n          Set<TaskProvider<?>> jibTaskProviders =\n              ImmutableSet.of(buildImageTask, buildDockerTask, buildTarTask, syncMapTask);\n          jibTaskProviders.forEach(\n              provider ->\n                  provider.configure(task -> jibDependencies.forEach(dep -> task.dependsOn(dep))));\n        });\n  }",
        "distance": 2.5,
        "title": null,
        "name": "apply",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "DockerConfigCredentialRetriever"
          },
          {
            "start_node": "DockerConfigCredentialRetriever",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "create"
          },
          {
            "start_node": "create",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "apply"
          }
        ],
        "similarity": 0.07578615836286062,
        "end_line": 225,
        "signature": "com.google.cloud.tools.jib.gradle.JibPlugin.apply(Project project): void"
      },
      {
        "start_line": 89,
        "file_path": "playground/googlecontainertools__jib/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/JibCli.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public static void main(String[] args) {\n    int exitCode = new CommandLine(new JibCli()).execute(args);\n    System.exit(exitCode);\n  }",
        "distance": 1.0,
        "title": null,
        "name": "main",
        "documentation": "/**\n   * The magic starts here.\n   *\n   * @param args the command-line arguments\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "main"
          }
        ],
        "similarity": 0.0730224006773936,
        "end_line": 92,
        "signature": "com.google.cloud.tools.jib.cli.JibCli.main(String[] args): void"
      },
      {
        "start_line": 77,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/FilesMojoV2.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  static Set<Path> getKotlinSourceDirectories(MavenProject project) {\n    Plugin kotlinPlugin = project.getPlugin(\"org.jetbrains.kotlin:kotlin-maven-plugin\");\n    if (kotlinPlugin == null) {\n      return Collections.emptySet();\n    }\n\n    Path projectBaseDir = project.getBasedir().toPath();\n\n    // Extract <sourceDir> values from <configuration> in the plugin <executions>. Sample:\n    // <executions><execution><configuration>\n    //   <sourceDirs>\n    //     <sourceDir>src/main/kotlin</sourceDir>\n    //     <sourceDir>${project.basedir}/src/main/java</sourceDir>\n    //   </sourceDirs>\n    // </configuration></execution></executions>\n    Set<Path> kotlinSourceDirectories =\n        kotlinPlugin\n            .getExecutions()\n            .stream()\n            .filter(execution -> !execution.getGoals().contains(\"test-compile\"))\n            .map(execution -> (Xpp3Dom) execution.getConfiguration())\n            .filter(Objects::nonNull)\n            .map(configuration -> configuration.getChild(\"sourceDirs\"))\n            .filter(Objects::nonNull)\n            .map(sourceDirs -> Arrays.asList(sourceDirs.getChildren()))\n            .flatMap(Collection::stream) // \"array of arrays\" into \"arrays\"\n            .map(Xpp3Dom::getValue)\n            .filter(value -> !Strings.isNullOrEmpty(value))\n            .map(Paths::get)\n            .map(path -> path.isAbsolute() ? path : projectBaseDir.resolve(path))\n            .collect(Collectors.toSet());\n\n    Path conventionalDirectory = projectBaseDir.resolve(Paths.get(\"src\", \"main\", \"kotlin\"));\n    kotlinSourceDirectories.add(conventionalDirectory);\n\n    return kotlinSourceDirectories;\n  }",
        "distance": 1.5,
        "title": null,
        "name": "getKotlinSourceDirectories",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "FilesMojoV2"
          },
          {
            "start_node": "FilesMojoV2",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "getKotlinSourceDirectories"
          }
        ],
        "similarity": 0.07233243268301053,
        "end_line": 113,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.FilesMojoV2.getKotlinSourceDirectories(MavenProject project): Set"
      },
      {
        "start_line": 277,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/FilesMojoV2.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private SkaffoldConfiguration.Watch collectWatchParameters(MavenProject project) {\n    // Try getting extra directory from project pom\n    SkaffoldConfiguration.Watch watchConfig = new SkaffoldConfiguration.Watch();\n    Plugin jibMavenPlugin = project.getPlugin(MavenProjectProperties.PLUGIN_KEY);\n    if (jibMavenPlugin != null) {\n      Xpp3Dom pluginConfiguration = (Xpp3Dom) jibMavenPlugin.getConfiguration();\n      if (pluginConfiguration != null) {\n        Xpp3Dom skaffold = pluginConfiguration.getChild(\"skaffold\");\n        if (skaffold != null) {\n          Xpp3Dom watch = skaffold.getChild(\"watch\");\n          if (watch != null) {\n            Xpp3Dom buildIncludes = watch.getChild(\"buildIncludes\");\n            if (buildIncludes != null) {\n              watchConfig.buildIncludes = xpp3ToList(buildIncludes, File::new);\n            }\n            Xpp3Dom includes = watch.getChild(\"includes\");\n            if (includes != null) {\n              watchConfig.includes = xpp3ToList(includes, File::new);\n            }\n            Xpp3Dom excludes = watch.getChild(\"excludes\");\n            if (excludes != null) {\n              watchConfig.excludes = xpp3ToList(excludes, File::new);\n            }\n          }\n        }\n      }\n    }\n    return watchConfig;\n  }",
        "distance": 1.5,
        "title": null,
        "name": "collectWatchParameters",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "FilesMojoV2"
          },
          {
            "start_node": "FilesMojoV2",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "collectWatchParameters"
          }
        ],
        "similarity": 0.07084613410558155,
        "end_line": 305,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.FilesMojoV2.collectWatchParameters(MavenProject project): SkaffoldConfiguration"
      },
      {
        "start_line": 32,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  static Optional<Credential> getBaseImageCredential(BuildContext buildContext)",
        "distance": 1.0,
        "title": null,
        "name": "getBaseImageCredential",
        "documentation": "/** Retrieves credentials for the base image. */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "getBaseImageCredential"
          }
        ],
        "similarity": 0.06961378557773525,
        "end_line": 32,
        "signature": "com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getBaseImageCredential(BuildContext buildContext): Optional"
      },
      {
        "start_line": 96,
        "file_path": "playground/googlecontainertools__jib/jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibPlugin.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private static void checkJibVersion() {\n    // todo: should retrieve from project properties?\n    String requiredVersion = System.getProperty(REQUIRED_VERSION_PROPERTY_NAME);\n    if (requiredVersion == null) {\n      return;\n    }\n    String actualVersion = GradleProjectProperties.TOOL_VERSION;\n    if (actualVersion == null) {\n      throw new GradleException(\"Could not determine Jib plugin version\");\n    }\n    VersionChecker<GradleVersion> checker = new VersionChecker<>(GradleVersion::version);\n    if (!checker.compatibleVersion(requiredVersion, actualVersion)) {\n      String failure =\n          String.format(\n              \"Jib plugin version is %s but is required to be %s\", actualVersion, requiredVersion);\n      throw new GradleException(failure);\n    }\n  }",
        "distance": 2.0,
        "title": null,
        "name": "checkJibVersion",
        "documentation": "/** Check the Jib version matches the required version (if specified). */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "getProject"
          },
          {
            "start_node": "getProject",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "JibPluginConfiguration"
          },
          {
            "start_node": "JibPluginConfiguration",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "checkJibVersion"
          }
        ],
        "similarity": 0.0669467769204454,
        "end_line": 113,
        "signature": "com.google.cloud.tools.jib.gradle.JibPlugin.checkJibVersion(): void"
      },
      {
        "start_line": 33,
        "file_path": "playground/googlecontainertools__jib/examples/dropwizard/src/main/java/example/JibExampleApplication.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public static void main(final String[] args) throws Exception {\n    new JibExampleApplication().run(args);\n  }",
        "distance": 1.0,
        "title": null,
        "name": "main",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "main"
          }
        ],
        "similarity": 0.06654967654631178,
        "end_line": 35,
        "signature": "example.JibExampleApplication.main(String[] args): void"
      },
      {
        "start_line": 67,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/credentials/DockerConfigCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private DockerConfigCredentialRetriever(",
        "distance": 1.5,
        "title": null,
        "name": "DockerConfigCredentialRetriever",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "DockerConfigCredentialRetriever"
          },
          {
            "start_node": "DockerConfigCredentialRetriever",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "DockerConfigCredentialRetriever"
          }
        ],
        "similarity": 0.06620397587698792,
        "end_line": 67,
        "signature": "com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever(String registry, Path dockerConfigFile, boolean legacyConfigFormat)"
      },
      {
        "start_line": 99,
        "file_path": "playground/googlecontainertools__jib/jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibExtension.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public JibExtension(Project project) {\n    ObjectFactory objectFactory = project.getObjects();\n\n    from = objectFactory.newInstance(BaseImageParameters.class);\n    to = objectFactory.newInstance(TargetImageParameters.class);\n    container = objectFactory.newInstance(ContainerParameters.class);\n    extraDirectories = objectFactory.newInstance(ExtraDirectoriesParameters.class, project);\n    dockerClient = objectFactory.newInstance(DockerClientParameters.class);\n    outputPaths = objectFactory.newInstance(OutputPathsParameters.class, project);\n    skaffold = objectFactory.newInstance(SkaffoldParameters.class, project);\n\n    pluginExtensions = objectFactory.listProperty(ExtensionParameters.class).empty();\n    extensionParametersSpec =\n        objectFactory.newInstance(ExtensionParametersSpec.class, project, pluginExtensions);\n    allowInsecureRegistries = objectFactory.property(Boolean.class);\n    containerizingMode = objectFactory.property(String.class);\n\n    // Sets defaults.\n    allowInsecureRegistries.set(DEFAULT_ALLOW_INSECURE_REGISTIRIES);\n    containerizingMode.set(DEFAULT_CONTAINERIZING_MODE);\n  }",
        "distance": 2.5,
        "title": null,
        "name": "JibExtension",
        "documentation": "/**\n   * Should be called using {@link org.gradle.api.plugins.ExtensionContainer#create}.\n   *\n   * @param project the injected gradle project\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "getContainerizingMode"
          },
          {
            "start_node": "getContainerizingMode",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "JibExtension"
          },
          {
            "start_node": "JibExtension",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "JibExtension"
          }
        ],
        "similarity": 0.06155107105239909,
        "end_line": 119,
        "signature": "com.google.cloud.tools.jib.gradle.JibExtension(Project project)"
      },
      {
        "start_line": 230,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/http/FailoverHttpClient.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public Response call(String httpMethod, URL url, Request request) throws IOException {\n    if (!isHttpsProtocol(url)) {\n      if (enableHttpAndInsecureFailover) { // HTTP requested. We only care if HTTP is enabled.\n        return call(httpMethod, url, request, getHttpTransport(true));\n      }\n      throw new SSLException(\"insecure HTTP connection not allowed: \" + url);\n    }\n\n    Optional<Response> fastPathResponse = followFailoverHistory(httpMethod, url, request);\n    if (fastPathResponse.isPresent()) {\n      return fastPathResponse.get();\n    }\n\n    try {\n      return call(httpMethod, url, request, getHttpTransport(true));\n\n    } catch (SSLException ex) {\n      if (!enableHttpAndInsecureFailover) {\n        throw ex;\n      }\n\n      try {\n        logInsecureHttpsFailover(url);\n        Response response = call(httpMethod, url, request, getHttpTransport(false));\n        failoverHistory.put(url.getHost() + \":\" + url.getPort(), Failover.INSECURE_HTTPS);\n        return response;\n\n      } catch (SSLException ignored) { // This is usually when the server is plain-HTTP.\n        logHttpFailover(url);\n        Response response = call(httpMethod, toHttp(url), request, getHttpTransport(true));\n        failoverHistory.put(url.getHost() + \":\" + url.getPort(), Failover.HTTP);\n        return response;\n      }\n\n    } catch (ConnectException ex) {\n      // It is observed that Open/Oracle JDKs sometimes throw SocketTimeoutException but other times\n      // ConnectException for connection timeout. (Could be a JDK bug.) Note SocketTimeoutException\n      // does not extend ConnectException (or vice versa), and we want to be consistent to error out\n      // on timeouts: https://github.com/GoogleContainerTools/jib/issues/1895#issuecomment-527544094\n      if (ex.getMessage() == null || !ex.getMessage().contains(\"timed out\")) {\n        // Fall back to HTTP only if \"url\" had no port specified (i.e., we tried the default HTTPS\n        // port 443) and we could not connect to 443. It's worth trying port 80.\n        if (enableHttpAndInsecureFailover && isHttpsProtocol(url) && url.getPort() == -1) {\n          logHttpFailover(url);\n          Response response = call(httpMethod, toHttp(url), request, getHttpTransport(true));\n          failoverHistory.put(url.getHost() + \":\" + url.getPort(), Failover.HTTP);\n          return response;\n        }\n      }\n      throw ex;\n    }\n  }",
        "distance": 2.0,
        "title": null,
        "name": "call",
        "documentation": "/**\n   * Sends the request.\n   *\n   * @param httpMethod the HTTP request method\n   * @param url endpoint URL\n   * @param request the request to send\n   * @return the response to the sent request\n   * @throws IOException if building the HTTP request fails.\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "call"
          }
        ],
        "similarity": 0.05918672155208627,
        "end_line": 281,
        "signature": "com.google.cloud.tools.jib.http.FailoverHttpClient.call(String httpMethod, URL url, Request request): Response"
      },
      {
        "start_line": 80,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/credentials/DockerCredentialHelper.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  DockerCredentialHelper(",
        "distance": 1.5,
        "title": null,
        "name": "DockerCredentialHelper",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "DockerCredentialHelper"
          },
          {
            "start_node": "DockerCredentialHelper",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "DockerCredentialHelper"
          }
        ],
        "similarity": 0.05867254413992087,
        "end_line": 80,
        "signature": "com.google.cloud.tools.jib.registry.credentials.DockerCredentialHelper(String serverUrl, Path credentialHelper, Properties systemProperties, Function processBuilderFactory)"
      },
      {
        "start_line": 62,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/credentials/DockerConfigCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public static DockerConfigCredentialRetriever createForLegacyFormat(",
        "distance": 1.5,
        "title": null,
        "name": "createForLegacyFormat",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "DockerConfigCredentialRetriever"
          },
          {
            "start_node": "DockerConfigCredentialRetriever",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "createForLegacyFormat"
          }
        ],
        "similarity": 0.05794363834442593,
        "end_line": 62,
        "signature": "com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.createForLegacyFormat(String registry, Path dockerConfigFile): DockerConfigCredentialRetriever"
      },
      {
        "start_line": 44,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushContainerConfigurationStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  PushContainerConfigurationStep(",
        "distance": 1.5,
        "title": null,
        "name": "PushContainerConfigurationStep",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "PushContainerConfigurationStep"
          },
          {
            "start_node": "PushContainerConfigurationStep",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "PushContainerConfigurationStep"
          }
        ],
        "similarity": 0.0572932960028632,
        "end_line": 44,
        "signature": "com.google.cloud.tools.jib.builder.steps.PushContainerConfigurationStep(BuildContext buildContext, ProgressEventDispatcher progressEventDispatcherFactory, RegistryClient registryClient, Image builtImage)"
      },
      {
        "start_line": 38,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  static Optional<Credential> getTargetImageCredential(BuildContext buildContext)",
        "distance": 1.5,
        "title": null,
        "name": "getTargetImageCredential",
        "documentation": "/** Retrieves credentials for the target image. */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "getBaseImageCredential"
          },
          {
            "start_node": "getBaseImageCredential",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "RegistryCredentialRetriever"
          },
          {
            "start_node": "RegistryCredentialRetriever",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "getTargetImageCredential"
          }
        ],
        "similarity": 0.05560116027671862,
        "end_line": 38,
        "signature": "com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getTargetImageCredential(BuildContext buildContext): Optional"
      },
      {
        "start_line": 240,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/frontend/CredentialRetrieverFactory.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public CredentialRetriever googleApplicationDefaultCredentials() {\n    return () -> {\n      try {\n        if (imageReference.getRegistry().endsWith(\"gcr.io\")) {\n          GoogleCredentials googleCredentials = googleCredentialsProvider.get();\n          logger.accept(LogEvent.info(\"Google ADC found\"));\n          if (googleCredentials.createScopedRequired()) { // not scoped if service account\n            // The short-lived OAuth2 access token to be generated from the service account with\n            // refreshIfExpired() below will have one-hour expiry (as of Aug 2019). Instead of using\n            // an access token, it is technically possible to use the service account private key to\n            // auth with GCR, but it does not worth writing complex code to achieve that.\n            logger.accept(LogEvent.info(\"ADC is a service account. Setting GCS read-write scope\"));\n            List<String> scope = Collections.singletonList(OAUTH_SCOPE_STORAGE_READ_WRITE);\n            googleCredentials = googleCredentials.createScoped(scope);\n          }\n          googleCredentials.refreshIfExpired();\n\n          logGotCredentialsFrom(\"Google Application Default Credentials\");\n          AccessToken accessToken = googleCredentials.getAccessToken();\n          // https://cloud.google.com/container-registry/docs/advanced-authentication#access_token\n          return Optional.of(Credential.from(\"oauth2accesstoken\", accessToken.getTokenValue()));\n        }\n\n      } catch (IOException ex) { // Includes the case where ADC is simply not available.\n        logger.accept(\n            LogEvent.info(\"ADC not present or error fetching access token: \" + ex.getMessage()));\n      }\n      return Optional.empty();\n    };\n  }",
        "distance": 2.5,
        "title": null,
        "name": "googleApplicationDefaultCredentials",
        "documentation": "/**\n   * Creates a new {@link CredentialRetriever} that tries to retrieve credentials from <a\n   * href=\"https://cloud.google.com/docs/authentication/production\">Google Application Default\n   * Credentials</a>.\n   *\n   * @return a new {@link CredentialRetriever}\n   * @see <a\n   *     href=\"https://cloud.google.com/docs/authentication/production\">https://cloud.google.com/docs/authentication/production</a>\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "retrieveFromDockerCredentialHelper"
          },
          {
            "start_node": "retrieveFromDockerCredentialHelper",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "CredentialRetrieverFactory"
          },
          {
            "start_node": "CredentialRetrieverFactory",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "googleApplicationDefaultCredentials"
          }
        ],
        "similarity": 0.05551260079776525,
        "end_line": 269,
        "signature": "com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.googleApplicationDefaultCredentials(): CredentialRetriever"
      },
      {
        "start_line": 187,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryEndpointCaller.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  RegistryErrorException newRegistryErrorException(ResponseException responseException) {\n    RegistryErrorExceptionBuilder registryErrorExceptionBuilder =\n        new RegistryErrorExceptionBuilder(\n            registryEndpointProvider.getActionDescription(), responseException);\n\n    try {\n      ErrorResponseTemplate errorResponse =\n          JsonTemplateMapper.readJson(responseException.getContent(), ErrorResponseTemplate.class);\n      for (ErrorEntryTemplate errorEntry : errorResponse.getErrors()) {\n        registryErrorExceptionBuilder.addReason(errorEntry);\n      }\n    } catch (IOException ex) {\n      registryErrorExceptionBuilder.addReason(\n          \"registry returned error code \"\n              + responseException.getStatusCode()\n              + \"; possible causes include invalid or wrong reference. Actual error output follows:\\n\"\n              + responseException.getContent()\n              + \"\\n\");\n    }\n\n    return registryErrorExceptionBuilder.build();\n  }",
        "distance": 1.5,
        "title": null,
        "name": "newRegistryErrorException",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "RegistryEndpointCaller"
          },
          {
            "start_node": "RegistryEndpointCaller",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "newRegistryErrorException"
          }
        ],
        "similarity": 0.054798644640189936,
        "end_line": 208,
        "signature": "com.google.cloud.tools.jib.registry.RegistryEndpointCaller.newRegistryErrorException(ResponseException responseException): RegistryErrorException"
      },
      {
        "start_line": 49,
        "file_path": "playground/googlecontainertools__jib/examples/dropwizard/src/main/java/example/JibExampleApplication.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void run(final JibExampleConfiguration configuration, final Environment environment) {\n    final TemplateHealthCheck healthCheck =\n        new TemplateHealthCheck(configuration.getHelloConfiguration().getTemplate());\n    environment.healthChecks().register(\"template\", healthCheck);\n\n    environment.jersey().register(HelloWorldResource.from(configuration));\n  }",
        "distance": 1.0,
        "title": null,
        "name": "run",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "run"
          }
        ],
        "similarity": 0.05289120441216745,
        "end_line": 55,
        "signature": "example.JibExampleApplication.run(JibExampleConfiguration configuration, Environment environment): void"
      },
      {
        "start_line": 43,
        "file_path": "playground/googlecontainertools__jib/examples/dropwizard/src/main/java/example/JibExampleApplication.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public void initialize(final Bootstrap<JibExampleConfiguration> bootstrap) {\n    // Enable FreeMarker config templates\n    bootstrap.addBundle(new TemplateConfigBundle());\n  }",
        "distance": 1.5,
        "title": null,
        "name": "initialize",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "main"
          },
          {
            "start_node": "main",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "JibExampleApplication"
          },
          {
            "start_node": "JibExampleApplication",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "initialize"
          }
        ],
        "similarity": 0.05054555666157883,
        "end_line": 46,
        "signature": "example.JibExampleApplication.initialize(Bootstrap bootstrap): void"
      },
      {
        "start_line": 221,
        "file_path": "playground/googlecontainertools__jib/jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/JibBuildRunner.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public JibContainer runBuild()",
        "distance": 2.0,
        "title": null,
        "name": "runBuild",
        "documentation": "/**\n   * Runs the Jib build.\n   *\n   * @return the built {@link JibContainer}\n   * @throws BuildStepsExecutionException if another exception is thrown during the build\n   * @throws IOException if an I/O exception occurs\n   * @throws CacheDirectoryCreationException if the cache directory could not be created\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "runBuild"
          }
        ],
        "similarity": 0.04847413948070163,
        "end_line": 221,
        "signature": "com.google.cloud.tools.jib.plugins.common.JibBuildRunner.runBuild(): JibContainer"
      },
      {
        "start_line": 61,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/MavenSettingsServerCredentials.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public Optional<AuthProperty> inferAuth(String registry) throws InferredAuthException {\n\n    Server server = getServerFromMavenSettings(registry);\n    if (server == null) {\n      return Optional.empty();\n    }\n\n    SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(server);\n    SettingsDecryptionResult result = decrypter.decrypt(request);\n    // Un-encrypted passwords are passed through, so a problem indicates a real issue.\n    // If there are any ERROR or FATAL problems reported, then decryption failed.\n    for (SettingsProblem problem : result.getProblems()) {\n      if (problem.getSeverity() == SettingsProblem.Severity.ERROR\n          || problem.getSeverity() == SettingsProblem.Severity.FATAL) {\n        throw new InferredAuthException(\n            \"Unable to decrypt server(\" + registry + \") info from settings.xml: \" + problem);\n      }\n    }\n    Server resultServer = result.getServer();\n\n    String username = resultServer.getUsername();\n    String password = resultServer.getPassword();\n\n    return Optional.of(\n        new AuthProperty() {\n\n          @Override\n          public String getUsername() {\n            return username;\n          }\n\n          @Override\n          public String getPassword() {\n            return password;\n          }\n\n          @Override\n          public String getAuthDescriptor() {\n            return CREDENTIAL_SOURCE;\n          }\n\n          @Override\n          public String getUsernameDescriptor() {\n            return CREDENTIAL_SOURCE;\n          }\n\n          @Override\n          public String getPasswordDescriptor() {\n            return CREDENTIAL_SOURCE;\n          }\n        });\n  }",
        "distance": 2.5,
        "title": null,
        "name": "inferAuth",
        "documentation": "/**\n   * Retrieves credentials for {@code registry} from Maven settings.\n   *\n   * @param registry the registry\n   * @return the auth info for the registry, or {@link Optional#empty} if none could be retrieved\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "MavenSettingsServerCredentials"
          },
          {
            "start_node": "MavenSettingsServerCredentials",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "MavenSettingsServerCredentials"
          },
          {
            "start_node": "MavenSettingsServerCredentials",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "inferAuth"
          }
        ],
        "similarity": 0.048381817365057346,
        "end_line": 112,
        "signature": "com.google.cloud.tools.jib.maven.MavenSettingsServerCredentials.inferAuth(String registry): Optional"
      },
      {
        "start_line": 40,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/LoadDockerStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  LoadDockerStep(",
        "distance": 1.5,
        "title": null,
        "name": "LoadDockerStep",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "LoadDockerStep"
          },
          {
            "start_node": "LoadDockerStep",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "LoadDockerStep"
          }
        ],
        "similarity": 0.04779493552450601,
        "end_line": 40,
        "signature": "com.google.cloud.tools.jib.builder.steps.LoadDockerStep(BuildContext buildContext, ProgressEventDispatcher progressEventDispatcherFactory, DockerClient dockerClient, Image builtImage)"
      },
      {
        "start_line": 732,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/JibPluginConfiguration.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  boolean isContainerizable() {\n    String moduleSpecification = getProperty(PropertyNames.CONTAINERIZE);\n    if (project == null || Strings.isNullOrEmpty(moduleSpecification)) {\n      return true;\n    }\n    // modules can be specified in one of three ways:\n    // 1) a `groupId:artifactId`\n    // 2) an `:artifactId`\n    // 3) relative path within the repository\n    if (moduleSpecification.equals(project.getGroupId() + \":\" + project.getArtifactId())\n        || moduleSpecification.equals(\":\" + project.getArtifactId())) {\n      return true;\n    }\n    // Relative paths never have a colon on *nix nor Windows.  This moduleSpecification could be an\n    // :artifactId or groupId:artifactId for a different artifact.\n    if (moduleSpecification.contains(\":\")) {\n      return false;\n    }\n    try {\n      Path projectBase = project.getBasedir().toPath();\n      return projectBase.endsWith(moduleSpecification);\n    } catch (InvalidPathException ex) {\n      // ignore since moduleSpecification may not actually be a path\n      return false;\n    }\n  }",
        "distance": 2.5,
        "title": null,
        "name": "isContainerizable",
        "documentation": "/**\n   * Return false if the `jib.containerize` property is specified and does not match this\n   * module/project. Used by the Skaffold-Jib binding.\n   *\n   * @return true if this module should be containerized\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "getProject"
          },
          {
            "start_node": "getProject",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "JibPluginConfiguration"
          },
          {
            "start_node": "JibPluginConfiguration",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "isContainerizable"
          }
        ],
        "similarity": 0.0462137209589752,
        "end_line": 757,
        "signature": "com.google.cloud.tools.jib.maven.JibPluginConfiguration.isContainerizable(): boolean"
      },
      {
        "start_line": 120,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/ObtainBaseImageLayerStep.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private ObtainBaseImageLayerStep(",
        "distance": 1.5,
        "title": null,
        "name": "ObtainBaseImageLayerStep",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "ObtainBaseImageLayerStep"
          },
          {
            "start_node": "ObtainBaseImageLayerStep",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "ObtainBaseImageLayerStep"
          }
        ],
        "similarity": 0.046022093149924226,
        "end_line": 120,
        "signature": "com.google.cloud.tools.jib.builder.steps.ObtainBaseImageLayerStep(BuildContext buildContext, ProgressEventDispatcher progressEventDispatcherFactory, Layer layer, RegistryClient registryClient, BlobExistenceChecker blobExistenceChecker)"
      },
      {
        "start_line": 229,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/FilesMojoV2.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  private List<Path> resolveExtraDirectories(MavenProject project) {\n    return collectExtraDirectories(project)\n        .stream()\n        .map(path -> path.isAbsolute() ? path : project.getBasedir().toPath().resolve(path))\n        .collect(Collectors.toList());\n  }",
        "distance": 1.5,
        "title": null,
        "name": "resolveExtraDirectories",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "FilesMojoV2"
          },
          {
            "start_node": "FilesMojoV2",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "resolveExtraDirectories"
          }
        ],
        "similarity": 0.04560016157639515,
        "end_line": 234,
        "signature": "com.google.cloud.tools.jib.maven.skaffold.FilesMojoV2.resolveExtraDirectories(MavenProject project): List"
      },
      {
        "start_line": 194,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  static Multimap<String, String> decodeTokenRepositoryGrants(String token) {\n    // Docker Registry Bearer Tokens are based on JWT.  A valid JWT is a set of 3 base64-encoded\n    // parts (header, payload, signature), collated with a \".\".  The header and payload are\n    // JSON objects.\n    String[] jwtParts = token.split(\"\\\\.\", -1);\n    byte[] payloadData;\n    if (jwtParts.length != 3 || (payloadData = Base64.decodeBase64(jwtParts[1])) == null) {\n      return null;\n    }\n\n    // The payload looks like:\n    // {\n    //   \"access\":[{\"type\":\"repository\",\"name\":\"repository/name\",\"actions\":[\"pull\"]}],\n    //   \"aud\":\"registry.docker.io\",\n    //   \"iss\":\"auth.docker.io\",\n    //   \"exp\":999,\n    //   \"iat\":999,\n    //   \"jti\":\"zzzz\",\n    //   \"nbf\":999,\n    //   \"sub\":\"e3ae001d-xxx\"\n    // }\n    //\n    try {\n      TokenPayloadTemplate payload =\n          JsonTemplateMapper.readJson(payloadData, TokenPayloadTemplate.class);\n      if (payload.access == null) {\n        return null;\n      }\n      return payload\n          .access\n          .stream()\n          .filter(claim -> \"repository\".equals(claim.type))\n          .collect(\n              ImmutableSetMultimap.<AccessClaim, String, String>flatteningToImmutableSetMultimap(\n                  claim -> claim.name,\n                  claim -> claim.actions == null ? Stream.empty() : claim.actions.stream()));\n    } catch (IOException ex) {\n      return null;\n    }\n  }",
        "distance": 2.5,
        "title": null,
        "name": "decodeTokenRepositoryGrants",
        "documentation": "/**\n   * Decode the <a href=\"https://docs.docker.com/registry/spec/auth/jwt/\">Docker Registry v2 Bearer\n   * Token</a> to list the granted repositories with their levels of access.\n   *\n   * @param token a Docker Registry Bearer Token\n   * @return a mapping of repository to granted access scopes, or {@code null} if the token is not a\n   *     Docker Registry Bearer Token\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "callRegistryEndpoint"
          },
          {
            "start_node": "callRegistryEndpoint",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "RegistryClient"
          },
          {
            "start_node": "RegistryClient",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "decodeTokenRepositoryGrants"
          }
        ],
        "similarity": 0.044608061589972235,
        "end_line": 233,
        "signature": "com.google.cloud.tools.jib.registry.RegistryClient.decodeTokenRepositoryGrants(String token): Multimap"
      },
      {
        "start_line": 162,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/frontend/CredentialRetrieverFactory.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  public CredentialRetriever wellKnownCredentialHelpers() {\n    return () -> {\n      for (Map.Entry<String, String> entry : WELL_KNOWN_CREDENTIAL_HELPERS.entrySet()) {\n        try {\n          String registrySuffix = entry.getKey();\n          if (imageReference.getRegistry().endsWith(registrySuffix)) {\n            String credentialHelper = entry.getValue();\n            return Optional.of(retrieveFromDockerCredentialHelper(Paths.get(credentialHelper)));\n          }\n\n        } catch (CredentialHelperNotFoundException\n            | CredentialHelperUnhandledServerUrlException ex) {\n          if (ex.getMessage() != null) {\n            // Warns the user that the specified (or inferred) credential helper cannot be used.\n            logger.accept(LogEvent.info(ex.getMessage()));\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n              logger.accept(LogEvent.info(\"  Caused by: \" + ex.getCause().getMessage()));\n            }\n          }\n\n        } catch (IOException ex) {\n          throw new CredentialRetrievalException(ex);\n        }\n      }\n      return Optional.empty();\n    };\n  }",
        "distance": 2.5,
        "title": null,
        "name": "wellKnownCredentialHelpers",
        "documentation": "/**\n   * Creates a new {@link CredentialRetriever} that tries well-known Docker credential helpers to\n   * retrieve credentials based on the registry of the image, such as {@code docker-credential-gcr}\n   * for images with the registry ending with {@code gcr.io}.\n   *\n   * @return a new {@link CredentialRetriever}\n   */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "retrieve"
          },
          {
            "start_node": "retrieve",
            "description": "called by method",
            "type": "RELATED",
            "end_node": "retrieveFromDockerCredentialHelper"
          },
          {
            "start_node": "retrieveFromDockerCredentialHelper",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "CredentialRetrieverFactory"
          },
          {
            "start_node": "CredentialRetrieverFactory",
            "description": "contains method",
            "type": "RELATED",
            "end_node": "wellKnownCredentialHelpers"
          }
        ],
        "similarity": 0.044335082423159755,
        "end_line": 188,
        "signature": "com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.wellKnownCredentialHelpers(): CredentialRetriever"
      },
      {
        "start_line": 119,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/api/JibContainerBuilder.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  JibContainerBuilder(",
        "distance": 2.5,
        "title": null,
        "name": "JibContainerBuilder",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "setUser"
          },
          {
            "start_node": "setUser",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "JibContainerBuilder"
          },
          {
            "start_node": "JibContainerBuilder",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "JibContainerBuilder"
          }
        ],
        "similarity": 0.0436463461769299,
        "end_line": 119,
        "signature": "com.google.cloud.tools.jib.api.JibContainerBuilder(ImageConfiguration imageConfiguration, BuildContext buildContextBuilder)"
      },
      {
        "start_line": 90,
        "file_path": "playground/googlecontainertools__jib/jib-core/src/main/java/com/google/cloud/tools/jib/api/JibContainerBuilder.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  JibContainerBuilder(RegistryImage baseImage) {\n    this(\n        ImageConfiguration.builder(baseImage.getImageReference())\n            .setCredentialRetrievers(baseImage.getCredentialRetrievers())\n            .build(),\n        BuildContext.builder());\n  }",
        "distance": 2.5,
        "title": null,
        "name": "JibContainerBuilder",
        "documentation": "/** Instantiate with {@link Jib#from}. */",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "call"
          },
          {
            "start_node": "call",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "setUser"
          },
          {
            "start_node": "setUser",
            "description": "contained in method",
            "type": "RELATED",
            "end_node": "JibContainerBuilder"
          },
          {
            "start_node": "JibContainerBuilder",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "JibContainerBuilder"
          }
        ],
        "similarity": 0.04362471006824524,
        "end_line": 96,
        "signature": "com.google.cloud.tools.jib.api.JibContainerBuilder(RegistryImage baseImage)"
      },
      {
        "start_line": 328,
        "file_path": "playground/googlecontainertools__jib/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/JibPluginConfiguration.java",
        "issue_id": null,
        "type": "method",
        "content": null,
        "source_code": "  protected void checkJibVersion() throws MojoExecutionException {\n    Preconditions.checkNotNull(descriptor);\n    MojoCommon.checkJibVersion(descriptor);\n  }",
        "distance": 2.5,
        "title": null,
        "name": "checkJibVersion",
        "documentation": "",
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "execute"
          },
          {
            "start_node": "execute",
            "description": "calls method",
            "type": "RELATED",
            "end_node": "getProject"
          },
          {
            "start_node": "getProject",
            "description": "contained in class",
            "type": "RELATED",
            "end_node": "JibPluginConfiguration"
          },
          {
            "start_node": "JibPluginConfiguration",
            "description": "contains class",
            "type": "RELATED",
            "end_node": "checkJibVersion"
          }
        ],
        "similarity": 0.04336688997950313,
        "end_line": 331,
        "signature": "com.google.cloud.tools.jib.maven.JibPluginConfiguration.checkJibVersion(): void"
      }
    ],
    "classes": [],
    "issues": [
      {
        "content": "@Gsealy reported NPE on Jib 2.4.0. This looks like a regression introduced by #2489.\r\n\r\n---\r\n\r\n**Environment\uff1a** \r\nWindows Terminal \r\n```\r\nApache Maven 3.6.0 (Cannot get information of commit 97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)\r\nMaven home: C:\\apache-maven\\bin\\..\r\nJava version: 11, vendor: Oracle Corporation, runtime: C:\\Java\\jdk-11\r\nDefault locale: zh_CN, platform encoding: GBK\r\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\r\n```\r\ndocker for windows version: \r\n```\r\ndocker desktop: 2.3.0(45519)\r\nDocker version 19.03.8, build afacb8b\r\nCredntial Helper: 0.6.3\r\n```\r\n\r\n**`jib-maven-plugin` Configuration:**\r\n```\r\n     <plugin>\r\n        <groupId>com.google.cloud.tools</groupId>\r\n        <artifactId>jib-maven-plugin</artifactId>\r\n        <version>2.4.0</version>\r\n        <configuration>\r\n          <from>\r\n            <image>hub.gsealy.cn/base-image/jdk:11.0</image>\r\n          </from>\r\n          <to>\r\n            <image>spring-boot-jib</image>\r\n          </to>\r\n          <allowInsecureRegistries>true</allowInsecureRegistries>\r\n          <container>\r\n            <ports>\r\n              <port>9999</port>\r\n            </ports>\r\n          </container>\r\n        </configuration>\r\n      </plugin>\r\n```\r\n**description:**\r\nwe are use harbor for docker registry at inner network, and use Let's encrypt cert for ssl. `2.3.0` also print warning but build succeed.\r\nI don't find `docker-credential-desktop.cmd` in system, just have `docker-credential-desktop.exe`\r\n\r\n```\r\n... omit ...\r\n[DEBUG] trying docker-credential-desktop for hub.gsealy.cn\r\n[WARNING] Cannot run program \"docker-credential-desktop.cmd\": CreateProcess error=2, cannot find the file.\r\n[WARNING]   Caused by: CreateProcess error=2, cannot find the file.\r\n... omit ...\r\n```\r\nbut `2.4.0` was facing the NPE\r\n```\r\n[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project\r\n jib: (null exception message): NullPointerException -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project jib: (null exception message)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: (null exception message)\r\n    at com.google.cloud.tools.jib.maven.BuildTarMojo.execute (BuildTarMojo.java:140)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: java.lang.NullPointerException\r\n    at java.lang.String.<init> (String.java:561)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:146)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:104)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerConfig$4 (CredentialRetrieverFactory.java:277)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getBaseImageCredential (RegistryCredentialRetriever.java:34)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:134)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:56)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n    at java.lang.Thread.run (Thread.java:834)\r\n```\r\n\r\n_Originally posted by @Gsealy in https://github.com/GoogleContainerTools/jib/issues/2527#issuecomment-646463172_\n",
        "distance": 0,
        "title": "Possible NPE from DockerConfigCredentialRetriever with 2.4.0",
        "name": "root",
        "path": [],
        "issue_id": "root",
        "similarity": 2.0,
        "type": "issue"
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2535",
        "type": "issue",
        "content": "@Gsealy reported NPE on Jib 2.4.0. This looks like a regression introduced by #2489.\r\n\r\n---\r\n\r\n**Environment\uff1a** \r\nWindows Terminal \r\n```\r\nApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)\r\nMaven home: C:\\apache-maven\\bin\\..\r\nJava version: 11, vendor: Oracle Corporation, runtime: C:\\Java\\jdk-11\r\nDefault locale: zh_CN, platform encoding: GBK\r\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\r\n```\r\ndocker for windows version: \r\n```\r\ndocker desktop: 2.3.0(45519)\r\nDocker version 19.03.8, build afacb8b\r\nCredntial Helper: 0.6.3\r\n```\r\n\r\n**`jib-maven-plugin` Configuration:**\r\n```\r\n     <plugin>\r\n        <groupId>com.google.cloud.tools</groupId>\r\n        <artifactId>jib-maven-plugin</artifactId>\r\n        <version>2.4.0</version>\r\n        <configuration>\r\n          <from>\r\n            <image>hub.gsealy.cn/base-image/jdk:11.0</image>\r\n          </from>\r\n          <to>\r\n            <image>spring-boot-jib</image>\r\n          </to>\r\n          <allowInsecureRegistries>true</allowInsecureRegistries>\r\n          <container>\r\n            <ports>\r\n              <port>9999</port>\r\n            </ports>\r\n          </container>\r\n        </configuration>\r\n      </plugin>\r\n```\r\n**description:**\r\nwe are use harbor for docker registry at inner network, and use Let's encrypt cert for ssl. `2.3.0` also print warning but build succeed.\r\nI don't find `docker-credential-desktop.cmd` in system, just have `docker-credential-desktop.exe`\r\n\r\n```\r\n... omit ...\r\n[DEBUG] trying docker-credential-desktop for hub.gsealy.cn\r\n[WARNING] Cannot run program \"docker-credential-desktop.cmd\": CreateProcess error=2, cannot find the file.\r\n[WARNING]   Caused by: CreateProcess error=2, cannot find the file.\r\n... omit ...\r\n```\r\nbut `2.4.0` was facing the NPE\r\n```\r\n[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project\r\n jib: (null exception message): NullPointerException -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project jib: (null exception message)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: (null exception message)\r\n    at com.google.cloud.tools.jib.maven.BuildTarMojo.execute (BuildTarMojo.java:140)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: java.lang.NullPointerException\r\n    at java.lang.String.<init> (String.java:561)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:146)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:104)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerConfig$4 (CredentialRetrieverFactory.java:277)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getBaseImageCredential (RegistryCredentialRetriever.java:34)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:134)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:56)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n    at java.lang.Thread.run (Thread.java:834)\r\n```\r\n\r\n_Originally posted by @Gsealy in https://github.com/GoogleContainerTools/jib/issues/2527#issuecomment-646463172_\n\n\nComment by chanseokoh:\n@Gsealy we will fix this bug in the upcoming release (most likely 2.5.0).\r\n\r\nHowever, this is unrelated to #2527 (that is, the issue about the `.cmd` or `.exe` suffix). I don't think a credential helper was ever used, even in 2.3.0.\r\n\r\nThe triggering factor is probably that there is an entry in the `auths` section in `~/.docker/config.json` that doesn't have an `\"auth\":` field. For example,\r\n```\r\n{\r\n    \"auths\": {\r\n        \"docker.pkg.github.com\": {\r\n            \"auth\": ...      <-- For example, this entry has \"auth\".\r\n        },\r\n        \"hub.gsealy.cn\": {      <-- Maybe your entry doesn't have \"auth\"? (Not that this is wrong.)\r\n            \"identityToken\": ...\r\n        },\r\n```\r\nSo, if it worked with 2.3.0, I think a workaround would be to remove the `\"hub.gsealy.cn\"` entry that does not have the `\"auth\":` field. And I also suggest you test removing all the entries that don't have `\"auth\":` or the entire `auths` section.\r\n\r\nIn any case, we will fix this, and the next version will not throw NPE whether or not an entry has the `auth` field.",
        "source_code": null,
        "distance": 0.25,
        "title": "Possible NPE from DockerConfigCredentialRetriever with 2.4.0",
        "name": "issue#2535",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2535"
          }
        ],
        "similarity": 0.8796010609851168,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2527",
        "type": "issue",
        "content": "**Environment**: git-bash\r\n\r\nApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)\r\nJava version: 1.8.0_252, vendor: Azul Systems, Inc., runtime: D:\\Dev\\Java\\jdk8x64\\jre\r\nDefault locale: de_DE, platform encoding: Cp1252\r\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\r\n\r\n- *Jib version:* 2.4.0\r\n- *Build tool:* maven 3.6.3\r\n- *OS:* windows\r\n\r\n**Description of the issue**:\r\n\r\nI installed \"docker-credential-ecr-login\" ... and I can use it :)\r\n\r\nMINGW64 /d/Dev/git/coc/spice-configuration-cluster (develop)\r\n$ docker-credential-ecr-login list                                            \r\n{\"https://XXXXXXXXX.dkr.ecr.eu-west-1.amazonaws.com\":\"AWS\"}                \r\n                                                                              \r\nMINGW64 /d/Dev/git/coc/spice-configuration-cluster (develop)\r\n$ docker-credential-ecr-login version                                         \r\n0.6.3                                                                         \r\n                                                                              \r\nMINGW64 /d/Dev/git/coc/spice-configuration-cluster (develop)\r\n$ which docker-credential-ecr-login                                           \r\n/c/Users/hoehmann/go/bin/docker-credential-ecr-login                          \r\n\r\nBut inside the jib-run it doesn't work.\r\nIt seems that jib is trying to execute docker-credential-ecr-login.cmd\r\ninstead of docker-credential-ecr-login.exe or docker-credential-ecr-login\r\n\r\n**Expected behavior**:\r\n\r\ndocker-credential-ecr-login should work under windows-git-bash as well\r\n\r\n**Steps to reproduce**:\r\n\r\n  1.  installed docker-credential-ecr-login with \"go get -u github.com/awslabs/amazon-ecr-credential-helper/ecr-login/cli/docker-credential-ecr-login\"\r\n  2.  add jib-maven-plugin\r\n  3. run maven\r\n\r\n**`jib-maven-plugin` Configuration**: <!-- Delete this section if not used -->\r\n```xml\r\n<configuration>\r\n            <to>\r\n              <image>${aws.ecr.url}/${finalName}:latest</image>\r\n              <credHelper>ecr-login</credHelper>\r\n            </to>\r\n            <container>\r\n              <creationTime>USE_CURRENT_TIMESTAMP</creationTime>\r\n              <ports>\r\n                <port>8080</port>\r\n              </ports>\r\n            </container>\r\n          </configuration>\r\n```\r\n\r\n**Log output**: <!-- If applicable, provide relevant log output -->\r\n\r\n[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:build (default-cli) on project rest-service-sce: java.io.IOException: Cannot run program \"docker-credential-ecr-login.cmd\": CreateProcess error=2, Das System kann die angegebene Datei nicht finden -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:build (default-cli) on project rest-service-sce: java.io.IOException: Cannot run program \"docker-credential-ecr-login.cmd\": CreateProcess error=2, Das System kann die angegebene Datei nicht finden\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:957)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:289)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:193)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:498)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: java.io.IOException: Cannot run program \"docker-credential-ecr-login.cmd\": CreateProcess error=2, Das System kann die angegebene Datei nicht finden\r\n    at com.google.cloud.tools.jib.maven.BuildImageMojo.execute (BuildImageMojo.java:162)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:957)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:289)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:193)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:498)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\nCaused by: com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException: java.io.IOException: Cannot run program \"docker-credential-ecr-login.cmd\": CreateProcess error=2, Das System kann die angegebene Datei nicht finden\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerCredentialHelper$1 (CredentialRetrieverFactory.java:150)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getTargetImageCredential (RegistryCredentialRetriever.java:40)\r\n    at com.google.cloud.tools.jib.builder.steps.AuthenticatePushStep.call (AuthenticatePushStep.java:57)\r\n    at com.google.cloud.tools.jib.builder.steps.StepsRunner.lambda$authenticateBearerPush$3 (StepsRunner.java:236)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)\r\n    at java.lang.Thread.run (Thread.java:748)\r\nCaused by: java.io.IOException: Cannot run program \"docker-credential-ecr-login.cmd\": CreateProcess error=2, Das System kann die angegebene Datei nicht finden\r\n    at java.lang.ProcessBuilder.start (ProcessBuilder.java:1048)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerCredentialHelper.retrieve (DockerCredentialHelper.java:132)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerCredentialHelper.retrieve (DockerCredentialHelper.java:117)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.retrieveFromDockerCredentialHelper (CredentialRetrieverFactory.java:296)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerCredentialHelper$1 (CredentialRetrieverFactory.java:141)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getTargetImageCredential (RegistryCredentialRetriever.java:40)\r\n    at com.google.cloud.tools.jib.builder.steps.AuthenticatePushStep.call (AuthenticatePushStep.java:57)\r\n    at com.google.cloud.tools.jib.builder.steps.StepsRunner.lambda$authenticateBearerPush$3 (StepsRunner.java:236)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)\r\n    at java.lang.Thread.run (Thread.java:748)\r\nCaused by: java.io.IOException: CreateProcess error=2, Das System kann die angegebene Datei nicht finden\r\n    at java.lang.ProcessImpl.create (Native Method)\r\n    at java.lang.ProcessImpl.<init> (ProcessImpl.java:444)\r\n    at java.lang.ProcessImpl.start (ProcessImpl.java:139)\r\n    at java.lang.ProcessBuilder.start (ProcessBuilder.java:1029)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerCredentialHelper.retrieve (DockerCredentialHelper.java:132)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerCredentialHelper.retrieve (DockerCredentialHelper.java:117)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.retrieveFromDockerCredentialHelper (CredentialRetrieverFactory.java:296)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerCredentialHelper$1 (CredentialRetrieverFactory.java:141)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getTargetImageCredential (RegistryCredentialRetriever.java:40)\r\n    at com.google.cloud.tools.jib.builder.steps.AuthenticatePushStep.call (AuthenticatePushStep.java:57)\r\n    at com.google.cloud.tools.jib.builder.steps.StepsRunner.lambda$authenticateBearerPush$3 (StepsRunner.java:236)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)\r\n    at java.lang.Thread.run (Thread.java:748)\r\n\r\n**Additional Information**: <!-- Any additional information that may be helpful -->\r\nmvn -DskipTests -Denforcer.skip -nsu jib:build -X\r\n\r\n<!-- Thanks for contributing! -->\r\n\n\n\nComment by loosebazooka:\nprobably related to this PR: https://github.com/GoogleContainerTools/jib/pull/2403\n\nComment by loosebazooka:\n@ahoehma was this working before, and stopped working when you upgraded to `2.4.0`?\n\nComment by chanseokoh:\n> @ahoehma was this working before, and stopped working when you upgraded to 2.4.0?\r\n\r\nI am also curious. For now, I think you can set\r\n```xml\r\n    <credHelper>ecr-login.exe</credHelper>\r\n```\n\nComment by ahoehma:\n@chanseokoh ... was never working before :)\n\nComment by ahoehma:\n@chanseokoh  .... today I tried your suggestion 'ecr-login.exe' ... and this works :) with 2.4.0 too.\n\nComment by Gsealy:\n@chanseokoh same issue, use `2.3.0` build success, `2.4.0` occur this error\r\n\r\n**Environment\uff1a** \r\nWindows Terminal \r\n```\r\nApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)\r\nMaven home: C:\\apache-maven\\bin\\..\r\nJava version: 11, vendor: Oracle Corporation, runtime: C:\\Java\\jdk-11\r\nDefault locale: zh_CN, platform encoding: GBK\r\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\r\n```\r\ndocker for windows version: \r\n```\r\ndocker desktop: 2.3.0(45519)\r\nDocker version 19.03.8, build afacb8b\r\nCredntial Helper: 0.6.3\r\n```\r\n\r\n**`jib-maven-plugin` Configuration:**\r\n```\r\n     <plugin>\r\n        <groupId>com.google.cloud.tools</groupId>\r\n        <artifactId>jib-maven-plugin</artifactId>\r\n        <version>2.4.0</version>\r\n        <configuration>\r\n          <from>\r\n            <image>hub.gsealy.cn/base-image/jdk:11.0</image>\r\n          </from>\r\n          <to>\r\n            <image>spring-boot-jib</image>\r\n          </to>\r\n          <allowInsecureRegistries>true</allowInsecureRegistries>\r\n          <container>\r\n            <ports>\r\n              <port>9999</port>\r\n            </ports>\r\n          </container>\r\n        </configuration>\r\n      </plugin>\r\n```\r\n**description:**\r\nwe are use harbor for docker registry at inner network, and use Let's encrypt cert for ssl. `2.3.0` also print warning but build succeed.\r\nI don't find `docker-credential-desktop.cmd` in system, just have `docker-credential-desktop.exe`\r\n\r\n```\r\n... omit ...\r\n[DEBUG] trying docker-credential-desktop for hub.gsealy.cn\r\n[WARNING] Cannot run program \"docker-credential-desktop.cmd\": CreateProcess error=2, cannot find the file.\r\n[WARNING]   Caused by: CreateProcess error=2, cannot find the file.\r\n... omit ...\r\n```\r\nbut `2.4.0` was facing the NPE\r\n```\r\n[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project\r\n jib: (null exception message): NullPointerException -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.4.0:buildTar (default-cli) on project jib: (null exception message)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: (null exception message)\r\n    at com.google.cloud.tools.jib.maven.BuildTarMojo.execute (BuildTarMojo.java:140)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: java.lang.NullPointerException\r\n    at java.lang.String.<init> (String.java:561)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:146)\r\n    at com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve (DockerConfigCredentialRetriever.java:104)\r\n    at com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory.lambda$dockerConfig$4 (CredentialRetrieverFactory.java:277)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.retrieve (RegistryCredentialRetriever.java:47)\r\n    at com.google.cloud.tools.jib.builder.steps.RegistryCredentialRetriever.getBaseImageCredential (RegistryCredentialRetriever.java:34)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:134)\r\n    at com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.call (PullBaseImageStep.java:56)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly (TrustedListenableFutureTask.java:125)\r\n    at com.google.common.util.concurrent.InterruptibleTask.run (InterruptibleTask.java:69)\r\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run (TrustedListenableFutureTask.java:78)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:628)\r\n    at java.lang.Thread.run (Thread.java:834)\r\n```\r\n\n\nComment by ahoehma:\nI'm able to run now my build ....\r\n\r\njib:build -Djib.to.credHelper=ecr-login.exe\r\n\r\nworks for me.\r\n\r\nI removed all the auth-stuff from my pom.xml:\r\n\r\n```xml\r\n<plugin>\r\n          <groupId>com.google.cloud.tools</groupId>\r\n          <artifactId>jib-maven-plugin</artifactId>\r\n          <configuration>\r\n            <!-- <from> -->\r\n            <!-- <image>gcr.io/distroless/java:debug</image> -->\r\n            <!-- </from> -->\r\n            <to>\r\n              <image>${aws.ecr.url}/${finalName}:latest</image>\r\n            </to>\r\n            <container>\r\n              <creationTime>USE_CURRENT_TIMESTAMP</creationTime>\r\n              <ports>\r\n                <port>8080</port>\r\n              </ports>\r\n            </container>\r\n          </configuration>\r\n        </plugin>\r\n```\n\nComment by chanseokoh:\n@ahoehma thanks for the update.\r\n@Gsealy filed #2535 for your issue.",
        "source_code": null,
        "distance": 0.75,
        "title": "Cannot run program \"docker-credential-ecr-login.cmd\"",
        "name": "issue#2527",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2535"
          },
          {
            "start_node": "issue#2535",
            "description": "referenced by issue",
            "type": "RELATED",
            "end_node": "issue#2527"
          }
        ],
        "similarity": 0.5168799693163607,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2488",
        "type": "issue",
        "content": "Even though `docker push francium25.azurecr.io/hello-world` works, Jib cannot push to Azure Container Registry. Note Jib does retrieve Azure credentials from `~/.docker/config.json`.\r\n```\r\n[INFO] Using credentials from Docker config (.../.docker/config.json) for francium25.azurecr.io/hello-world\r\n```\r\n\r\nNotably, `~/docker/config.json` has `identitytoken` that other `auths` entries don't have. I wonder if this is basically the same issue we've taken care of when using Azure credential helpers (#1490).\r\n```json\r\n    \"auths\": {\r\n       \"francium25.azurecr.io\": {\r\n            \"auth\": \"...\",\r\n            \"identitytoken\": \"...\"\r\n        },\r\n        \"quay.io\": {\r\n            \"auth\": \"...\"\r\n        },\r\n```\r\n\r\nFull log:\r\n```\r\n[INFO] Containerizing application to francium25.azurecr.io/hello-world...\r\n[WARNING] Base image 'gcr.io/distroless/java:8' does not use a specific image digest - build may not be reproducible\r\n[INFO] Using credentials from Docker config (.../.docker/config.json) for francium25.azurecr.io/hello-world\r\n[INFO] Using base image with digest: sha256:f59b26c5ecc735514a38afbf845214383c4e2ba1fdd15a76225339b8ab7da8ef\r\n[INFO] Executing tasks:\r\n[INFO] [=======                       ] 22.2% complete\r\n[INFO] > pulling base image manifest\r\n[INFO] \r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time:  1.530 s\r\n[INFO] Finished at: 2020-05-21T13:50:02-04:00\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.2.0:build (default-cli) on project helloworld: Build image failed, perhaps you should make sure your credentials for 'francium25.azurecr.io/hello-world' are set up correctly. See https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#what-should-i-do-when-the-registry-responds-with-unauthorized for help: Unauthorized for francium25.azurecr.io/hello-world: 401 Unauthorized -> [Help 1]\r\n```\n\n",
        "source_code": null,
        "distance": 0.5,
        "title": "Pushing to Azure Container Registry fails with \"401 Unauthorized\" even though \"docker push\" works",
        "name": "issue#2488",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "pr#2489"
          },
          {
            "start_node": "pr#2489",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2488"
          }
        ],
        "similarity": 0.46345356691036826,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2536",
        "type": "issue",
        "content": "Fixes #2535.\n\n",
        "source_code": null,
        "distance": 0.5,
        "title": "Fix NPE when reading \"auths\" section in ~/.docker/config.json",
        "name": "pr#2536",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2535"
          },
          {
            "start_node": "issue#2535",
            "description": "referenced by issue",
            "type": "RELATED",
            "end_node": "pr#2536"
          }
        ],
        "similarity": 0.36029923175808753,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "1490",
        "type": "issue",
        "content": "The Docker [Credential helper protocol](https://github.com/docker/cli/blob/master/docs/reference/commandline/login.md#credential-helper-protocol) specifies:\r\n> If the secret being stored is an identity token, the Username should be set to `<token>`.\r\n\r\nJib should consider the case where the username received from a credential helper is `<token>` and authenticate by using the `Secret` as an identity token. See https://github.com/Azure/acr-docker-credential-helper/issues/31#issuecomment-457460762 for an example.\r\n\r\nOriginates from https://github.com/Azure/acr-docker-credential-helper/issues/31#issuecomment-465318647\n\n\nComment by andxu:\nI on working on a PR regarding the logic of https://github.com/containerd/containerd/blob/master/remotes/docker/authorizer.go#L189 and https://github.com/docker/distribution/blob/master/registry/client/auth/session.go#L335\r\nto `RegistryAuthenticator` in jib\n\nComment by coollog:\n@andxu thanks! It might be a bit involved and I would recommend outlining your approach here first and splitting the work into multiple subtasks. Let us know if you have any questions!\n\nComment by andxu:\n@coollog Thanks for the advice.  I will post it here later today.\n\nComment by andxu:\nFirst, let's take a look how docker gets the credentials from docker-credential-helper(see inline comments added).  \r\n\r\n```go\r\n    // https://github.com/docker/cli/blob/master/cli/config/credentials/native_store.go#L115 \r\n    // andy: get crendentials from executing echo \"$serverAddress\"|docker-credential-helper get  \r\n    creds, err := client.Get(c.programFunc, serverAddress)\r\n\tif err != nil {\r\n\t\t...\r\n\t}\r\n\r\n    // andy: here tokenUsername  = \"<token>\"\r\n\tif creds.Username == tokenUsername {\r\n\t    // andy: token auth\r\n\t\tret.IdentityToken = creds.Secret\r\n\t} else {\r\n\t    // andy: basic auth\r\n\t\tret.Password = creds.Secret\r\n\t\tret.Username = creds.Username\r\n\t}\r\n\r\n\tret.ServerAddress = serverAddress\r\n```\r\n\r\n```go\r\n// https://github.com/docker/distribution/blob/master/registry/client/auth/session.go#L478\r\nfunc (th *tokenHandler) fetchToken(params map[string]string, scopes []string) (token string, expiration time.Time, err error) {\r\n     ...\r\n    var refreshToken string\r\n\r\n\tif th.creds != nil {\r\n\t\trefreshToken = th.creds.RefreshToken(realmURL, service)\r\n\t}\r\n\r\n\tif refreshToken != \"\" || th.forceOAuth {\r\n\t    // andy: token auth\r\n\t\treturn th.fetchTokenWithOAuth(realmURL, refreshToken, service, scopes)\r\n\t}\r\n\r\n    // andy: basic auth\r\n\treturn th.fetchTokenWithBasicAuth(realmURL, service, scopes)\r\n}\r\n\r\n// https://github.com/docker/cli/blob/ae1618713f83e7da07317d579d0675f578de22fa/cli/trust/trust.go#L89\r\nfunc (scs simpleCredentialStore) RefreshToken(u *url.URL, service string) string {\r\n\treturn scs.auth.IdentityToken\r\n}\r\n\r\n```\r\nThrough above code, in jib, I suggest to change(here takes pull image for example, push is similar):\r\n  \r\n 1. Add a new field named \"refreshToken\" in Credential class, when we get the response from `docker-credential-helper get`, we will check the username, if the username equals `<token>`, then we will save the password as refresh token, otherwise, we save the username and password.\r\n 2. in BaseImageWithAuthorization#call we should not always get the basic auth token(see [code](https://github.com/GoogleContainerTools/jib/blob/master/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java#L150)) and then set the `registryAuthorization` to `registryAuthenticator`, instead we should set the credentials for `registryAuthenticator` before `authenticatePull`.\r\n\r\n```java\r\n    // pseudocode for BaseImageWithAuthorization call()\r\n\r\n    Credential Credential registryCredential = NonBlockingSteps.get(retrieveBaseRegistryCredentialsStep); = NonBlockingSteps.get(retrieveBaseRegistryCredentialsStep);\r\n    \r\n    registryAuthenticator.setCredential(registryCredential).authenticatePull();                    \r\n``` \r\n3. in `RegistryAuthenticator#authenticate`, we should turn into two different ways of retrieving the token. \r\n\r\n```java\r\n    // https://github.com/GoogleContainerTools/jib/blob/master/jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryAuthenticator.java#L264\r\n    // pseudocode\r\n    private Authorization authenticate(String scope) throws RegistryAuthenticationFailedException {\r\n        ...\r\n        AuthenticationResponseTemplate responseJson = null;\r\n        if (credential != null) {\r\n        \tif (StringUtils.isNotBlank(credential.getRefreshToken())) {\r\n        \t\t// example:\r\n\t\t\t// POST:  https://andyreg.azurecr.io/oauth2/token\r\n\t\t\t// Body:  grant_type=refresh_token&service=andyreg.azurecr.io&scope=repository:ubuntu:pull&refresh_token=<eyJhbGciOi...88Q>\r\n        \t\tresponseJson = fetchTokenWithOAuth(credential, realm, service, scope);\r\n        \t} else {\r\n        \t\t// example:\r\n\t\t\t// GET:  https://auth.docker.io/token?service=registry.docker.io&scope=repository:ubuntu:pull\r\n        \t\tresponseJson = fetchTokenWithBasicAuth(credential, realm, service, scope);\r\n        \t}\r\n        }\r\n        \r\n\r\n        if (responseJson.getToken() == null) {\r\n          throw new RegistryAuthenticationFailedException(\r\n              registryEndpointRequestProperties.getServerUrl(),\r\n              registryEndpointRequestProperties.getImageName(),\r\n              \"Did not get token in authentication response from \" + authenticationUrl);\r\n        }\r\n        return Authorizations.withBearerToken(responseJson.getToken());\r\n    }               \r\n```\r\n\r\n\n\nComment by coollog:\n@andxu Thanks for the writeup!\r\n\r\n1. I think we can keep `Credential` as-is for now and have it just store the username/secret that is retrieved as is (so for refresh tokens, the username would be `<token>` and the password would be the refresh token). We can consider changing the API of `Credential` later after this fix is complete (like add a refresh token field or a `isRefreshToken` method).\r\n2. That sounds good, but we should probably keep the current behavior for when the username is not `<token>`.\r\n3. Looks good - feel free to add the `Credential#isRefreshToken` method if needed for this.\n\nComment by andxu:\nI am adding test cases, please take a review of my implementation, thanks \n\nComment by chanseokoh:\nFixed by #1511. Jib will be able to use ACR through an OAuth2 token retrieved from ACR credential helpers.\n\nComment by chanseokoh:\n@andxu v1.0.2 released with the ACR credential helper support. Will work on the doc (#1530) later. Thanks for your awesome contribution!\n\nComment by andxu:\n@coollog @chanseokoh Thank you all for your works to make acr supported.",
        "source_code": null,
        "distance": 1.0,
        "title": "Handle \"<token>\" as Username from credential helpers.",
        "name": "issue#1490",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "pr#2489"
          },
          {
            "start_node": "pr#2489",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2488"
          },
          {
            "start_node": "issue#2488",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#1490"
          }
        ],
        "similarity": 0.27956124750781713,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2489",
        "type": "issue",
        "content": "Fixes #2488.\n\n\nComment by chanseokoh:\n> Is this really only an issue with azure? Can no one else use identity tokens?\r\n\r\nMaybe not only an issue with Azure. But because we've not heard any error report, I think it's safer to keep using `auth` when both `auth` and `identityToken` are given and try to keep the current behavior as much as possible. That is, I'm just fixing the error in this Azure case.",
        "source_code": null,
        "distance": 0.25,
        "title": "Fix Azure auth failure from not using identity token in docker.config auths section",
        "name": "pr#2489",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "pr#2489"
          }
        ],
        "similarity": 0.2723191899325139,
        "end_line": null,
        "signature": null
      },
      {
        "start_line": null,
        "file_path": null,
        "issue_id": "2529",
        "type": "issue",
        "content": "Fixes #2527 \r\n\r\nThe logic to determine whether a file does not exist isn't reliable; in #2527, the exception message was localized. (Note the logic wasn't changed in #2403. We had it like that from the beginning.)\r\n\r\nHowever, I think we still have to rely on `CredentialHelperNotFoundException`. Otherwise, when attempting multiple filenames (.cmd, .exe., no file ext), there's no way to distinguish which one failed because of a wrong filename, insufficient permissions, or an IO error while running.\n\n",
        "source_code": null,
        "distance": 1.0,
        "title": "Also try .exe for cred helpers on Windows",
        "name": "pr#2529",
        "documentation": null,
        "path": [
          {
            "start_node": "root",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "issue#2535"
          },
          {
            "start_node": "issue#2535",
            "description": "referenced by issue",
            "type": "RELATED",
            "end_node": "issue#2527"
          },
          {
            "start_node": "issue#2527",
            "description": "points to issue",
            "type": "RELATED",
            "end_node": "pr#2529"
          }
        ],
        "similarity": 0.14758339835876422,
        "end_line": null,
        "signature": null
      }
    ]
  },
  "artifact_stats": {
    "skipped_due_to_time": 7,
    "valid_related_items": 33
  }
}